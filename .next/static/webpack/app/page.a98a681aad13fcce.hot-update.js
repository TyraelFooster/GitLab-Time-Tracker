"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/gitlab.ts":
/*!***************************!*\
  !*** ./app/lib/gitlab.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchProjectTimeReport: function() { return /* binding */ fetchProjectTimeReport; },\n/* harmony export */   formatDuration: function() { return /* binding */ formatDuration; },\n/* harmony export */   secondsToHours: function() { return /* binding */ secondsToHours; }\n/* harmony export */ });\nconst DEFAULT_GRAPHQL_ENDPOINT = \"https://gitlab.com/api/graphql\";\nconst DEFAULT_ISSUE_PAGE_SIZE = 20;\nconst DEFAULT_TIMELOG_PAGE_SIZE = 100;\nconst ISSUE_TIMELOGS_QUERY = \"\\n  query ProjectIssueTimelogs(\\n    $fullPath: ID!,\\n    $issuesFirst: Int!,\\n    $issuesAfter: String,\\n    $timelogFirst: Int!\\n  ) {\\n    project(fullPath: $fullPath) {\\n      id\\n      name\\n      webUrl\\n      issues(first: $issuesFirst, after: $issuesAfter, sort: UPDATED_DESC) {\\n        nodes {\\n          id\\n          iid\\n          title\\n          webUrl\\n          state\\n          labels(first: 10) {\\n            nodes {\\n              title\\n            }\\n          }\\n          epic {\\n            id\\n            iid\\n            title\\n            webUrl\\n          }\\n          timelogs(first: $timelogFirst) {\\n            nodes {\\n              id\\n              spentAt\\n              timeSpent\\n              summary\\n              user {\\n                id\\n                name\\n                username\\n              }\\n            }\\n          }\\n        }\\n        pageInfo {\\n          hasNextPage\\n          endCursor\\n        }\\n      }\\n    }\\n  }\\n\";\nasync function fetchProjectTimeReport(projectFullPath, credentials, range) {\n    let issuePageSize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : DEFAULT_ISSUE_PAGE_SIZE, timelogPageSize = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : DEFAULT_TIMELOG_PAGE_SIZE;\n    var _credentials_apiUrl;\n    const apiUrl = ((_credentials_apiUrl = credentials.apiUrl) === null || _credentials_apiUrl === void 0 ? void 0 : _credentials_apiUrl.trim()) || DEFAULT_GRAPHQL_ENDPOINT;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(credentials.token)\n    };\n    if (!projectFullPath) {\n        throw new Error(\"Missing GitLab project full path.\");\n    }\n    if (!credentials.token) {\n        throw new Error(\"Missing GitLab access token.\");\n    }\n    const issues = [];\n    let pageInfo = null;\n    let projectMeta = null;\n    do {\n        var _payload_errors, _payload_data;\n        var _pageInfo_endCursor;\n        const response = await fetch(apiUrl, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({\n                query: ISSUE_TIMELOGS_QUERY,\n                variables: {\n                    fullPath: projectFullPath,\n                    issuesFirst: issuePageSize,\n                    issuesAfter: (_pageInfo_endCursor = pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.endCursor) !== null && _pageInfo_endCursor !== void 0 ? _pageInfo_endCursor : null,\n                    timelogFirst: timelogPageSize\n                }\n            })\n        });\n        if (!response.ok) {\n            const message = \"GitLab GraphQL responded with \".concat(response.status, \" \").concat(response.statusText);\n            throw new Error(message);\n        }\n        const payload = await response.json();\n        if ((_payload_errors = payload.errors) === null || _payload_errors === void 0 ? void 0 : _payload_errors.length) {\n            throw new Error(payload.errors.map((err)=>err.message).join(\"; \"));\n        }\n        if (!((_payload_data = payload.data) === null || _payload_data === void 0 ? void 0 : _payload_data.project)) {\n            throw new Error(\"Project not found or access denied.\");\n        }\n        projectMeta = {\n            id: payload.data.project.id,\n            name: payload.data.project.name,\n            webUrl: payload.data.project.webUrl\n        };\n        const currentIssues = payload.data.project.issues.nodes.map((node)=>transformIssueNode(node, range));\n        issues.push(...currentIssues);\n        pageInfo = payload.data.project.issues.pageInfo;\n    }while (pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.hasNextPage);\n    const summary = buildTimeSummary(issues);\n    return {\n        project: projectMeta !== null && projectMeta !== void 0 ? projectMeta : {\n            id: \"unknown\",\n            name: projectFullPath,\n            webUrl: \"\"\n        },\n        issues,\n        summary,\n        range,\n        generatedAt: new Date().toISOString()\n    };\n}\nfunction transformIssueNode(node, range) {\n    var _node_timelogs, _node_labels_nodes, _node_labels;\n    var _node_timelogs_nodes;\n    const timelogs = ((_node_timelogs_nodes = (_node_timelogs = node.timelogs) === null || _node_timelogs === void 0 ? void 0 : _node_timelogs.nodes) !== null && _node_timelogs_nodes !== void 0 ? _node_timelogs_nodes : []).filter((log)=>{\n        if (!log || log.timeSpent <= 0) {\n            return false;\n        }\n        return isWithinRange(log.spentAt, range);\n    }).map((log)=>{\n        var _log_user, _log_user1, _log_user2;\n        var _log_user_id, _log_user_name, _log_user_username;\n        return {\n            id: log.id,\n            spentAt: log.spentAt,\n            seconds: log.timeSpent,\n            summary: log.summary,\n            user: {\n                id: (_log_user_id = (_log_user = log.user) === null || _log_user === void 0 ? void 0 : _log_user.id) !== null && _log_user_id !== void 0 ? _log_user_id : \"unknown\",\n                name: (_log_user_name = (_log_user1 = log.user) === null || _log_user1 === void 0 ? void 0 : _log_user1.name) !== null && _log_user_name !== void 0 ? _log_user_name : \"Unknown\",\n                username: (_log_user_username = (_log_user2 = log.user) === null || _log_user2 === void 0 ? void 0 : _log_user2.username) !== null && _log_user_username !== void 0 ? _log_user_username : \"unknown\"\n            }\n        };\n    });\n    var _node_labels_nodes_map;\n    return {\n        id: node.id,\n        iid: node.iid,\n        title: node.title,\n        webUrl: node.webUrl,\n        state: node.state,\n        labels: (_node_labels_nodes_map = (_node_labels = node.labels) === null || _node_labels === void 0 ? void 0 : (_node_labels_nodes = _node_labels.nodes) === null || _node_labels_nodes === void 0 ? void 0 : _node_labels_nodes.map((label)=>label.title)) !== null && _node_labels_nodes_map !== void 0 ? _node_labels_nodes_map : [],\n        epic: node.epic ? {\n            id: node.epic.id,\n            iid: node.epic.iid,\n            title: node.epic.title,\n            webUrl: node.epic.webUrl\n        } : null,\n        timelogs\n    };\n}\nfunction isWithinRange(spentAt, range) {\n    if (!range.from && !range.to) {\n        return true;\n    }\n    const timestamp = Date.parse(spentAt);\n    if (Number.isNaN(timestamp)) {\n        return true;\n    }\n    if (range.from) {\n        const fromTs = Date.parse(range.from);\n        if (!Number.isNaN(fromTs) && timestamp < fromTs) {\n            return false;\n        }\n    }\n    if (range.to) {\n        const toTs = Date.parse(range.to);\n        if (!Number.isNaN(toTs) && timestamp >= toTs) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction buildTimeSummary(issues) {\n    let totalSeconds = 0;\n    const byUser = new Map();\n    const byIssue = new Map();\n    const byEpic = new Map();\n    const byDate = new Map();\n    const byLabel = new Map();\n    const byState = new Map();\n    const weeklyBuckets = new Map();\n    for (const issue of issues){\n        var _issue_epic, _issue_epic1;\n        let issueSeconds = 0;\n        for (const timelog of issue.timelogs){\n            totalSeconds += timelog.seconds;\n            issueSeconds += timelog.seconds;\n            const dateKey = timelog.spentAt ? timelog.spentAt.slice(0, 10) : \"unknown\";\n            var _byDate_get;\n            byDate.set(dateKey, ((_byDate_get = byDate.get(dateKey)) !== null && _byDate_get !== void 0 ? _byDate_get : 0) + timelog.seconds);\n            const userKey = timelog.user.username || timelog.user.id;\n            var _byUser_get;\n            const userGroup = (_byUser_get = byUser.get(userKey)) !== null && _byUser_get !== void 0 ? _byUser_get : {\n                label: timelog.user.name,\n                seconds: 0,\n                hints: {\n                    username: timelog.user.username\n                }\n            };\n            userGroup.seconds += timelog.seconds;\n            byUser.set(userKey, userGroup);\n            const weekBucket = getWeekBucket(timelog.spentAt);\n            if (weekBucket) {\n                var _weeklyBuckets_get;\n                const aggregate = (_weeklyBuckets_get = weeklyBuckets.get(weekBucket.key)) !== null && _weeklyBuckets_get !== void 0 ? _weeklyBuckets_get : {\n                    weekStart: weekBucket.start,\n                    label: weekBucket.label,\n                    totals: new Map(),\n                    totalSeconds: 0\n                };\n                var _aggregate_totals_get;\n                const userTotals = (_aggregate_totals_get = aggregate.totals.get(userKey)) !== null && _aggregate_totals_get !== void 0 ? _aggregate_totals_get : {\n                    userId: timelog.user.id,\n                    userName: timelog.user.name,\n                    username: timelog.user.username,\n                    seconds: 0\n                };\n                userTotals.seconds += timelog.seconds;\n                aggregate.totals.set(userKey, userTotals);\n                aggregate.totalSeconds += timelog.seconds;\n                weeklyBuckets.set(weekBucket.key, aggregate);\n            }\n        }\n        var _byIssue_get;\n        const issueGroup = (_byIssue_get = byIssue.get(issue.id)) !== null && _byIssue_get !== void 0 ? _byIssue_get : {\n            label: \"#\".concat(issue.iid, \" \").concat(issue.title),\n            seconds: 0,\n            hints: {\n                issueUrl: issue.webUrl,\n                state: issue.state\n            }\n        };\n        issueGroup.seconds += issueSeconds;\n        byIssue.set(issue.id, issueGroup);\n        var _issue_epic_id;\n        const epicKey = (_issue_epic_id = (_issue_epic = issue.epic) === null || _issue_epic === void 0 ? void 0 : _issue_epic.id) !== null && _issue_epic_id !== void 0 ? _issue_epic_id : \"unassigned\";\n        const epicLabel = issue.epic ? issue.epic.title : \"No epic\";\n        var _issue_epic_webUrl, _byEpic_get;\n        const epicGroup = (_byEpic_get = byEpic.get(epicKey)) !== null && _byEpic_get !== void 0 ? _byEpic_get : {\n            label: epicLabel,\n            seconds: 0,\n            hints: {\n                epicUrl: (_issue_epic_webUrl = (_issue_epic1 = issue.epic) === null || _issue_epic1 === void 0 ? void 0 : _issue_epic1.webUrl) !== null && _issue_epic_webUrl !== void 0 ? _issue_epic_webUrl : undefined\n            }\n        };\n        epicGroup.seconds += issueSeconds;\n        byEpic.set(epicKey, epicGroup);\n        const stateKey = issue.state || \"unknown\";\n        var _byState_get;\n        const stateGroup = (_byState_get = byState.get(stateKey)) !== null && _byState_get !== void 0 ? _byState_get : {\n            label: stateKey,\n            seconds: 0\n        };\n        stateGroup.seconds += issueSeconds;\n        byState.set(stateKey, stateGroup);\n        for (const label of issue.labels){\n            var _byLabel_get;\n            const labelGroup = (_byLabel_get = byLabel.get(label)) !== null && _byLabel_get !== void 0 ? _byLabel_get : {\n                label,\n                seconds: 0\n            };\n            labelGroup.seconds += issueSeconds;\n            byLabel.set(label, labelGroup);\n        }\n    }\n    return {\n        totalSeconds,\n        byUser: Array.from(byUser.values()).sort((a, b)=>b.seconds - a.seconds),\n        byIssue: Array.from(byIssue.values()).sort((a, b)=>b.seconds - a.seconds),\n        byEpic: Array.from(byEpic.values()).sort((a, b)=>b.seconds - a.seconds),\n        byLabel: Array.from(byLabel.values()).sort((a, b)=>b.seconds - a.seconds),\n        byState: Array.from(byState.values()).sort((a, b)=>b.seconds - a.seconds),\n        byDate: Array.from(byDate.entries()).map((param)=>{\n            let [date, seconds] = param;\n            return {\n                date,\n                seconds\n            };\n        }).sort((a, b)=>a.date.localeCompare(b.date)),\n        weeklyByUser: Array.from(weeklyBuckets.values()).map((bucket)=>({\n                weekStart: bucket.weekStart,\n                label: bucket.label,\n                totals: Array.from(bucket.totals.values()).sort((a, b)=>b.seconds - a.seconds),\n                totalSeconds: bucket.totalSeconds\n            })).sort((a, b)=>a.weekStart.localeCompare(b.weekStart))\n    };\n}\nfunction secondsToHours(seconds) {\n    return Math.round(seconds / 3600 * 100) / 100;\n}\nfunction formatDuration(seconds) {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor(seconds % 3600 / 60);\n    if (hours === 0 && minutes === 0) {\n        return \"<1m\";\n    }\n    if (hours === 0) {\n        return \"\".concat(minutes, \"m\");\n    }\n    if (minutes === 0) {\n        return \"\".concat(hours, \"h\");\n    }\n    return \"\".concat(hours, \"h \").concat(minutes, \"m\");\n}\nfunction getWeekBucket(spentAt) {\n    const timestamp = Date.parse(spentAt);\n    if (Number.isNaN(timestamp)) {\n        return null;\n    }\n    const weekStartDate = startOfWeek(new Date(timestamp));\n    const start = isoDateOnly(weekStartDate);\n    return {\n        key: start,\n        start,\n        label: formatWeekLabel(weekStartDate)\n    };\n}\nfunction startOfWeek(date) {\n    const start = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));\n    const day = start.getUTCDay();\n    const diff = day === 0 ? -6 : 1 - day;\n    start.setUTCDate(start.getUTCDate() + diff);\n    return start;\n}\nfunction isoDateOnly(date) {\n    return date.toISOString().slice(0, 10);\n}\nfunction formatWeekLabel(date) {\n    const formatter = new Intl.DateTimeFormat(undefined, {\n        month: \"short\",\n        day: \"numeric\"\n    });\n    return \"Week of \".concat(formatter.format(date));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTQyxZQUFZWixJQUFVO0lBQzdCLE1BQU1yQixRQUFRLElBQUlqRCxLQUFLQSxLQUFLcUYsR0FBRyxDQUFDZixLQUFLZ0IsY0FBYyxJQUFJaEIsS0FBS2lCLFdBQVcsSUFBSWpCLEtBQUtrQixVQUFVO0lBQzFGLE1BQU1DLE1BQU14QyxNQUFNeUMsU0FBUztJQUMzQixNQUFNQyxPQUFPRixRQUFRLElBQUksQ0FBQyxJQUFJLElBQUlBO0lBQ2xDeEMsTUFBTTJDLFVBQVUsQ0FBQzNDLE1BQU11QyxVQUFVLEtBQUtHO0lBQ3RDLE9BQU8xQztBQUNUO0FBRUEsU0FBU2tDLFlBQVliLElBQVU7SUFDN0IsT0FBT0EsS0FBS3JFLFdBQVcsR0FBR3FDLEtBQUssQ0FBQyxHQUFHO0FBQ3JDO0FBRUEsU0FBUzhDLGdCQUFnQmQsSUFBVTtJQUNqQyxNQUFNdUIsWUFBWSxJQUFJQyxLQUFLQyxjQUFjLENBQUNuQyxXQUFXO1FBQ25Eb0MsT0FBTztRQUNQUCxLQUFLO0lBQ1A7SUFDQSxPQUFPLFdBQWtDLE9BQXZCSSxVQUFVSSxNQUFNLENBQUMzQjtBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL2dpdGxhYi50cz85OWY4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IERFRkFVTFRfR1JBUEhRTF9FTkRQT0lOVCA9IFwiaHR0cHM6Ly9naXRsYWIuY29tL2FwaS9ncmFwaHFsXCI7XG5jb25zdCBERUZBVUxUX0lTU1VFX1BBR0VfU0laRSA9IDIwO1xuY29uc3QgREVGQVVMVF9USU1FTE9HX1BBR0VfU0laRSA9IDEwMDtcblxuZXhwb3J0IGludGVyZmFjZSBHaXRMYWJDcmVkZW50aWFscyB7XG4gIGFwaVVybD86IHN0cmluZztcbiAgdG9rZW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaW1lUmFuZ2VGaWx0ZXIge1xuICBmcm9tPzogc3RyaW5nO1xuICB0bz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXZWVrbHlVc2VyVG90YWwge1xuICB1c2VySWQ6IHN0cmluZztcbiAgdXNlck5hbWU6IHN0cmluZztcbiAgdXNlcm5hbWU6IHN0cmluZztcbiAgc2Vjb25kczogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlZWtseVVzZXJTdW1tYXJ5IHtcbiAgd2Vla1N0YXJ0OiBzdHJpbmc7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIHRvdGFsczogV2Vla2x5VXNlclRvdGFsW107XG4gIHRvdGFsU2Vjb25kczogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbW1pdEFjdGl2aXR5RGF5IHtcbiAgZGF0ZTogc3RyaW5nO1xuICBjb3VudDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbW1pdFJhbmdlIHtcbiAgbW9udGg6IHN0cmluZztcbiAgZnJvbTogc3RyaW5nO1xuICB0bzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdpdExhYklzc3VlVGltZWxvZyB7XG4gIGlkOiBzdHJpbmc7XG4gIHNwZW50QXQ6IHN0cmluZztcbiAgc2Vjb25kczogbnVtYmVyO1xuICB1c2VyOiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgdXNlcm5hbWU6IHN0cmluZztcbiAgfTtcbiAgc3VtbWFyeT86IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2l0TGFiSXNzdWVUaW1lIHtcbiAgaWQ6IHN0cmluZztcbiAgaWlkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHdlYlVybDogc3RyaW5nO1xuICBzdGF0ZTogc3RyaW5nO1xuICBsYWJlbHM6IHN0cmluZ1tdO1xuICBlcGljPzoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgaWlkPzogc3RyaW5nIHwgbnVsbDtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHdlYlVybD86IHN0cmluZyB8IG51bGw7XG4gIH0gfCBudWxsO1xuICB0aW1lbG9nczogR2l0TGFiSXNzdWVUaW1lbG9nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdFRpbWVSZXBvcnQge1xuICBwcm9qZWN0OiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgd2ViVXJsOiBzdHJpbmc7XG4gIH07XG4gIGlzc3VlczogR2l0TGFiSXNzdWVUaW1lW107XG4gIHN1bW1hcnk6IFRpbWVTdW1tYXJ5O1xuICByYW5nZTogVGltZVJhbmdlRmlsdGVyO1xuICBnZW5lcmF0ZWRBdDogc3RyaW5nO1xuICBjb21taXRBY3Rpdml0eT86IENvbW1pdEFjdGl2aXR5RGF5W107XG4gIGNvbW1pdFJhbmdlPzogQ29tbWl0UmFuZ2UgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVTdW1tYXJ5R3JvdXAge1xuICBsYWJlbDogc3RyaW5nO1xuICBzZWNvbmRzOiBudW1iZXI7XG4gIGhpbnRzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaW1lU3VtbWFyeSB7XG4gIHRvdGFsU2Vjb25kczogbnVtYmVyO1xuICBieVVzZXI6IFRpbWVTdW1tYXJ5R3JvdXBbXTtcbiAgYnlJc3N1ZTogVGltZVN1bW1hcnlHcm91cFtdO1xuICBieUVwaWM6IFRpbWVTdW1tYXJ5R3JvdXBbXTtcbiAgYnlMYWJlbDogVGltZVN1bW1hcnlHcm91cFtdO1xuICBieVN0YXRlOiBUaW1lU3VtbWFyeUdyb3VwW107XG4gIGJ5RGF0ZTogeyBkYXRlOiBzdHJpbmc7IHNlY29uZHM6IG51bWJlciB9W107XG4gIHdlZWtseUJ5VXNlcjogV2Vla2x5VXNlclN1bW1hcnlbXTtcbn1cblxuaW50ZXJmYWNlIEdyYXBoUUxJc3N1ZU5vZGUge1xuICBpZDogc3RyaW5nO1xuICBpaWQ6IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgd2ViVXJsOiBzdHJpbmc7XG4gIHN0YXRlOiBzdHJpbmc7XG4gIGxhYmVsczogeyBub2RlczogQXJyYXk8eyB0aXRsZTogc3RyaW5nIH0+IH07XG4gIGVwaWM/OiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBpaWQ6IHN0cmluZyB8IG51bGw7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICB3ZWJVcmw6IHN0cmluZyB8IG51bGw7XG4gIH0gfCBudWxsO1xuICB0aW1lbG9nczoge1xuICAgIG5vZGVzOiBBcnJheTx7XG4gICAgICBpZDogc3RyaW5nO1xuICAgICAgc3BlbnRBdDogc3RyaW5nO1xuICAgICAgdGltZVNwZW50OiBudW1iZXI7XG4gICAgICBzdW1tYXJ5OiBzdHJpbmcgfCBudWxsO1xuICAgICAgdXNlcj86IHtcbiAgICAgICAgaWQ6IHN0cmluZztcbiAgICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgICB1c2VybmFtZTogc3RyaW5nO1xuICAgICAgfSB8IG51bGw7XG4gICAgfT47XG4gIH07XG59XG5cbmludGVyZmFjZSBHcmFwaFFMUmVzcG9uc2U8VD4ge1xuICBkYXRhPzogVDtcbiAgZXJyb3JzPzogQXJyYXk8eyBtZXNzYWdlOiBzdHJpbmcgfT47XG59XG5cbmludGVyZmFjZSBJc3N1ZVBhZ2VQYXlsb2FkIHtcbiAgcHJvamVjdDoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHdlYlVybDogc3RyaW5nO1xuICAgIGlzc3Vlczoge1xuICAgICAgbm9kZXM6IEdyYXBoUUxJc3N1ZU5vZGVbXTtcbiAgICAgIHBhZ2VJbmZvOiB7XG4gICAgICAgIGhhc05leHRQYWdlOiBib29sZWFuO1xuICAgICAgICBlbmRDdXJzb3I6IHN0cmluZyB8IG51bGw7XG4gICAgICB9O1xuICAgIH07XG4gIH0gfCBudWxsO1xufVxuXG5jb25zdCBJU1NVRV9USU1FTE9HU19RVUVSWSA9IGBcbiAgcXVlcnkgUHJvamVjdElzc3VlVGltZWxvZ3MoXG4gICAgJGZ1bGxQYXRoOiBJRCEsXG4gICAgJGlzc3Vlc0ZpcnN0OiBJbnQhLFxuICAgICRpc3N1ZXNBZnRlcjogU3RyaW5nLFxuICAgICR0aW1lbG9nRmlyc3Q6IEludCFcbiAgKSB7XG4gICAgcHJvamVjdChmdWxsUGF0aDogJGZ1bGxQYXRoKSB7XG4gICAgICBpZFxuICAgICAgbmFtZVxuICAgICAgd2ViVXJsXG4gICAgICBpc3N1ZXMoZmlyc3Q6ICRpc3N1ZXNGaXJzdCwgYWZ0ZXI6ICRpc3N1ZXNBZnRlciwgc29ydDogVVBEQVRFRF9ERVNDKSB7XG4gICAgICAgIG5vZGVzIHtcbiAgICAgICAgICBpZFxuICAgICAgICAgIGlpZFxuICAgICAgICAgIHRpdGxlXG4gICAgICAgICAgd2ViVXJsXG4gICAgICAgICAgc3RhdGVcbiAgICAgICAgICBsYWJlbHMoZmlyc3Q6IDEwKSB7XG4gICAgICAgICAgICBub2RlcyB7XG4gICAgICAgICAgICAgIHRpdGxlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVwaWMge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIGlpZFxuICAgICAgICAgICAgdGl0bGVcbiAgICAgICAgICAgIHdlYlVybFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aW1lbG9ncyhmaXJzdDogJHRpbWVsb2dGaXJzdCkge1xuICAgICAgICAgICAgbm9kZXMge1xuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICBzcGVudEF0XG4gICAgICAgICAgICAgIHRpbWVTcGVudFxuICAgICAgICAgICAgICBzdW1tYXJ5XG4gICAgICAgICAgICAgIHVzZXIge1xuICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgIHVzZXJuYW1lXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFnZUluZm8ge1xuICAgICAgICAgIGhhc05leHRQYWdlXG4gICAgICAgICAgZW5kQ3Vyc29yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbmA7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFByb2plY3RUaW1lUmVwb3J0KFxuICBwcm9qZWN0RnVsbFBhdGg6IHN0cmluZyxcbiAgY3JlZGVudGlhbHM6IEdpdExhYkNyZWRlbnRpYWxzLFxuICByYW5nZTogVGltZVJhbmdlRmlsdGVyLFxuICBpc3N1ZVBhZ2VTaXplOiBudW1iZXIgPSBERUZBVUxUX0lTU1VFX1BBR0VfU0laRSxcbiAgdGltZWxvZ1BhZ2VTaXplOiBudW1iZXIgPSBERUZBVUxUX1RJTUVMT0dfUEFHRV9TSVpFXG4pOiBQcm9taXNlPFByb2plY3RUaW1lUmVwb3J0PiB7XG4gIGNvbnN0IGFwaVVybCA9IGNyZWRlbnRpYWxzLmFwaVVybD8udHJpbSgpIHx8IERFRkFVTFRfR1JBUEhRTF9FTkRQT0lOVDtcbiAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Y3JlZGVudGlhbHMudG9rZW59YFxuICB9O1xuXG4gIGlmICghcHJvamVjdEZ1bGxQYXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBHaXRMYWIgcHJvamVjdCBmdWxsIHBhdGguXCIpO1xuICB9XG5cbiAgaWYgKCFjcmVkZW50aWFscy50b2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgR2l0TGFiIGFjY2VzcyB0b2tlbi5cIik7XG4gIH1cblxuICBjb25zdCBpc3N1ZXM6IEdpdExhYklzc3VlVGltZVtdID0gW107XG4gIGxldCBwYWdlSW5mbzogeyBoYXNOZXh0UGFnZTogYm9vbGVhbjsgZW5kQ3Vyc29yOiBzdHJpbmcgfCBudWxsIH0gfCBudWxsID0gbnVsbDtcbiAgbGV0IHByb2plY3RNZXRhOiB7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgd2ViVXJsOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsO1xuXG4gIGRvIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFwaVVybCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHF1ZXJ5OiBJU1NVRV9USU1FTE9HU19RVUVSWSxcbiAgICAgICAgdmFyaWFibGVzOiB7XG4gICAgICAgICAgZnVsbFBhdGg6IHByb2plY3RGdWxsUGF0aCxcbiAgICAgICAgICBpc3N1ZXNGaXJzdDogaXNzdWVQYWdlU2l6ZSxcbiAgICAgICAgICBpc3N1ZXNBZnRlcjogcGFnZUluZm8/LmVuZEN1cnNvciA/PyBudWxsLFxuICAgICAgICAgIHRpbWVsb2dGaXJzdDogdGltZWxvZ1BhZ2VTaXplXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYEdpdExhYiBHcmFwaFFMIHJlc3BvbmRlZCB3aXRoICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXlsb2FkID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSkgYXMgR3JhcGhRTFJlc3BvbnNlPElzc3VlUGFnZVBheWxvYWQ+O1xuXG4gICAgaWYgKHBheWxvYWQuZXJyb3JzPy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwYXlsb2FkLmVycm9ycy5tYXAoKGVycikgPT4gZXJyLm1lc3NhZ2UpLmpvaW4oXCI7IFwiKSk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXlsb2FkLmRhdGE/LnByb2plY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb2plY3Qgbm90IGZvdW5kIG9yIGFjY2VzcyBkZW5pZWQuXCIpO1xuICAgIH1cblxuICAgIHByb2plY3RNZXRhID0ge1xuICAgICAgaWQ6IHBheWxvYWQuZGF0YS5wcm9qZWN0LmlkLFxuICAgICAgbmFtZTogcGF5bG9hZC5kYXRhLnByb2plY3QubmFtZSxcbiAgICAgIHdlYlVybDogcGF5bG9hZC5kYXRhLnByb2plY3Qud2ViVXJsXG4gICAgfTtcblxuICAgIGNvbnN0IGN1cnJlbnRJc3N1ZXMgPSBwYXlsb2FkLmRhdGEucHJvamVjdC5pc3N1ZXMubm9kZXMubWFwKChub2RlKSA9PlxuICAgICAgdHJhbnNmb3JtSXNzdWVOb2RlKG5vZGUsIHJhbmdlKVxuICAgICk7XG4gICAgaXNzdWVzLnB1c2goLi4uY3VycmVudElzc3Vlcyk7XG5cbiAgICBwYWdlSW5mbyA9IHBheWxvYWQuZGF0YS5wcm9qZWN0Lmlzc3Vlcy5wYWdlSW5mbztcbiAgfSB3aGlsZSAocGFnZUluZm8/Lmhhc05leHRQYWdlKTtcblxuICBjb25zdCBzdW1tYXJ5ID0gYnVpbGRUaW1lU3VtbWFyeShpc3N1ZXMpO1xuXG4gIHJldHVybiB7XG4gICAgcHJvamVjdDogcHJvamVjdE1ldGEgPz8ge1xuICAgICAgaWQ6IFwidW5rbm93blwiLFxuICAgICAgbmFtZTogcHJvamVjdEZ1bGxQYXRoLFxuICAgICAgd2ViVXJsOiBcIlwiXG4gICAgfSxcbiAgICBpc3N1ZXMsXG4gICAgc3VtbWFyeSxcbiAgICByYW5nZSxcbiAgICBnZW5lcmF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUlzc3VlTm9kZShcbiAgbm9kZTogR3JhcGhRTElzc3VlTm9kZSxcbiAgcmFuZ2U6IFRpbWVSYW5nZUZpbHRlclxuKTogR2l0TGFiSXNzdWVUaW1lIHtcbiAgY29uc3QgdGltZWxvZ3MgPSAobm9kZS50aW1lbG9ncz8ubm9kZXMgPz8gW10pXG4gICAgLmZpbHRlcigobG9nKTogbG9nIGlzIE5vbk51bGxhYmxlPHR5cGVvZiBsb2c+ID0+IHtcbiAgICAgIGlmICghbG9nIHx8IGxvZy50aW1lU3BlbnQgPD0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNXaXRoaW5SYW5nZShsb2cuc3BlbnRBdCwgcmFuZ2UpO1xuICAgIH0pXG4gICAgLm1hcCgobG9nKSA9PiAoe1xuICAgICAgaWQ6IGxvZy5pZCxcbiAgICAgIHNwZW50QXQ6IGxvZy5zcGVudEF0LFxuICAgICAgc2Vjb25kczogbG9nLnRpbWVTcGVudCxcbiAgICAgIHN1bW1hcnk6IGxvZy5zdW1tYXJ5LFxuICAgICAgdXNlcjoge1xuICAgICAgICBpZDogbG9nLnVzZXI/LmlkID8/IFwidW5rbm93blwiLFxuICAgICAgICBuYW1lOiBsb2cudXNlcj8ubmFtZSA/PyBcIlVua25vd25cIixcbiAgICAgICAgdXNlcm5hbWU6IGxvZy51c2VyPy51c2VybmFtZSA/PyBcInVua25vd25cIlxuICAgICAgfVxuICAgIH0pKTtcblxuICByZXR1cm4ge1xuICAgIGlkOiBub2RlLmlkLFxuICAgIGlpZDogbm9kZS5paWQsXG4gICAgdGl0bGU6IG5vZGUudGl0bGUsXG4gICAgd2ViVXJsOiBub2RlLndlYlVybCxcbiAgICBzdGF0ZTogbm9kZS5zdGF0ZSxcbiAgICBsYWJlbHM6IG5vZGUubGFiZWxzPy5ub2Rlcz8ubWFwKChsYWJlbCkgPT4gbGFiZWwudGl0bGUpID8/IFtdLFxuICAgIGVwaWM6IG5vZGUuZXBpY1xuICAgICAgPyB7XG4gICAgICAgICAgaWQ6IG5vZGUuZXBpYy5pZCxcbiAgICAgICAgICBpaWQ6IG5vZGUuZXBpYy5paWQsXG4gICAgICAgICAgdGl0bGU6IG5vZGUuZXBpYy50aXRsZSxcbiAgICAgICAgICB3ZWJVcmw6IG5vZGUuZXBpYy53ZWJVcmxcbiAgICAgICAgfVxuICAgICAgOiBudWxsLFxuICAgIHRpbWVsb2dzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzV2l0aGluUmFuZ2Uoc3BlbnRBdDogc3RyaW5nLCByYW5nZTogVGltZVJhbmdlRmlsdGVyKTogYm9vbGVhbiB7XG4gIGlmICghcmFuZ2UuZnJvbSAmJiAhcmFuZ2UudG8pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUucGFyc2Uoc3BlbnRBdCk7XG4gIGlmIChOdW1iZXIuaXNOYU4odGltZXN0YW1wKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHJhbmdlLmZyb20pIHtcbiAgICBjb25zdCBmcm9tVHMgPSBEYXRlLnBhcnNlKHJhbmdlLmZyb20pO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKGZyb21UcykgJiYgdGltZXN0YW1wIDwgZnJvbVRzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJhbmdlLnRvKSB7XG4gICAgY29uc3QgdG9UcyA9IERhdGUucGFyc2UocmFuZ2UudG8pO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHRvVHMpICYmIHRpbWVzdGFtcCA+PSB0b1RzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVGltZVN1bW1hcnkoaXNzdWVzOiBHaXRMYWJJc3N1ZVRpbWVbXSk6IFRpbWVTdW1tYXJ5IHtcbiAgbGV0IHRvdGFsU2Vjb25kcyA9IDA7XG4gIGNvbnN0IGJ5VXNlciA9IG5ldyBNYXA8c3RyaW5nLCBUaW1lU3VtbWFyeUdyb3VwPigpO1xuICBjb25zdCBieUlzc3VlID0gbmV3IE1hcDxzdHJpbmcsIFRpbWVTdW1tYXJ5R3JvdXA+KCk7XG4gIGNvbnN0IGJ5RXBpYyA9IG5ldyBNYXA8c3RyaW5nLCBUaW1lU3VtbWFyeUdyb3VwPigpO1xuICBjb25zdCBieURhdGUgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuICBjb25zdCBieUxhYmVsID0gbmV3IE1hcDxzdHJpbmcsIFRpbWVTdW1tYXJ5R3JvdXA+KCk7XG4gIGNvbnN0IGJ5U3RhdGUgPSBuZXcgTWFwPHN0cmluZywgVGltZVN1bW1hcnlHcm91cD4oKTtcbiAgY29uc3Qgd2Vla2x5QnVja2V0cyA9IG5ldyBNYXA8XG4gICAgc3RyaW5nLFxuICAgIHtcbiAgICAgIHdlZWtTdGFydDogc3RyaW5nO1xuICAgICAgbGFiZWw6IHN0cmluZztcbiAgICAgIHRvdGFsczogTWFwPHN0cmluZywgV2Vla2x5VXNlclRvdGFsPjtcbiAgICAgIHRvdGFsU2Vjb25kczogbnVtYmVyO1xuICAgIH1cbiAgPigpO1xuXG4gIGZvciAoY29uc3QgaXNzdWUgb2YgaXNzdWVzKSB7XG4gICAgbGV0IGlzc3VlU2Vjb25kcyA9IDA7XG4gICAgZm9yIChjb25zdCB0aW1lbG9nIG9mIGlzc3VlLnRpbWVsb2dzKSB7XG4gICAgICB0b3RhbFNlY29uZHMgKz0gdGltZWxvZy5zZWNvbmRzO1xuICAgICAgaXNzdWVTZWNvbmRzICs9IHRpbWVsb2cuc2Vjb25kcztcblxuICAgICAgY29uc3QgZGF0ZUtleSA9IHRpbWVsb2cuc3BlbnRBdCA/IHRpbWVsb2cuc3BlbnRBdC5zbGljZSgwLCAxMCkgOiBcInVua25vd25cIjtcbiAgICAgIGJ5RGF0ZS5zZXQoZGF0ZUtleSwgKGJ5RGF0ZS5nZXQoZGF0ZUtleSkgPz8gMCkgKyB0aW1lbG9nLnNlY29uZHMpO1xuXG4gICAgICBjb25zdCB1c2VyS2V5ID0gdGltZWxvZy51c2VyLnVzZXJuYW1lIHx8IHRpbWVsb2cudXNlci5pZDtcbiAgICAgIGNvbnN0IHVzZXJHcm91cCA9IGJ5VXNlci5nZXQodXNlcktleSkgPz8ge1xuICAgICAgICBsYWJlbDogdGltZWxvZy51c2VyLm5hbWUsXG4gICAgICAgIHNlY29uZHM6IDAsXG4gICAgICAgIGhpbnRzOiB7XG4gICAgICAgICAgdXNlcm5hbWU6IHRpbWVsb2cudXNlci51c2VybmFtZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXNlckdyb3VwLnNlY29uZHMgKz0gdGltZWxvZy5zZWNvbmRzO1xuICAgICAgYnlVc2VyLnNldCh1c2VyS2V5LCB1c2VyR3JvdXApO1xuXG4gICAgICBjb25zdCB3ZWVrQnVja2V0ID0gZ2V0V2Vla0J1Y2tldCh0aW1lbG9nLnNwZW50QXQpO1xuICAgICAgaWYgKHdlZWtCdWNrZXQpIHtcbiAgICAgICAgY29uc3QgYWdncmVnYXRlID1cbiAgICAgICAgICB3ZWVrbHlCdWNrZXRzLmdldCh3ZWVrQnVja2V0LmtleSkgPz9cbiAgICAgICAgICB7XG4gICAgICAgICAgICB3ZWVrU3RhcnQ6IHdlZWtCdWNrZXQuc3RhcnQsXG4gICAgICAgICAgICBsYWJlbDogd2Vla0J1Y2tldC5sYWJlbCxcbiAgICAgICAgICAgIHRvdGFsczogbmV3IE1hcDxzdHJpbmcsIFdlZWtseVVzZXJUb3RhbD4oKSxcbiAgICAgICAgICAgIHRvdGFsU2Vjb25kczogMFxuICAgICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVzZXJUb3RhbHMgPVxuICAgICAgICAgIGFnZ3JlZ2F0ZS50b3RhbHMuZ2V0KHVzZXJLZXkpID8/XG4gICAgICAgICAge1xuICAgICAgICAgICAgdXNlcklkOiB0aW1lbG9nLnVzZXIuaWQsXG4gICAgICAgICAgICB1c2VyTmFtZTogdGltZWxvZy51c2VyLm5hbWUsXG4gICAgICAgICAgICB1c2VybmFtZTogdGltZWxvZy51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgc2Vjb25kczogMFxuICAgICAgICAgIH07XG4gICAgICAgIHVzZXJUb3RhbHMuc2Vjb25kcyArPSB0aW1lbG9nLnNlY29uZHM7XG4gICAgICAgIGFnZ3JlZ2F0ZS50b3RhbHMuc2V0KHVzZXJLZXksIHVzZXJUb3RhbHMpO1xuICAgICAgICBhZ2dyZWdhdGUudG90YWxTZWNvbmRzICs9IHRpbWVsb2cuc2Vjb25kcztcbiAgICAgICAgd2Vla2x5QnVja2V0cy5zZXQod2Vla0J1Y2tldC5rZXksIGFnZ3JlZ2F0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaXNzdWVHcm91cCA9IGJ5SXNzdWUuZ2V0KGlzc3VlLmlkKSA/PyB7XG4gICAgICBsYWJlbDogYCMke2lzc3VlLmlpZH0gJHtpc3N1ZS50aXRsZX1gLFxuICAgICAgc2Vjb25kczogMCxcbiAgICAgIGhpbnRzOiB7XG4gICAgICAgIGlzc3VlVXJsOiBpc3N1ZS53ZWJVcmwsXG4gICAgICAgIHN0YXRlOiBpc3N1ZS5zdGF0ZVxuICAgICAgfVxuICAgIH07XG4gICAgaXNzdWVHcm91cC5zZWNvbmRzICs9IGlzc3VlU2Vjb25kcztcbiAgICBieUlzc3VlLnNldChpc3N1ZS5pZCwgaXNzdWVHcm91cCk7XG5cbiAgICBjb25zdCBlcGljS2V5ID0gaXNzdWUuZXBpYz8uaWQgPz8gXCJ1bmFzc2lnbmVkXCI7XG4gICAgY29uc3QgZXBpY0xhYmVsID0gaXNzdWUuZXBpYyA/IGlzc3VlLmVwaWMudGl0bGUgOiBcIk5vIGVwaWNcIjtcbiAgICBjb25zdCBlcGljR3JvdXAgPSBieUVwaWMuZ2V0KGVwaWNLZXkpID8/IHtcbiAgICAgIGxhYmVsOiBlcGljTGFiZWwsXG4gICAgICBzZWNvbmRzOiAwLFxuICAgICAgaGludHM6IHtcbiAgICAgICAgZXBpY1VybDogaXNzdWUuZXBpYz8ud2ViVXJsID8/IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH07XG4gICAgZXBpY0dyb3VwLnNlY29uZHMgKz0gaXNzdWVTZWNvbmRzO1xuICAgIGJ5RXBpYy5zZXQoZXBpY0tleSwgZXBpY0dyb3VwKTtcblxuICAgIGNvbnN0IHN0YXRlS2V5ID0gaXNzdWUuc3RhdGUgfHwgXCJ1bmtub3duXCI7XG4gICAgY29uc3Qgc3RhdGVHcm91cCA9IGJ5U3RhdGUuZ2V0KHN0YXRlS2V5KSA/PyB7XG4gICAgICBsYWJlbDogc3RhdGVLZXksXG4gICAgICBzZWNvbmRzOiAwXG4gICAgfTtcbiAgICBzdGF0ZUdyb3VwLnNlY29uZHMgKz0gaXNzdWVTZWNvbmRzO1xuICAgIGJ5U3RhdGUuc2V0KHN0YXRlS2V5LCBzdGF0ZUdyb3VwKTtcblxuICAgIGZvciAoY29uc3QgbGFiZWwgb2YgaXNzdWUubGFiZWxzKSB7XG4gICAgICBjb25zdCBsYWJlbEdyb3VwID0gYnlMYWJlbC5nZXQobGFiZWwpID8/IHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIHNlY29uZHM6IDBcbiAgICAgIH07XG4gICAgICBsYWJlbEdyb3VwLnNlY29uZHMgKz0gaXNzdWVTZWNvbmRzO1xuICAgICAgYnlMYWJlbC5zZXQobGFiZWwsIGxhYmVsR3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG90YWxTZWNvbmRzLFxuICAgIGJ5VXNlcjogQXJyYXkuZnJvbShieVVzZXIudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGIuc2Vjb25kcyAtIGEuc2Vjb25kcyksXG4gICAgYnlJc3N1ZTogQXJyYXkuZnJvbShieUlzc3VlLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiBiLnNlY29uZHMgLSBhLnNlY29uZHMpLFxuICAgIGJ5RXBpYzogQXJyYXkuZnJvbShieUVwaWMudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGIuc2Vjb25kcyAtIGEuc2Vjb25kcyksXG4gICAgYnlMYWJlbDogQXJyYXkuZnJvbShieUxhYmVsLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiBiLnNlY29uZHMgLSBhLnNlY29uZHMpLFxuICAgIGJ5U3RhdGU6IEFycmF5LmZyb20oYnlTdGF0ZS52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4gYi5zZWNvbmRzIC0gYS5zZWNvbmRzKSxcbiAgICBieURhdGU6IEFycmF5LmZyb20oYnlEYXRlLmVudHJpZXMoKSlcbiAgICAgIC5tYXAoKFtkYXRlLCBzZWNvbmRzXSkgPT4gKHsgZGF0ZSwgc2Vjb25kcyB9KSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmRhdGUubG9jYWxlQ29tcGFyZShiLmRhdGUpKSxcbiAgICB3ZWVrbHlCeVVzZXI6IEFycmF5LmZyb20od2Vla2x5QnVja2V0cy52YWx1ZXMoKSlcbiAgICAgIC5tYXAoKGJ1Y2tldCkgPT4gKHtcbiAgICAgICAgd2Vla1N0YXJ0OiBidWNrZXQud2Vla1N0YXJ0LFxuICAgICAgICBsYWJlbDogYnVja2V0LmxhYmVsLFxuICAgICAgICB0b3RhbHM6IEFycmF5LmZyb20oYnVja2V0LnRvdGFscy52YWx1ZXMoKSkuc29ydChcbiAgICAgICAgICAoYSwgYikgPT4gYi5zZWNvbmRzIC0gYS5zZWNvbmRzXG4gICAgICAgICksXG4gICAgICAgIHRvdGFsU2Vjb25kczogYnVja2V0LnRvdGFsU2Vjb25kc1xuICAgICAgfSkpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS53ZWVrU3RhcnQubG9jYWxlQ29tcGFyZShiLndlZWtTdGFydCkpXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWNvbmRzVG9Ib3VycyhzZWNvbmRzOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5yb3VuZCgoc2Vjb25kcyAvIDM2MDApICogMTAwKSAvIDEwMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdER1cmF0aW9uKHNlY29uZHM6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gMzYwMCk7XG4gIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKChzZWNvbmRzICUgMzYwMCkgLyA2MCk7XG4gIGlmIChob3VycyA9PT0gMCAmJiBtaW51dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIFwiPDFtXCI7XG4gIH1cbiAgaWYgKGhvdXJzID09PSAwKSB7XG4gICAgcmV0dXJuIGAke21pbnV0ZXN9bWA7XG4gIH1cbiAgaWYgKG1pbnV0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gYCR7aG91cnN9aGA7XG4gIH1cbiAgcmV0dXJuIGAke2hvdXJzfWggJHttaW51dGVzfW1gO1xufVxuXG5mdW5jdGlvbiBnZXRXZWVrQnVja2V0KHNwZW50QXQ6IHN0cmluZyk6IHsga2V5OiBzdHJpbmc7IHN0YXJ0OiBzdHJpbmc7IGxhYmVsOiBzdHJpbmcgfSB8IG51bGwge1xuICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLnBhcnNlKHNwZW50QXQpO1xuICBpZiAoTnVtYmVyLmlzTmFOKHRpbWVzdGFtcCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB3ZWVrU3RhcnREYXRlID0gc3RhcnRPZldlZWsobmV3IERhdGUodGltZXN0YW1wKSk7XG4gIGNvbnN0IHN0YXJ0ID0gaXNvRGF0ZU9ubHkod2Vla1N0YXJ0RGF0ZSk7XG4gIHJldHVybiB7XG4gICAga2V5OiBzdGFydCxcbiAgICBzdGFydCxcbiAgICBsYWJlbDogZm9ybWF0V2Vla0xhYmVsKHdlZWtTdGFydERhdGUpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0YXJ0T2ZXZWVrKGRhdGU6IERhdGUpOiBEYXRlIHtcbiAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZShEYXRlLlVUQyhkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgZGF0ZS5nZXRVVENEYXRlKCkpKTtcbiAgY29uc3QgZGF5ID0gc3RhcnQuZ2V0VVRDRGF5KCk7XG4gIGNvbnN0IGRpZmYgPSBkYXkgPT09IDAgPyAtNiA6IDEgLSBkYXk7XG4gIHN0YXJ0LnNldFVUQ0RhdGUoc3RhcnQuZ2V0VVRDRGF0ZSgpICsgZGlmZik7XG4gIHJldHVybiBzdGFydDtcbn1cblxuZnVuY3Rpb24gaXNvRGF0ZU9ubHkoZGF0ZTogRGF0ZSk6IHN0cmluZyB7XG4gIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgMTApO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTGFiZWwoZGF0ZTogRGF0ZSk6IHN0cmluZyB7XG4gIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHVuZGVmaW5lZCwge1xuICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgZGF5OiBcIm51bWVyaWNcIlxuICB9KTtcbiAgcmV0dXJuIGBXZWVrIG9mICR7Zm9ybWF0dGVyLmZvcm1hdChkYXRlKX1gO1xufVxuIl0sIm5hbWVzIjpbIkRFRkFVTFRfR1JBUEhRTF9FTkRQT0lOVCIsIkRFRkFVTFRfSVNTVUVfUEFHRV9TSVpFIiwiREVGQVVMVF9USU1FTE9HX1BBR0VfU0laRSIsIklTU1VFX1RJTUVMT0dTX1FVRVJZIiwiZmV0Y2hQcm9qZWN0VGltZVJlcG9ydCIsInByb2plY3RGdWxsUGF0aCIsImNyZWRlbnRpYWxzIiwicmFuZ2UiLCJpc3N1ZVBhZ2VTaXplIiwidGltZWxvZ1BhZ2VTaXplIiwiYXBpVXJsIiwidHJpbSIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwidG9rZW4iLCJFcnJvciIsImlzc3VlcyIsInBhZ2VJbmZvIiwicHJvamVjdE1ldGEiLCJwYXlsb2FkIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicXVlcnkiLCJ2YXJpYWJsZXMiLCJmdWxsUGF0aCIsImlzc3Vlc0ZpcnN0IiwiaXNzdWVzQWZ0ZXIiLCJlbmRDdXJzb3IiLCJ0aW1lbG9nRmlyc3QiLCJvayIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwianNvbiIsImVycm9ycyIsImxlbmd0aCIsIm1hcCIsImVyciIsImpvaW4iLCJkYXRhIiwicHJvamVjdCIsImlkIiwibmFtZSIsIndlYlVybCIsImN1cnJlbnRJc3N1ZXMiLCJub2RlcyIsIm5vZGUiLCJ0cmFuc2Zvcm1Jc3N1ZU5vZGUiLCJwdXNoIiwiaGFzTmV4dFBhZ2UiLCJzdW1tYXJ5IiwiYnVpbGRUaW1lU3VtbWFyeSIsImdlbmVyYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidGltZWxvZ3MiLCJmaWx0ZXIiLCJsb2ciLCJ0aW1lU3BlbnQiLCJpc1dpdGhpblJhbmdlIiwic3BlbnRBdCIsInNlY29uZHMiLCJ1c2VyIiwidXNlcm5hbWUiLCJpaWQiLCJ0aXRsZSIsInN0YXRlIiwibGFiZWxzIiwibGFiZWwiLCJlcGljIiwiZnJvbSIsInRvIiwidGltZXN0YW1wIiwicGFyc2UiLCJOdW1iZXIiLCJpc05hTiIsImZyb21UcyIsInRvVHMiLCJ0b3RhbFNlY29uZHMiLCJieVVzZXIiLCJNYXAiLCJieUlzc3VlIiwiYnlFcGljIiwiYnlEYXRlIiwiYnlMYWJlbCIsImJ5U3RhdGUiLCJ3ZWVrbHlCdWNrZXRzIiwiaXNzdWUiLCJpc3N1ZVNlY29uZHMiLCJ0aW1lbG9nIiwiZGF0ZUtleSIsInNsaWNlIiwic2V0IiwiZ2V0IiwidXNlcktleSIsInVzZXJHcm91cCIsImhpbnRzIiwid2Vla0J1Y2tldCIsImdldFdlZWtCdWNrZXQiLCJhZ2dyZWdhdGUiLCJrZXkiLCJ3ZWVrU3RhcnQiLCJzdGFydCIsInRvdGFscyIsInVzZXJUb3RhbHMiLCJ1c2VySWQiLCJ1c2VyTmFtZSIsImlzc3VlR3JvdXAiLCJpc3N1ZVVybCIsImVwaWNLZXkiLCJlcGljTGFiZWwiLCJlcGljR3JvdXAiLCJlcGljVXJsIiwidW5kZWZpbmVkIiwic3RhdGVLZXkiLCJzdGF0ZUdyb3VwIiwibGFiZWxHcm91cCIsIkFycmF5IiwidmFsdWVzIiwic29ydCIsImEiLCJiIiwiZW50cmllcyIsImRhdGUiLCJsb2NhbGVDb21wYXJlIiwid2Vla2x5QnlVc2VyIiwiYnVja2V0Iiwic2Vjb25kc1RvSG91cnMiLCJNYXRoIiwicm91bmQiLCJmb3JtYXREdXJhdGlvbiIsImhvdXJzIiwiZmxvb3IiLCJtaW51dGVzIiwid2Vla1N0YXJ0RGF0ZSIsInN0YXJ0T2ZXZWVrIiwiaXNvRGF0ZU9ubHkiLCJmb3JtYXRXZWVrTGFiZWwiLCJVVEMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImRheSIsImdldFVUQ0RheSIsImRpZmYiLCJzZXRVVENEYXRlIiwiZm9ybWF0dGVyIiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwibW9udGgiLCJmb3JtYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/gitlab.ts\n"));

/***/ })

});