"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/gitlab.ts":
/*!***************************!*\
  !*** ./app/lib/gitlab.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchCommitActivityByDay: function() { return /* binding */ fetchCommitActivityByDay; },\n/* harmony export */   fetchProjectTimeReport: function() { return /* binding */ fetchProjectTimeReport; },\n/* harmony export */   formatDuration: function() { return /* binding */ formatDuration; },\n/* harmony export */   secondsToHours: function() { return /* binding */ secondsToHours; }\n/* harmony export */ });\nconst DEFAULT_GRAPHQL_ENDPOINT = \"https://gitlab.com/api/graphql\";\nconst DEFAULT_ISSUE_PAGE_SIZE = 20;\nconst DEFAULT_TIMELOG_PAGE_SIZE = 100;\nconst DEFAULT_REST_ENDPOINT = \"https://gitlab.com/api/v4\";\nconst ISSUE_TIMELOGS_QUERY = \"\\n  query ProjectIssueTimelogs(\\n    $fullPath: ID!,\\n    $issuesFirst: Int!,\\n    $issuesAfter: String,\\n    $timelogFirst: Int!\\n  ) {\\n    project(fullPath: $fullPath) {\\n      id\\n      name\\n      webUrl\\n      issues(first: $issuesFirst, after: $issuesAfter, sort: UPDATED_DESC) {\\n        nodes {\\n          id\\n          iid\\n          title\\n          webUrl\\n          state\\n          labels(first: 10) {\\n            nodes {\\n              title\\n            }\\n          }\\n          epic {\\n            id\\n            iid\\n            title\\n            webUrl\\n          }\\n          timelogs(first: $timelogFirst) {\\n            nodes {\\n              id\\n              spentAt\\n              timeSpent\\n              summary\\n              user {\\n                id\\n                name\\n                username\\n              }\\n            }\\n          }\\n        }\\n        pageInfo {\\n          hasNextPage\\n          endCursor\\n        }\\n      }\\n    }\\n  }\\n\";\nasync function fetchProjectTimeReport(projectFullPath, credentials, range) {\n    let issuePageSize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : DEFAULT_ISSUE_PAGE_SIZE, timelogPageSize = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : DEFAULT_TIMELOG_PAGE_SIZE;\n    var _credentials_apiUrl;\n    const apiUrl = ((_credentials_apiUrl = credentials.apiUrl) === null || _credentials_apiUrl === void 0 ? void 0 : _credentials_apiUrl.trim()) || DEFAULT_GRAPHQL_ENDPOINT;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(credentials.token)\n    };\n    if (!projectFullPath) {\n        throw new Error(\"Missing GitLab project full path.\");\n    }\n    if (!credentials.token) {\n        throw new Error(\"Missing GitLab access token.\");\n    }\n    const issues = [];\n    let pageInfo = null;\n    let projectMeta = null;\n    do {\n        var _payload_errors, _payload_data;\n        var _pageInfo_endCursor;\n        const response = await fetch(apiUrl, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({\n                query: ISSUE_TIMELOGS_QUERY,\n                variables: {\n                    fullPath: projectFullPath,\n                    issuesFirst: issuePageSize,\n                    issuesAfter: (_pageInfo_endCursor = pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.endCursor) !== null && _pageInfo_endCursor !== void 0 ? _pageInfo_endCursor : null,\n                    timelogFirst: timelogPageSize\n                }\n            })\n        });\n        if (!response.ok) {\n            const message = \"GitLab GraphQL responded with \".concat(response.status, \" \").concat(response.statusText);\n            throw new Error(message);\n        }\n        const payload = await response.json();\n        if ((_payload_errors = payload.errors) === null || _payload_errors === void 0 ? void 0 : _payload_errors.length) {\n            throw new Error(payload.errors.map((err)=>err.message).join(\"; \"));\n        }\n        if (!((_payload_data = payload.data) === null || _payload_data === void 0 ? void 0 : _payload_data.project)) {\n            throw new Error(\"Project not found or access denied.\");\n        }\n        projectMeta = {\n            id: payload.data.project.id,\n            name: payload.data.project.name,\n            webUrl: payload.data.project.webUrl\n        };\n        const currentIssues = payload.data.project.issues.nodes.map((node)=>transformIssueNode(node, range));\n        issues.push(...currentIssues);\n        pageInfo = payload.data.project.issues.pageInfo;\n    }while (pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.hasNextPage);\n    const summary = buildTimeSummary(issues);\n    return {\n        project: projectMeta !== null && projectMeta !== void 0 ? projectMeta : {\n            id: \"unknown\",\n            name: projectFullPath,\n            webUrl: \"\"\n        },\n        issues,\n        summary,\n        range,\n        generatedAt: new Date().toISOString(),\n        commitActivity: [],\n        commitRange: null,\n        warnings: []\n    };\n}\nfunction transformIssueNode(node, range) {\n    var _node_timelogs, _node_labels_nodes, _node_labels;\n    var _node_timelogs_nodes;\n    const timelogs = ((_node_timelogs_nodes = (_node_timelogs = node.timelogs) === null || _node_timelogs === void 0 ? void 0 : _node_timelogs.nodes) !== null && _node_timelogs_nodes !== void 0 ? _node_timelogs_nodes : []).filter((log)=>{\n        if (!log || log.timeSpent <= 0) {\n            return false;\n        }\n        return isWithinRange(log.spentAt, range);\n    }).map((log)=>{\n        var _log_user, _log_user1, _log_user2;\n        var _log_user_id, _log_user_name, _log_user_username;\n        return {\n            id: log.id,\n            spentAt: log.spentAt,\n            seconds: log.timeSpent,\n            summary: log.summary,\n            user: {\n                id: (_log_user_id = (_log_user = log.user) === null || _log_user === void 0 ? void 0 : _log_user.id) !== null && _log_user_id !== void 0 ? _log_user_id : \"unknown\",\n                name: (_log_user_name = (_log_user1 = log.user) === null || _log_user1 === void 0 ? void 0 : _log_user1.name) !== null && _log_user_name !== void 0 ? _log_user_name : \"Unknown\",\n                username: (_log_user_username = (_log_user2 = log.user) === null || _log_user2 === void 0 ? void 0 : _log_user2.username) !== null && _log_user_username !== void 0 ? _log_user_username : \"unknown\"\n            }\n        };\n    });\n    var _node_labels_nodes_map;\n    return {\n        id: node.id,\n        iid: node.iid,\n        title: node.title,\n        webUrl: node.webUrl,\n        state: node.state,\n        labels: (_node_labels_nodes_map = (_node_labels = node.labels) === null || _node_labels === void 0 ? void 0 : (_node_labels_nodes = _node_labels.nodes) === null || _node_labels_nodes === void 0 ? void 0 : _node_labels_nodes.map((label)=>label.title)) !== null && _node_labels_nodes_map !== void 0 ? _node_labels_nodes_map : [],\n        epic: node.epic ? {\n            id: node.epic.id,\n            iid: node.epic.iid,\n            title: node.epic.title,\n            webUrl: node.epic.webUrl\n        } : null,\n        timelogs\n    };\n}\nfunction isWithinRange(spentAt, range) {\n    if (!range.from && !range.to) {\n        return true;\n    }\n    const timestamp = Date.parse(spentAt);\n    if (Number.isNaN(timestamp)) {\n        return true;\n    }\n    if (range.from) {\n        const fromTs = Date.parse(range.from);\n        if (!Number.isNaN(fromTs) && timestamp < fromTs) {\n            return false;\n        }\n    }\n    if (range.to) {\n        const toTs = Date.parse(range.to);\n        if (!Number.isNaN(toTs) && timestamp >= toTs) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction buildTimeSummary(issues) {\n    let totalSeconds = 0;\n    const byUser = new Map();\n    const byIssue = new Map();\n    const byEpic = new Map();\n    const byDate = new Map();\n    const byLabel = new Map();\n    const byState = new Map();\n    const weeklyBuckets = new Map();\n    for (const issue of issues){\n        var _issue_epic, _issue_epic1;\n        let issueSeconds = 0;\n        for (const timelog of issue.timelogs){\n            totalSeconds += timelog.seconds;\n            issueSeconds += timelog.seconds;\n            const dateKey = timelog.spentAt ? timelog.spentAt.slice(0, 10) : \"unknown\";\n            var _byDate_get;\n            byDate.set(dateKey, ((_byDate_get = byDate.get(dateKey)) !== null && _byDate_get !== void 0 ? _byDate_get : 0) + timelog.seconds);\n            const userKey = timelog.user.username || timelog.user.id;\n            var _byUser_get;\n            const userGroup = (_byUser_get = byUser.get(userKey)) !== null && _byUser_get !== void 0 ? _byUser_get : {\n                label: timelog.user.name,\n                seconds: 0,\n                hints: {\n                    username: timelog.user.username\n                }\n            };\n            userGroup.seconds += timelog.seconds;\n            byUser.set(userKey, userGroup);\n            const weekBucket = getWeekBucket(timelog.spentAt);\n            if (weekBucket) {\n                var _weeklyBuckets_get;\n                const aggregate = (_weeklyBuckets_get = weeklyBuckets.get(weekBucket.key)) !== null && _weeklyBuckets_get !== void 0 ? _weeklyBuckets_get : {\n                    weekStart: weekBucket.start,\n                    label: weekBucket.label,\n                    totals: new Map(),\n                    totalSeconds: 0\n                };\n                var _aggregate_totals_get;\n                const userTotals = (_aggregate_totals_get = aggregate.totals.get(userKey)) !== null && _aggregate_totals_get !== void 0 ? _aggregate_totals_get : {\n                    userId: timelog.user.id,\n                    userName: timelog.user.name,\n                    username: timelog.user.username,\n                    seconds: 0\n                };\n                userTotals.seconds += timelog.seconds;\n                aggregate.totals.set(userKey, userTotals);\n                aggregate.totalSeconds += timelog.seconds;\n                weeklyBuckets.set(weekBucket.key, aggregate);\n            }\n        }\n        var _byIssue_get;\n        const issueGroup = (_byIssue_get = byIssue.get(issue.id)) !== null && _byIssue_get !== void 0 ? _byIssue_get : {\n            label: \"#\".concat(issue.iid, \" \").concat(issue.title),\n            seconds: 0,\n            hints: {\n                issueUrl: issue.webUrl,\n                state: issue.state\n            }\n        };\n        issueGroup.seconds += issueSeconds;\n        byIssue.set(issue.id, issueGroup);\n        var _issue_epic_id;\n        const epicKey = (_issue_epic_id = (_issue_epic = issue.epic) === null || _issue_epic === void 0 ? void 0 : _issue_epic.id) !== null && _issue_epic_id !== void 0 ? _issue_epic_id : \"unassigned\";\n        const epicLabel = issue.epic ? issue.epic.title : \"No epic\";\n        var _issue_epic_webUrl, _byEpic_get;\n        const epicGroup = (_byEpic_get = byEpic.get(epicKey)) !== null && _byEpic_get !== void 0 ? _byEpic_get : {\n            label: epicLabel,\n            seconds: 0,\n            hints: {\n                epicUrl: (_issue_epic_webUrl = (_issue_epic1 = issue.epic) === null || _issue_epic1 === void 0 ? void 0 : _issue_epic1.webUrl) !== null && _issue_epic_webUrl !== void 0 ? _issue_epic_webUrl : undefined\n            }\n        };\n        epicGroup.seconds += issueSeconds;\n        byEpic.set(epicKey, epicGroup);\n        const stateKey = issue.state || \"unknown\";\n        var _byState_get;\n        const stateGroup = (_byState_get = byState.get(stateKey)) !== null && _byState_get !== void 0 ? _byState_get : {\n            label: stateKey,\n            seconds: 0\n        };\n        stateGroup.seconds += issueSeconds;\n        byState.set(stateKey, stateGroup);\n        for (const label of issue.labels){\n            var _byLabel_get;\n            const labelGroup = (_byLabel_get = byLabel.get(label)) !== null && _byLabel_get !== void 0 ? _byLabel_get : {\n                label,\n                seconds: 0\n            };\n            labelGroup.seconds += issueSeconds;\n            byLabel.set(label, labelGroup);\n        }\n    }\n    return {\n        totalSeconds,\n        byUser: Array.from(byUser.values()).sort((a, b)=>b.seconds - a.seconds),\n        byIssue: Array.from(byIssue.values()).sort((a, b)=>b.seconds - a.seconds),\n        byEpic: Array.from(byEpic.values()).sort((a, b)=>b.seconds - a.seconds),\n        byLabel: Array.from(byLabel.values()).sort((a, b)=>b.seconds - a.seconds),\n        byState: Array.from(byState.values()).sort((a, b)=>b.seconds - a.seconds),\n        byDate: Array.from(byDate.entries()).map((param)=>{\n            let [date, seconds] = param;\n            return {\n                date,\n                seconds\n            };\n        }).sort((a, b)=>a.date.localeCompare(b.date)),\n        weeklyByUser: Array.from(weeklyBuckets.values()).map((bucket)=>({\n                weekStart: bucket.weekStart,\n                label: bucket.label,\n                totals: Array.from(bucket.totals.values()).sort((a, b)=>b.seconds - a.seconds),\n                totalSeconds: bucket.totalSeconds\n            })).sort((a, b)=>a.weekStart.localeCompare(b.weekStart))\n    };\n}\nfunction secondsToHours(seconds) {\n    return Math.round(seconds / 3600 * 100) / 100;\n}\nfunction formatDuration(seconds) {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor(seconds % 3600 / 60);\n    if (hours === 0 && minutes === 0) {\n        return \"<1m\";\n    }\n    if (hours === 0) {\n        return \"\".concat(minutes, \"m\");\n    }\n    if (minutes === 0) {\n        return \"\".concat(hours, \"h\");\n    }\n    return \"\".concat(hours, \"h \").concat(minutes, \"m\");\n}\nfunction getWeekBucket(spentAt) {\n    const timestamp = Date.parse(spentAt);\n    if (Number.isNaN(timestamp)) {\n        return null;\n    }\n    const weekStartDate = startOfWeek(new Date(timestamp));\n    const start = isoDateOnly(weekStartDate);\n    return {\n        key: start,\n        start,\n        label: formatWeekLabel(weekStartDate)\n    };\n}\nfunction startOfWeek(date) {\n    const start = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));\n    const day = start.getUTCDay();\n    const diff = day === 0 ? -6 : 1 - day;\n    start.setUTCDate(start.getUTCDate() + diff);\n    return start;\n}\nfunction isoDateOnly(date) {\n    return date.toISOString().slice(0, 10);\n}\nfunction formatWeekLabel(date) {\n    const formatter = new Intl.DateTimeFormat(undefined, {\n        month: \"short\",\n        day: \"numeric\"\n    });\n    return \"Week of \".concat(formatter.format(date));\n}\nfunction resolveRestEndpoint(graphqlUrl) {\n    if (!graphqlUrl) {\n        return DEFAULT_REST_ENDPOINT;\n    }\n    if (graphqlUrl.endsWith(\"/api/graphql\")) {\n        return graphqlUrl.replace(\"/api/graphql\", \"/api/v4\");\n    }\n    return DEFAULT_REST_ENDPOINT;\n}\nasync function fetchCommitActivityByDay(projectFullPath, credentials, month) {\n    if (!projectFullPath) {\n        throw new Error(\"Missing GitLab project full path.\");\n    }\n    if (!credentials.token) {\n        throw new Error(\"Missing GitLab access token.\");\n    }\n    if (!month || !/^\\d{4}-\\d{2}$/.test(month)) {\n        throw new Error(\"Field 'commitMonth' must use YYYY-MM format.\");\n    }\n    const [yearStr, monthStr] = month.split(\"-\");\n    const year = Number(yearStr);\n    const monthIndex = Number(monthStr) - 1;\n    if (!Number.isInteger(year) || !Number.isInteger(monthIndex) || monthIndex < 0 || monthIndex > 11) {\n        throw new Error(\"Field 'commitMonth' must reference a valid month.\");\n    }\n    const startDate = new Date(Date.UTC(year, monthIndex, 1));\n    const endDate = new Date(Date.UTC(year, monthIndex + 1, 1));\n    const since = startDate.toISOString();\n    const until = endDate.toISOString();\n    const restBase = resolveRestEndpoint(credentials.apiUrl);\n    const encodedProject = encodeURIComponent(projectFullPath);\n    const perPage = 100;\n    let page = 1;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(credentials.token)\n    };\n    const counts = new Map();\n    while(true){\n        const url = \"\".concat(restBase, \"/projects/\").concat(encodedProject, \"/repository/commits?since=\").concat(encodeURIComponent(since), \"&until=\").concat(encodeURIComponent(until), \"&per_page=\").concat(perPage, \"&page=\").concat(page, \"&with_stats=false\");\n        const response = await fetch(url, {\n            headers\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch commit activity (\".concat(response.status, \" \").concat(response.statusText, \").\"));\n        }\n        const payload = await response.json();\n        for (const commit of payload){\n            if (!(commit === null || commit === void 0 ? void 0 : commit.committed_date)) {\n                continue;\n            }\n            const dayKey = commit.committed_date.slice(0, 10);\n            var _counts_get;\n            counts.set(dayKey, ((_counts_get = counts.get(dayKey)) !== null && _counts_get !== void 0 ? _counts_get : 0) + 1);\n        }\n        const nextPage = response.headers.get(\"x-next-page\");\n        if (!nextPage) {\n            break;\n        }\n        const parsed = Number(nextPage);\n        if (!Number.isFinite(parsed) || parsed <= page) {\n            break;\n        }\n        page = parsed;\n    }\n    const days = [];\n    for(let cursor = new Date(startDate); cursor < endDate; cursor.setUTCDate(cursor.getUTCDate() + 1)){\n        const key = isoDateOnly(cursor);\n        var _counts_get1;\n        days.push({\n            date: key,\n            count: (_counts_get1 = counts.get(key)) !== null && _counts_get1 !== void 0 ? _counts_get1 : 0\n        });\n    }\n    return {\n        days,\n        range: {\n            month,\n            from: since,\n            to: until\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvbGliL2dpdGxhYi50cz85OWY4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IERFRkFVTFRfR1JBUEhRTF9FTkRQT0lOVCA9IFwiaHR0cHM6Ly9naXRsYWIuY29tL2FwaS9ncmFwaHFsXCI7XG5jb25zdCBERUZBVUxUX0lTU1VFX1BBR0VfU0laRSA9IDIwO1xuY29uc3QgREVGQVVMVF9USU1FTE9HX1BBR0VfU0laRSA9IDEwMDtcbmNvbnN0IERFRkFVTFRfUkVTVF9FTkRQT0lOVCA9IFwiaHR0cHM6Ly9naXRsYWIuY29tL2FwaS92NFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdpdExhYkNyZWRlbnRpYWxzIHtcbiAgYXBpVXJsPzogc3RyaW5nO1xuICB0b2tlbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVSYW5nZUZpbHRlciB7XG4gIGZyb20/OiBzdHJpbmc7XG4gIHRvPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlZWtseVVzZXJUb3RhbCB7XG4gIHVzZXJJZDogc3RyaW5nO1xuICB1c2VyTmFtZTogc3RyaW5nO1xuICB1c2VybmFtZTogc3RyaW5nO1xuICBzZWNvbmRzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2Vla2x5VXNlclN1bW1hcnkge1xuICB3ZWVrU3RhcnQ6IHN0cmluZztcbiAgbGFiZWw6IHN0cmluZztcbiAgdG90YWxzOiBXZWVrbHlVc2VyVG90YWxbXTtcbiAgdG90YWxTZWNvbmRzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tbWl0QWN0aXZpdHlEYXkge1xuICBkYXRlOiBzdHJpbmc7XG4gIGNvdW50OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tbWl0UmFuZ2Uge1xuICBtb250aDogc3RyaW5nO1xuICBmcm9tOiBzdHJpbmc7XG4gIHRvOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2l0TGFiSXNzdWVUaW1lbG9nIHtcbiAgaWQ6IHN0cmluZztcbiAgc3BlbnRBdDogc3RyaW5nO1xuICBzZWNvbmRzOiBudW1iZXI7XG4gIHVzZXI6IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB1c2VybmFtZTogc3RyaW5nO1xuICB9O1xuICBzdW1tYXJ5Pzogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHaXRMYWJJc3N1ZVRpbWUge1xuICBpZDogc3RyaW5nO1xuICBpaWQ6IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgd2ViVXJsOiBzdHJpbmc7XG4gIHN0YXRlOiBzdHJpbmc7XG4gIGxhYmVsczogc3RyaW5nW107XG4gIGVwaWM/OiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBpaWQ/OiBzdHJpbmcgfCBudWxsO1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgd2ViVXJsPzogc3RyaW5nIHwgbnVsbDtcbiAgfSB8IG51bGw7XG4gIHRpbWVsb2dzOiBHaXRMYWJJc3N1ZVRpbWVsb2dbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9qZWN0VGltZVJlcG9ydCB7XG4gIHByb2plY3Q6IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB3ZWJVcmw6IHN0cmluZztcbiAgfTtcbiAgaXNzdWVzOiBHaXRMYWJJc3N1ZVRpbWVbXTtcbiAgc3VtbWFyeTogVGltZVN1bW1hcnk7XG4gIHJhbmdlOiBUaW1lUmFuZ2VGaWx0ZXI7XG4gIGdlbmVyYXRlZEF0OiBzdHJpbmc7XG4gIGNvbW1pdEFjdGl2aXR5PzogQ29tbWl0QWN0aXZpdHlEYXlbXTtcbiAgY29tbWl0UmFuZ2U/OiBDb21taXRSYW5nZSB8IG51bGw7XG4gIHdhcm5pbmdzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGltZVN1bW1hcnlHcm91cCB7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIHNlY29uZHM6IG51bWJlcjtcbiAgaGludHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVTdW1tYXJ5IHtcbiAgdG90YWxTZWNvbmRzOiBudW1iZXI7XG4gIGJ5VXNlcjogVGltZVN1bW1hcnlHcm91cFtdO1xuICBieUlzc3VlOiBUaW1lU3VtbWFyeUdyb3VwW107XG4gIGJ5RXBpYzogVGltZVN1bW1hcnlHcm91cFtdO1xuICBieUxhYmVsOiBUaW1lU3VtbWFyeUdyb3VwW107XG4gIGJ5U3RhdGU6IFRpbWVTdW1tYXJ5R3JvdXBbXTtcbiAgYnlEYXRlOiB7IGRhdGU6IHN0cmluZzsgc2Vjb25kczogbnVtYmVyIH1bXTtcbiAgd2Vla2x5QnlVc2VyOiBXZWVrbHlVc2VyU3VtbWFyeVtdO1xufVxuXG5pbnRlcmZhY2UgR3JhcGhRTElzc3VlTm9kZSB7XG4gIGlkOiBzdHJpbmc7XG4gIGlpZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICB3ZWJVcmw6IHN0cmluZztcbiAgc3RhdGU6IHN0cmluZztcbiAgbGFiZWxzOiB7IG5vZGVzOiBBcnJheTx7IHRpdGxlOiBzdHJpbmcgfT4gfTtcbiAgZXBpYz86IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGlpZDogc3RyaW5nIHwgbnVsbDtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHdlYlVybDogc3RyaW5nIHwgbnVsbDtcbiAgfSB8IG51bGw7XG4gIHRpbWVsb2dzOiB7XG4gICAgbm9kZXM6IEFycmF5PHtcbiAgICAgIGlkOiBzdHJpbmc7XG4gICAgICBzcGVudEF0OiBzdHJpbmc7XG4gICAgICB0aW1lU3BlbnQ6IG51bWJlcjtcbiAgICAgIHN1bW1hcnk6IHN0cmluZyB8IG51bGw7XG4gICAgICB1c2VyPzoge1xuICAgICAgICBpZDogc3RyaW5nO1xuICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgICB9IHwgbnVsbDtcbiAgICB9PjtcbiAgfTtcbn1cblxuaW50ZXJmYWNlIEdyYXBoUUxSZXNwb25zZTxUPiB7XG4gIGRhdGE/OiBUO1xuICBlcnJvcnM/OiBBcnJheTx7IG1lc3NhZ2U6IHN0cmluZyB9Pjtcbn1cblxuaW50ZXJmYWNlIElzc3VlUGFnZVBheWxvYWQge1xuICBwcm9qZWN0OiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgd2ViVXJsOiBzdHJpbmc7XG4gICAgaXNzdWVzOiB7XG4gICAgICBub2RlczogR3JhcGhRTElzc3VlTm9kZVtdO1xuICAgICAgcGFnZUluZm86IHtcbiAgICAgICAgaGFzTmV4dFBhZ2U6IGJvb2xlYW47XG4gICAgICAgIGVuZEN1cnNvcjogc3RyaW5nIHwgbnVsbDtcbiAgICAgIH07XG4gICAgfTtcbiAgfSB8IG51bGw7XG59XG5cbmNvbnN0IElTU1VFX1RJTUVMT0dTX1FVRVJZID0gYFxuICBxdWVyeSBQcm9qZWN0SXNzdWVUaW1lbG9ncyhcbiAgICAkZnVsbFBhdGg6IElEISxcbiAgICAkaXNzdWVzRmlyc3Q6IEludCEsXG4gICAgJGlzc3Vlc0FmdGVyOiBTdHJpbmcsXG4gICAgJHRpbWVsb2dGaXJzdDogSW50IVxuICApIHtcbiAgICBwcm9qZWN0KGZ1bGxQYXRoOiAkZnVsbFBhdGgpIHtcbiAgICAgIGlkXG4gICAgICBuYW1lXG4gICAgICB3ZWJVcmxcbiAgICAgIGlzc3VlcyhmaXJzdDogJGlzc3Vlc0ZpcnN0LCBhZnRlcjogJGlzc3Vlc0FmdGVyLCBzb3J0OiBVUERBVEVEX0RFU0MpIHtcbiAgICAgICAgbm9kZXMge1xuICAgICAgICAgIGlkXG4gICAgICAgICAgaWlkXG4gICAgICAgICAgdGl0bGVcbiAgICAgICAgICB3ZWJVcmxcbiAgICAgICAgICBzdGF0ZVxuICAgICAgICAgIGxhYmVscyhmaXJzdDogMTApIHtcbiAgICAgICAgICAgIG5vZGVzIHtcbiAgICAgICAgICAgICAgdGl0bGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXBpYyB7XG4gICAgICAgICAgICBpZFxuICAgICAgICAgICAgaWlkXG4gICAgICAgICAgICB0aXRsZVxuICAgICAgICAgICAgd2ViVXJsXG4gICAgICAgICAgfVxuICAgICAgICAgIHRpbWVsb2dzKGZpcnN0OiAkdGltZWxvZ0ZpcnN0KSB7XG4gICAgICAgICAgICBub2RlcyB7XG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgIHNwZW50QXRcbiAgICAgICAgICAgICAgdGltZVNwZW50XG4gICAgICAgICAgICAgIHN1bW1hcnlcbiAgICAgICAgICAgICAgdXNlciB7XG4gICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgdXNlcm5hbWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYWdlSW5mbyB7XG4gICAgICAgICAgaGFzTmV4dFBhZ2VcbiAgICAgICAgICBlbmRDdXJzb3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuYDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoUHJvamVjdFRpbWVSZXBvcnQoXG4gIHByb2plY3RGdWxsUGF0aDogc3RyaW5nLFxuICBjcmVkZW50aWFsczogR2l0TGFiQ3JlZGVudGlhbHMsXG4gIHJhbmdlOiBUaW1lUmFuZ2VGaWx0ZXIsXG4gIGlzc3VlUGFnZVNpemU6IG51bWJlciA9IERFRkFVTFRfSVNTVUVfUEFHRV9TSVpFLFxuICB0aW1lbG9nUGFnZVNpemU6IG51bWJlciA9IERFRkFVTFRfVElNRUxPR19QQUdFX1NJWkVcbik6IFByb21pc2U8UHJvamVjdFRpbWVSZXBvcnQ+IHtcbiAgY29uc3QgYXBpVXJsID0gY3JlZGVudGlhbHMuYXBpVXJsPy50cmltKCkgfHwgREVGQVVMVF9HUkFQSFFMX0VORFBPSU5UO1xuICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjcmVkZW50aWFscy50b2tlbn1gXG4gIH07XG5cbiAgaWYgKCFwcm9qZWN0RnVsbFBhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIEdpdExhYiBwcm9qZWN0IGZ1bGwgcGF0aC5cIik7XG4gIH1cblxuICBpZiAoIWNyZWRlbnRpYWxzLnRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBHaXRMYWIgYWNjZXNzIHRva2VuLlwiKTtcbiAgfVxuXG4gIGNvbnN0IGlzc3VlczogR2l0TGFiSXNzdWVUaW1lW10gPSBbXTtcbiAgbGV0IHBhZ2VJbmZvOiB7IGhhc05leHRQYWdlOiBib29sZWFuOyBlbmRDdXJzb3I6IHN0cmluZyB8IG51bGwgfSB8IG51bGwgPSBudWxsO1xuICBsZXQgcHJvamVjdE1ldGE6IHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nOyB3ZWJVcmw6IHN0cmluZyB9IHwgbnVsbCA9IG51bGw7XG5cbiAgZG8ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXBpVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcXVlcnk6IElTU1VFX1RJTUVMT0dTX1FVRVJZLFxuICAgICAgICB2YXJpYWJsZXM6IHtcbiAgICAgICAgICBmdWxsUGF0aDogcHJvamVjdEZ1bGxQYXRoLFxuICAgICAgICAgIGlzc3Vlc0ZpcnN0OiBpc3N1ZVBhZ2VTaXplLFxuICAgICAgICAgIGlzc3Vlc0FmdGVyOiBwYWdlSW5mbz8uZW5kQ3Vyc29yID8/IG51bGwsXG4gICAgICAgICAgdGltZWxvZ0ZpcnN0OiB0aW1lbG9nUGFnZVNpemVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgR2l0TGFiIEdyYXBoUUwgcmVzcG9uZGVkIHdpdGggJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHBheWxvYWQgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKSBhcyBHcmFwaFFMUmVzcG9uc2U8SXNzdWVQYWdlUGF5bG9hZD47XG5cbiAgICBpZiAocGF5bG9hZC5lcnJvcnM/Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHBheWxvYWQuZXJyb3JzLm1hcCgoZXJyKSA9PiBlcnIubWVzc2FnZSkuam9pbihcIjsgXCIpKTtcbiAgICB9XG5cbiAgICBpZiAoIXBheWxvYWQuZGF0YT8ucHJvamVjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvamVjdCBub3QgZm91bmQgb3IgYWNjZXNzIGRlbmllZC5cIik7XG4gICAgfVxuXG4gICAgcHJvamVjdE1ldGEgPSB7XG4gICAgICBpZDogcGF5bG9hZC5kYXRhLnByb2plY3QuaWQsXG4gICAgICBuYW1lOiBwYXlsb2FkLmRhdGEucHJvamVjdC5uYW1lLFxuICAgICAgd2ViVXJsOiBwYXlsb2FkLmRhdGEucHJvamVjdC53ZWJVcmxcbiAgICB9O1xuXG4gICAgY29uc3QgY3VycmVudElzc3VlcyA9IHBheWxvYWQuZGF0YS5wcm9qZWN0Lmlzc3Vlcy5ub2Rlcy5tYXAoKG5vZGUpID0+XG4gICAgICB0cmFuc2Zvcm1Jc3N1ZU5vZGUobm9kZSwgcmFuZ2UpXG4gICAgKTtcbiAgICBpc3N1ZXMucHVzaCguLi5jdXJyZW50SXNzdWVzKTtcblxuICAgIHBhZ2VJbmZvID0gcGF5bG9hZC5kYXRhLnByb2plY3QuaXNzdWVzLnBhZ2VJbmZvO1xuICB9IHdoaWxlIChwYWdlSW5mbz8uaGFzTmV4dFBhZ2UpO1xuXG4gIGNvbnN0IHN1bW1hcnkgPSBidWlsZFRpbWVTdW1tYXJ5KGlzc3Vlcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm9qZWN0OiBwcm9qZWN0TWV0YSA/PyB7XG4gICAgICBpZDogXCJ1bmtub3duXCIsXG4gICAgICBuYW1lOiBwcm9qZWN0RnVsbFBhdGgsXG4gICAgICB3ZWJVcmw6IFwiXCJcbiAgICB9LFxuICAgIGlzc3VlcyxcbiAgICBzdW1tYXJ5LFxuICAgIHJhbmdlLFxuICAgIGdlbmVyYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgY29tbWl0QWN0aXZpdHk6IFtdLFxuICAgIGNvbW1pdFJhbmdlOiBudWxsLFxuICAgIHdhcm5pbmdzOiBbXVxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Jc3N1ZU5vZGUoXG4gIG5vZGU6IEdyYXBoUUxJc3N1ZU5vZGUsXG4gIHJhbmdlOiBUaW1lUmFuZ2VGaWx0ZXJcbik6IEdpdExhYklzc3VlVGltZSB7XG4gIGNvbnN0IHRpbWVsb2dzID0gKG5vZGUudGltZWxvZ3M/Lm5vZGVzID8/IFtdKVxuICAgIC5maWx0ZXIoKGxvZyk6IGxvZyBpcyBOb25OdWxsYWJsZTx0eXBlb2YgbG9nPiA9PiB7XG4gICAgICBpZiAoIWxvZyB8fCBsb2cudGltZVNwZW50IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzV2l0aGluUmFuZ2UobG9nLnNwZW50QXQsIHJhbmdlKTtcbiAgICB9KVxuICAgIC5tYXAoKGxvZykgPT4gKHtcbiAgICAgIGlkOiBsb2cuaWQsXG4gICAgICBzcGVudEF0OiBsb2cuc3BlbnRBdCxcbiAgICAgIHNlY29uZHM6IGxvZy50aW1lU3BlbnQsXG4gICAgICBzdW1tYXJ5OiBsb2cuc3VtbWFyeSxcbiAgICAgIHVzZXI6IHtcbiAgICAgICAgaWQ6IGxvZy51c2VyPy5pZCA/PyBcInVua25vd25cIixcbiAgICAgICAgbmFtZTogbG9nLnVzZXI/Lm5hbWUgPz8gXCJVbmtub3duXCIsXG4gICAgICAgIHVzZXJuYW1lOiBsb2cudXNlcj8udXNlcm5hbWUgPz8gXCJ1bmtub3duXCJcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpZDogbm9kZS5pZCxcbiAgICBpaWQ6IG5vZGUuaWlkLFxuICAgIHRpdGxlOiBub2RlLnRpdGxlLFxuICAgIHdlYlVybDogbm9kZS53ZWJVcmwsXG4gICAgc3RhdGU6IG5vZGUuc3RhdGUsXG4gICAgbGFiZWxzOiBub2RlLmxhYmVscz8ubm9kZXM/Lm1hcCgobGFiZWwpID0+IGxhYmVsLnRpdGxlKSA/PyBbXSxcbiAgICBlcGljOiBub2RlLmVwaWNcbiAgICAgID8ge1xuICAgICAgICAgIGlkOiBub2RlLmVwaWMuaWQsXG4gICAgICAgICAgaWlkOiBub2RlLmVwaWMuaWlkLFxuICAgICAgICAgIHRpdGxlOiBub2RlLmVwaWMudGl0bGUsXG4gICAgICAgICAgd2ViVXJsOiBub2RlLmVwaWMud2ViVXJsXG4gICAgICAgIH1cbiAgICAgIDogbnVsbCxcbiAgICB0aW1lbG9nc1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc1dpdGhpblJhbmdlKHNwZW50QXQ6IHN0cmluZywgcmFuZ2U6IFRpbWVSYW5nZUZpbHRlcik6IGJvb2xlYW4ge1xuICBpZiAoIXJhbmdlLmZyb20gJiYgIXJhbmdlLnRvKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLnBhcnNlKHNwZW50QXQpO1xuICBpZiAoTnVtYmVyLmlzTmFOKHRpbWVzdGFtcCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyYW5nZS5mcm9tKSB7XG4gICAgY29uc3QgZnJvbVRzID0gRGF0ZS5wYXJzZShyYW5nZS5mcm9tKTtcbiAgICBpZiAoIU51bWJlci5pc05hTihmcm9tVHMpICYmIHRpbWVzdGFtcCA8IGZyb21Ucykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyYW5nZS50bykge1xuICAgIGNvbnN0IHRvVHMgPSBEYXRlLnBhcnNlKHJhbmdlLnRvKTtcbiAgICBpZiAoIU51bWJlci5pc05hTih0b1RzKSAmJiB0aW1lc3RhbXAgPj0gdG9Ucykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBidWlsZFRpbWVTdW1tYXJ5KGlzc3VlczogR2l0TGFiSXNzdWVUaW1lW10pOiBUaW1lU3VtbWFyeSB7XG4gIGxldCB0b3RhbFNlY29uZHMgPSAwO1xuICBjb25zdCBieVVzZXIgPSBuZXcgTWFwPHN0cmluZywgVGltZVN1bW1hcnlHcm91cD4oKTtcbiAgY29uc3QgYnlJc3N1ZSA9IG5ldyBNYXA8c3RyaW5nLCBUaW1lU3VtbWFyeUdyb3VwPigpO1xuICBjb25zdCBieUVwaWMgPSBuZXcgTWFwPHN0cmluZywgVGltZVN1bW1hcnlHcm91cD4oKTtcbiAgY29uc3QgYnlEYXRlID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgY29uc3QgYnlMYWJlbCA9IG5ldyBNYXA8c3RyaW5nLCBUaW1lU3VtbWFyeUdyb3VwPigpO1xuICBjb25zdCBieVN0YXRlID0gbmV3IE1hcDxzdHJpbmcsIFRpbWVTdW1tYXJ5R3JvdXA+KCk7XG4gIGNvbnN0IHdlZWtseUJ1Y2tldHMgPSBuZXcgTWFwPFxuICAgIHN0cmluZyxcbiAgICB7XG4gICAgICB3ZWVrU3RhcnQ6IHN0cmluZztcbiAgICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgICB0b3RhbHM6IE1hcDxzdHJpbmcsIFdlZWtseVVzZXJUb3RhbD47XG4gICAgICB0b3RhbFNlY29uZHM6IG51bWJlcjtcbiAgICB9XG4gID4oKTtcblxuICBmb3IgKGNvbnN0IGlzc3VlIG9mIGlzc3Vlcykge1xuICAgIGxldCBpc3N1ZVNlY29uZHMgPSAwO1xuICAgIGZvciAoY29uc3QgdGltZWxvZyBvZiBpc3N1ZS50aW1lbG9ncykge1xuICAgICAgdG90YWxTZWNvbmRzICs9IHRpbWVsb2cuc2Vjb25kcztcbiAgICAgIGlzc3VlU2Vjb25kcyArPSB0aW1lbG9nLnNlY29uZHM7XG5cbiAgICAgIGNvbnN0IGRhdGVLZXkgPSB0aW1lbG9nLnNwZW50QXQgPyB0aW1lbG9nLnNwZW50QXQuc2xpY2UoMCwgMTApIDogXCJ1bmtub3duXCI7XG4gICAgICBieURhdGUuc2V0KGRhdGVLZXksIChieURhdGUuZ2V0KGRhdGVLZXkpID8/IDApICsgdGltZWxvZy5zZWNvbmRzKTtcblxuICAgICAgY29uc3QgdXNlcktleSA9IHRpbWVsb2cudXNlci51c2VybmFtZSB8fCB0aW1lbG9nLnVzZXIuaWQ7XG4gICAgICBjb25zdCB1c2VyR3JvdXAgPSBieVVzZXIuZ2V0KHVzZXJLZXkpID8/IHtcbiAgICAgICAgbGFiZWw6IHRpbWVsb2cudXNlci5uYW1lLFxuICAgICAgICBzZWNvbmRzOiAwLFxuICAgICAgICBoaW50czoge1xuICAgICAgICAgIHVzZXJuYW1lOiB0aW1lbG9nLnVzZXIudXNlcm5hbWVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVzZXJHcm91cC5zZWNvbmRzICs9IHRpbWVsb2cuc2Vjb25kcztcbiAgICAgIGJ5VXNlci5zZXQodXNlcktleSwgdXNlckdyb3VwKTtcblxuICAgICAgY29uc3Qgd2Vla0J1Y2tldCA9IGdldFdlZWtCdWNrZXQodGltZWxvZy5zcGVudEF0KTtcbiAgICAgIGlmICh3ZWVrQnVja2V0KSB7XG4gICAgICAgIGNvbnN0IGFnZ3JlZ2F0ZSA9XG4gICAgICAgICAgd2Vla2x5QnVja2V0cy5nZXQod2Vla0J1Y2tldC5rZXkpID8/XG4gICAgICAgICAge1xuICAgICAgICAgICAgd2Vla1N0YXJ0OiB3ZWVrQnVja2V0LnN0YXJ0LFxuICAgICAgICAgICAgbGFiZWw6IHdlZWtCdWNrZXQubGFiZWwsXG4gICAgICAgICAgICB0b3RhbHM6IG5ldyBNYXA8c3RyaW5nLCBXZWVrbHlVc2VyVG90YWw+KCksXG4gICAgICAgICAgICB0b3RhbFNlY29uZHM6IDBcbiAgICAgICAgICB9O1xuICAgICAgICBjb25zdCB1c2VyVG90YWxzID1cbiAgICAgICAgICBhZ2dyZWdhdGUudG90YWxzLmdldCh1c2VyS2V5KSA/P1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHVzZXJJZDogdGltZWxvZy51c2VyLmlkLFxuICAgICAgICAgICAgdXNlck5hbWU6IHRpbWVsb2cudXNlci5uYW1lLFxuICAgICAgICAgICAgdXNlcm5hbWU6IHRpbWVsb2cudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgIHNlY29uZHM6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB1c2VyVG90YWxzLnNlY29uZHMgKz0gdGltZWxvZy5zZWNvbmRzO1xuICAgICAgICBhZ2dyZWdhdGUudG90YWxzLnNldCh1c2VyS2V5LCB1c2VyVG90YWxzKTtcbiAgICAgICAgYWdncmVnYXRlLnRvdGFsU2Vjb25kcyArPSB0aW1lbG9nLnNlY29uZHM7XG4gICAgICAgIHdlZWtseUJ1Y2tldHMuc2V0KHdlZWtCdWNrZXQua2V5LCBhZ2dyZWdhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlzc3VlR3JvdXAgPSBieUlzc3VlLmdldChpc3N1ZS5pZCkgPz8ge1xuICAgICAgbGFiZWw6IGAjJHtpc3N1ZS5paWR9ICR7aXNzdWUudGl0bGV9YCxcbiAgICAgIHNlY29uZHM6IDAsXG4gICAgICBoaW50czoge1xuICAgICAgICBpc3N1ZVVybDogaXNzdWUud2ViVXJsLFxuICAgICAgICBzdGF0ZTogaXNzdWUuc3RhdGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGlzc3VlR3JvdXAuc2Vjb25kcyArPSBpc3N1ZVNlY29uZHM7XG4gICAgYnlJc3N1ZS5zZXQoaXNzdWUuaWQsIGlzc3VlR3JvdXApO1xuXG4gICAgY29uc3QgZXBpY0tleSA9IGlzc3VlLmVwaWM/LmlkID8/IFwidW5hc3NpZ25lZFwiO1xuICAgIGNvbnN0IGVwaWNMYWJlbCA9IGlzc3VlLmVwaWMgPyBpc3N1ZS5lcGljLnRpdGxlIDogXCJObyBlcGljXCI7XG4gICAgY29uc3QgZXBpY0dyb3VwID0gYnlFcGljLmdldChlcGljS2V5KSA/PyB7XG4gICAgICBsYWJlbDogZXBpY0xhYmVsLFxuICAgICAgc2Vjb25kczogMCxcbiAgICAgIGhpbnRzOiB7XG4gICAgICAgIGVwaWNVcmw6IGlzc3VlLmVwaWM/LndlYlVybCA/PyB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9O1xuICAgIGVwaWNHcm91cC5zZWNvbmRzICs9IGlzc3VlU2Vjb25kcztcbiAgICBieUVwaWMuc2V0KGVwaWNLZXksIGVwaWNHcm91cCk7XG5cbiAgICBjb25zdCBzdGF0ZUtleSA9IGlzc3VlLnN0YXRlIHx8IFwidW5rbm93blwiO1xuICAgIGNvbnN0IHN0YXRlR3JvdXAgPSBieVN0YXRlLmdldChzdGF0ZUtleSkgPz8ge1xuICAgICAgbGFiZWw6IHN0YXRlS2V5LFxuICAgICAgc2Vjb25kczogMFxuICAgIH07XG4gICAgc3RhdGVHcm91cC5zZWNvbmRzICs9IGlzc3VlU2Vjb25kcztcbiAgICBieVN0YXRlLnNldChzdGF0ZUtleSwgc3RhdGVHcm91cCk7XG5cbiAgICBmb3IgKGNvbnN0IGxhYmVsIG9mIGlzc3VlLmxhYmVscykge1xuICAgICAgY29uc3QgbGFiZWxHcm91cCA9IGJ5TGFiZWwuZ2V0KGxhYmVsKSA/PyB7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBzZWNvbmRzOiAwXG4gICAgICB9O1xuICAgICAgbGFiZWxHcm91cC5zZWNvbmRzICs9IGlzc3VlU2Vjb25kcztcbiAgICAgIGJ5TGFiZWwuc2V0KGxhYmVsLCBsYWJlbEdyb3VwKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvdGFsU2Vjb25kcyxcbiAgICBieVVzZXI6IEFycmF5LmZyb20oYnlVc2VyLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiBiLnNlY29uZHMgLSBhLnNlY29uZHMpLFxuICAgIGJ5SXNzdWU6IEFycmF5LmZyb20oYnlJc3N1ZS52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4gYi5zZWNvbmRzIC0gYS5zZWNvbmRzKSxcbiAgICBieUVwaWM6IEFycmF5LmZyb20oYnlFcGljLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiBiLnNlY29uZHMgLSBhLnNlY29uZHMpLFxuICAgIGJ5TGFiZWw6IEFycmF5LmZyb20oYnlMYWJlbC52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4gYi5zZWNvbmRzIC0gYS5zZWNvbmRzKSxcbiAgICBieVN0YXRlOiBBcnJheS5mcm9tKGJ5U3RhdGUudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGIuc2Vjb25kcyAtIGEuc2Vjb25kcyksXG4gICAgYnlEYXRlOiBBcnJheS5mcm9tKGJ5RGF0ZS5lbnRyaWVzKCkpXG4gICAgICAubWFwKChbZGF0ZSwgc2Vjb25kc10pID0+ICh7IGRhdGUsIHNlY29uZHMgfSkpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5kYXRlLmxvY2FsZUNvbXBhcmUoYi5kYXRlKSksXG4gICAgd2Vla2x5QnlVc2VyOiBBcnJheS5mcm9tKHdlZWtseUJ1Y2tldHMudmFsdWVzKCkpXG4gICAgICAubWFwKChidWNrZXQpID0+ICh7XG4gICAgICAgIHdlZWtTdGFydDogYnVja2V0LndlZWtTdGFydCxcbiAgICAgICAgbGFiZWw6IGJ1Y2tldC5sYWJlbCxcbiAgICAgICAgdG90YWxzOiBBcnJheS5mcm9tKGJ1Y2tldC50b3RhbHMudmFsdWVzKCkpLnNvcnQoXG4gICAgICAgICAgKGEsIGIpID0+IGIuc2Vjb25kcyAtIGEuc2Vjb25kc1xuICAgICAgICApLFxuICAgICAgICB0b3RhbFNlY29uZHM6IGJ1Y2tldC50b3RhbFNlY29uZHNcbiAgICAgIH0pKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGEud2Vla1N0YXJ0LmxvY2FsZUNvbXBhcmUoYi53ZWVrU3RhcnQpKVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2Vjb25kc1RvSG91cnMoc2Vjb25kczogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHNlY29uZHMgLyAzNjAwKSAqIDEwMCkgLyAxMDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREdXJhdGlvbihzZWNvbmRzOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBob3VycyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDM2MDApO1xuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcigoc2Vjb25kcyAlIDM2MDApIC8gNjApO1xuICBpZiAoaG91cnMgPT09IDAgJiYgbWludXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBcIjwxbVwiO1xuICB9XG4gIGlmIChob3VycyA9PT0gMCkge1xuICAgIHJldHVybiBgJHttaW51dGVzfW1gO1xuICB9XG4gIGlmIChtaW51dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIGAke2hvdXJzfWhgO1xuICB9XG4gIHJldHVybiBgJHtob3Vyc31oICR7bWludXRlc31tYDtcbn1cblxuZnVuY3Rpb24gZ2V0V2Vla0J1Y2tldChzcGVudEF0OiBzdHJpbmcpOiB7IGtleTogc3RyaW5nOyBzdGFydDogc3RyaW5nOyBsYWJlbDogc3RyaW5nIH0gfCBudWxsIHtcbiAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5wYXJzZShzcGVudEF0KTtcbiAgaWYgKE51bWJlci5pc05hTih0aW1lc3RhbXApKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgd2Vla1N0YXJ0RGF0ZSA9IHN0YXJ0T2ZXZWVrKG5ldyBEYXRlKHRpbWVzdGFtcCkpO1xuICBjb25zdCBzdGFydCA9IGlzb0RhdGVPbmx5KHdlZWtTdGFydERhdGUpO1xuICByZXR1cm4ge1xuICAgIGtleTogc3RhcnQsXG4gICAgc3RhcnQsXG4gICAgbGFiZWw6IGZvcm1hdFdlZWtMYWJlbCh3ZWVrU3RhcnREYXRlKVxuICB9O1xufVxuXG5mdW5jdGlvbiBzdGFydE9mV2VlayhkYXRlOiBEYXRlKTogRGF0ZSB7XG4gIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoRGF0ZS5VVEMoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCBkYXRlLmdldFVUQ01vbnRoKCksIGRhdGUuZ2V0VVRDRGF0ZSgpKSk7XG4gIGNvbnN0IGRheSA9IHN0YXJ0LmdldFVUQ0RheSgpO1xuICBjb25zdCBkaWZmID0gZGF5ID09PSAwID8gLTYgOiAxIC0gZGF5O1xuICBzdGFydC5zZXRVVENEYXRlKHN0YXJ0LmdldFVUQ0RhdGUoKSArIGRpZmYpO1xuICByZXR1cm4gc3RhcnQ7XG59XG5cbmZ1bmN0aW9uIGlzb0RhdGVPbmx5KGRhdGU6IERhdGUpOiBzdHJpbmcge1xuICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDEwKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vla0xhYmVsKGRhdGU6IERhdGUpOiBzdHJpbmcge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh1bmRlZmluZWQsIHtcbiAgICBtb250aDogXCJzaG9ydFwiLFxuICAgIGRheTogXCJudW1lcmljXCJcbiAgfSk7XG4gIHJldHVybiBgV2VlayBvZiAke2Zvcm1hdHRlci5mb3JtYXQoZGF0ZSl9YDtcbn1cblxuaW50ZXJmYWNlIFJlc3RDb21taXQge1xuICBjb21taXR0ZWRfZGF0ZTogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlUmVzdEVuZHBvaW50KGdyYXBocWxVcmw/OiBzdHJpbmcpIHtcbiAgaWYgKCFncmFwaHFsVXJsKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfUkVTVF9FTkRQT0lOVDtcbiAgfVxuICBpZiAoZ3JhcGhxbFVybC5lbmRzV2l0aChcIi9hcGkvZ3JhcGhxbFwiKSkge1xuICAgIHJldHVybiBncmFwaHFsVXJsLnJlcGxhY2UoXCIvYXBpL2dyYXBocWxcIiwgXCIvYXBpL3Y0XCIpO1xuICB9XG4gIHJldHVybiBERUZBVUxUX1JFU1RfRU5EUE9JTlQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaENvbW1pdEFjdGl2aXR5QnlEYXkoXG4gIHByb2plY3RGdWxsUGF0aDogc3RyaW5nLFxuICBjcmVkZW50aWFsczogR2l0TGFiQ3JlZGVudGlhbHMsXG4gIG1vbnRoOiBzdHJpbmdcbik6IFByb21pc2U8eyBkYXlzOiBDb21taXRBY3Rpdml0eURheVtdOyByYW5nZTogQ29tbWl0UmFuZ2UgfT4ge1xuICBpZiAoIXByb2plY3RGdWxsUGF0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgR2l0TGFiIHByb2plY3QgZnVsbCBwYXRoLlwiKTtcbiAgfVxuICBpZiAoIWNyZWRlbnRpYWxzLnRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBHaXRMYWIgYWNjZXNzIHRva2VuLlwiKTtcbiAgfVxuICBpZiAoIW1vbnRoIHx8ICEvXlxcZHs0fS1cXGR7Mn0kLy50ZXN0KG1vbnRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkICdjb21taXRNb250aCcgbXVzdCB1c2UgWVlZWS1NTSBmb3JtYXQuXCIpO1xuICB9XG5cbiAgY29uc3QgW3llYXJTdHIsIG1vbnRoU3RyXSA9IG1vbnRoLnNwbGl0KFwiLVwiKTtcbiAgY29uc3QgeWVhciA9IE51bWJlcih5ZWFyU3RyKTtcbiAgY29uc3QgbW9udGhJbmRleCA9IE51bWJlcihtb250aFN0cikgLSAxO1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIoeWVhcikgfHwgIU51bWJlci5pc0ludGVnZXIobW9udGhJbmRleCkgfHwgbW9udGhJbmRleCA8IDAgfHwgbW9udGhJbmRleCA+IDExKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgJ2NvbW1pdE1vbnRoJyBtdXN0IHJlZmVyZW5jZSBhIHZhbGlkIG1vbnRoLlwiKTtcbiAgfVxuICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aEluZGV4LCAxKSk7XG4gIGNvbnN0IGVuZERhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aEluZGV4ICsgMSwgMSkpO1xuXG4gIGNvbnN0IHNpbmNlID0gc3RhcnREYXRlLnRvSVNPU3RyaW5nKCk7XG4gIGNvbnN0IHVudGlsID0gZW5kRGF0ZS50b0lTT1N0cmluZygpO1xuXG4gIGNvbnN0IHJlc3RCYXNlID0gcmVzb2x2ZVJlc3RFbmRwb2ludChjcmVkZW50aWFscy5hcGlVcmwpO1xuICBjb25zdCBlbmNvZGVkUHJvamVjdCA9IGVuY29kZVVSSUNvbXBvbmVudChwcm9qZWN0RnVsbFBhdGgpO1xuICBjb25zdCBwZXJQYWdlID0gMTAwO1xuICBsZXQgcGFnZSA9IDE7XG4gIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NyZWRlbnRpYWxzLnRva2VufWBcbiAgfTtcblxuICBjb25zdCBjb3VudHMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgdXJsID0gYCR7cmVzdEJhc2V9L3Byb2plY3RzLyR7ZW5jb2RlZFByb2plY3R9L3JlcG9zaXRvcnkvY29tbWl0cz9zaW5jZT0ke2VuY29kZVVSSUNvbXBvbmVudChcbiAgICAgIHNpbmNlXG4gICAgKX0mdW50aWw9JHtlbmNvZGVVUklDb21wb25lbnQodW50aWwpfSZwZXJfcGFnZT0ke3BlclBhZ2V9JnBhZ2U9JHtwYWdlfSZ3aXRoX3N0YXRzPWZhbHNlYDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgaGVhZGVyc1xuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGZldGNoIGNvbW1pdCBhY3Rpdml0eSAoJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0pLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpIGFzIFJlc3RDb21taXRbXTtcbiAgICBmb3IgKGNvbnN0IGNvbW1pdCBvZiBwYXlsb2FkKSB7XG4gICAgICBpZiAoIWNvbW1pdD8uY29tbWl0dGVkX2RhdGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXlLZXkgPSBjb21taXQuY29tbWl0dGVkX2RhdGUuc2xpY2UoMCwgMTApO1xuICAgICAgY291bnRzLnNldChkYXlLZXksIChjb3VudHMuZ2V0KGRheUtleSkgPz8gMCkgKyAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0UGFnZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1uZXh0LXBhZ2VcIik7XG4gICAgaWYgKCFuZXh0UGFnZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZCA9IE51bWJlcihuZXh0UGFnZSk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocGFyc2VkKSB8fCBwYXJzZWQgPD0gcGFnZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhZ2UgPSBwYXJzZWQ7XG4gIH1cblxuICBjb25zdCBkYXlzOiBDb21taXRBY3Rpdml0eURheVtdID0gW107XG4gIGZvciAoXG4gICAgbGV0IGN1cnNvciA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSk7XG4gICAgY3Vyc29yIDwgZW5kRGF0ZTtcbiAgICBjdXJzb3Iuc2V0VVRDRGF0ZShjdXJzb3IuZ2V0VVRDRGF0ZSgpICsgMSlcbiAgKSB7XG4gICAgY29uc3Qga2V5ID0gaXNvRGF0ZU9ubHkoY3Vyc29yKTtcbiAgICBkYXlzLnB1c2goe1xuICAgICAgZGF0ZToga2V5LFxuICAgICAgY291bnQ6IGNvdW50cy5nZXQoa2V5KSA/PyAwXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRheXMsXG4gICAgcmFuZ2U6IHtcbiAgICAgIG1vbnRoLFxuICAgICAgZnJvbTogc2luY2UsXG4gICAgICB0bzogdW50aWxcbiAgICB9XG4gIH07XG59XG4iXSwibmFtZXMiOlsiREVGQVVMVF9HUkFQSFFMX0VORFBPSU5UIiwiREVGQVVMVF9JU1NVRV9QQUdFX1NJWkUiLCJERUZBVUxUX1RJTUVMT0dfUEFHRV9TSVpFIiwiREVGQVVMVF9SRVNUX0VORFBPSU5UIiwiSVNTVUVfVElNRUxPR1NfUVVFUlkiLCJmZXRjaFByb2plY3RUaW1lUmVwb3J0IiwicHJvamVjdEZ1bGxQYXRoIiwiY3JlZGVudGlhbHMiLCJyYW5nZSIsImlzc3VlUGFnZVNpemUiLCJ0aW1lbG9nUGFnZVNpemUiLCJhcGlVcmwiLCJ0cmltIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJ0b2tlbiIsIkVycm9yIiwiaXNzdWVzIiwicGFnZUluZm8iLCJwcm9qZWN0TWV0YSIsInBheWxvYWQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJxdWVyeSIsInZhcmlhYmxlcyIsImZ1bGxQYXRoIiwiaXNzdWVzRmlyc3QiLCJpc3N1ZXNBZnRlciIsImVuZEN1cnNvciIsInRpbWVsb2dGaXJzdCIsIm9rIiwibWVzc2FnZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJqc29uIiwiZXJyb3JzIiwibGVuZ3RoIiwibWFwIiwiZXJyIiwiam9pbiIsImRhdGEiLCJwcm9qZWN0IiwiaWQiLCJuYW1lIiwid2ViVXJsIiwiY3VycmVudElzc3VlcyIsIm5vZGVzIiwibm9kZSIsInRyYW5zZm9ybUlzc3VlTm9kZSIsInB1c2giLCJoYXNOZXh0UGFnZSIsInN1bW1hcnkiLCJidWlsZFRpbWVTdW1tYXJ5IiwiZ2VuZXJhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjb21taXRBY3Rpdml0eSIsImNvbW1pdFJhbmdlIiwid2FybmluZ3MiLCJ0aW1lbG9ncyIsImZpbHRlciIsImxvZyIsInRpbWVTcGVudCIsImlzV2l0aGluUmFuZ2UiLCJzcGVudEF0Iiwic2Vjb25kcyIsInVzZXIiLCJ1c2VybmFtZSIsImlpZCIsInRpdGxlIiwic3RhdGUiLCJsYWJlbHMiLCJsYWJlbCIsImVwaWMiLCJmcm9tIiwidG8iLCJ0aW1lc3RhbXAiLCJwYXJzZSIsIk51bWJlciIsImlzTmFOIiwiZnJvbVRzIiwidG9UcyIsInRvdGFsU2Vjb25kcyIsImJ5VXNlciIsIk1hcCIsImJ5SXNzdWUiLCJieUVwaWMiLCJieURhdGUiLCJieUxhYmVsIiwiYnlTdGF0ZSIsIndlZWtseUJ1Y2tldHMiLCJpc3N1ZSIsImlzc3VlU2Vjb25kcyIsInRpbWVsb2ciLCJkYXRlS2V5Iiwic2xpY2UiLCJzZXQiLCJnZXQiLCJ1c2VyS2V5IiwidXNlckdyb3VwIiwiaGludHMiLCJ3ZWVrQnVja2V0IiwiZ2V0V2Vla0J1Y2tldCIsImFnZ3JlZ2F0ZSIsImtleSIsIndlZWtTdGFydCIsInN0YXJ0IiwidG90YWxzIiwidXNlclRvdGFscyIsInVzZXJJZCIsInVzZXJOYW1lIiwiaXNzdWVHcm91cCIsImlzc3VlVXJsIiwiZXBpY0tleSIsImVwaWNMYWJlbCIsImVwaWNHcm91cCIsImVwaWNVcmwiLCJ1bmRlZmluZWQiLCJzdGF0ZUtleSIsInN0YXRlR3JvdXAiLCJsYWJlbEdyb3VwIiwiQXJyYXkiLCJ2YWx1ZXMiLCJzb3J0IiwiYSIsImIiLCJlbnRyaWVzIiwiZGF0ZSIsImxvY2FsZUNvbXBhcmUiLCJ3ZWVrbHlCeVVzZXIiLCJidWNrZXQiLCJzZWNvbmRzVG9Ib3VycyIsIk1hdGgiLCJyb3VuZCIsImZvcm1hdER1cmF0aW9uIiwiaG91cnMiLCJmbG9vciIsIm1pbnV0ZXMiLCJ3ZWVrU3RhcnREYXRlIiwic3RhcnRPZldlZWsiLCJpc29EYXRlT25seSIsImZvcm1hdFdlZWtMYWJlbCIsIlVUQyIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZGF5IiwiZ2V0VVRDRGF5IiwiZGlmZiIsInNldFVUQ0RhdGUiLCJmb3JtYXR0ZXIiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJtb250aCIsImZvcm1hdCIsInJlc29sdmVSZXN0RW5kcG9pbnQiLCJncmFwaHFsVXJsIiwiZW5kc1dpdGgiLCJyZXBsYWNlIiwiZmV0Y2hDb21taXRBY3Rpdml0eUJ5RGF5IiwidGVzdCIsInllYXJTdHIiLCJtb250aFN0ciIsInNwbGl0IiwieWVhciIsIm1vbnRoSW5kZXgiLCJpc0ludGVnZXIiLCJzdGFydERhdGUiLCJlbmREYXRlIiwic2luY2UiLCJ1bnRpbCIsInJlc3RCYXNlIiwiZW5jb2RlZFByb2plY3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJwZXJQYWdlIiwicGFnZSIsImNvdW50cyIsInVybCIsImNvbW1pdCIsImNvbW1pdHRlZF9kYXRlIiwiZGF5S2V5IiwibmV4dFBhZ2UiLCJwYXJzZWQiLCJpc0Zpbml0ZSIsImRheXMiLCJjdXJzb3IiLCJjb3VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/gitlab.ts\n"));

/***/ })

});