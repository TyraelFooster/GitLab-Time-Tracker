"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/gitlab.ts":
/*!***************************!*\
  !*** ./app/lib/gitlab.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchProjectTimeReport: function() { return /* binding */ fetchProjectTimeReport; },\n/* harmony export */   formatDuration: function() { return /* binding */ formatDuration; },\n/* harmony export */   secondsToHours: function() { return /* binding */ secondsToHours; }\n/* harmony export */ });\nconst DEFAULT_GRAPHQL_ENDPOINT = \"https://gitlab.com/api/graphql\";\nconst DEFAULT_ISSUE_PAGE_SIZE = 20;\nconst DEFAULT_TIMELOG_PAGE_SIZE = 100;\nconst ISSUE_TIMELOGS_QUERY = \"\\n  query ProjectIssueTimelogs(\\n    $fullPath: ID!,\\n    $issuesFirst: Int!,\\n    $issuesAfter: String,\\n    $timelogFirst: Int!\\n  ) {\\n    project(fullPath: $fullPath) {\\n      id\\n      name\\n      webUrl\\n      issues(first: $issuesFirst, after: $issuesAfter, sort: UPDATED_DESC) {\\n        nodes {\\n          id\\n          iid\\n          title\\n          webUrl\\n          state\\n          labels(first: 10) {\\n            nodes {\\n              title\\n            }\\n          }\\n          epic {\\n            id\\n            iid\\n            title\\n            webUrl\\n          }\\n          timelogs(first: $timelogFirst) {\\n            nodes {\\n              id\\n              spentAt\\n              timeSpent\\n              summary\\n              user {\\n                id\\n                name\\n                username\\n              }\\n            }\\n          }\\n        }\\n        pageInfo {\\n          hasNextPage\\n          endCursor\\n        }\\n      }\\n    }\\n  }\\n\";\nasync function fetchProjectTimeReport(projectFullPath, credentials, range) {\n    let issuePageSize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : DEFAULT_ISSUE_PAGE_SIZE, timelogPageSize = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : DEFAULT_TIMELOG_PAGE_SIZE;\n    var _credentials_apiUrl;\n    const apiUrl = ((_credentials_apiUrl = credentials.apiUrl) === null || _credentials_apiUrl === void 0 ? void 0 : _credentials_apiUrl.trim()) || DEFAULT_GRAPHQL_ENDPOINT;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(credentials.token)\n    };\n    if (!projectFullPath) {\n        throw new Error(\"Missing GitLab project full path.\");\n    }\n    if (!credentials.token) {\n        throw new Error(\"Missing GitLab access token.\");\n    }\n    const issues = [];\n    let pageInfo = null;\n    let projectMeta = null;\n    do {\n        var _payload_errors, _payload_data;\n        var _pageInfo_endCursor;\n        const response = await fetch(apiUrl, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({\n                query: ISSUE_TIMELOGS_QUERY,\n                variables: {\n                    fullPath: projectFullPath,\n                    issuesFirst: issuePageSize,\n                    issuesAfter: (_pageInfo_endCursor = pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.endCursor) !== null && _pageInfo_endCursor !== void 0 ? _pageInfo_endCursor : null,\n                    timelogFirst: timelogPageSize\n                }\n            })\n        });\n        if (!response.ok) {\n            const message = \"GitLab GraphQL responded with \".concat(response.status, \" \").concat(response.statusText);\n            throw new Error(message);\n        }\n        const payload = await response.json();\n        if ((_payload_errors = payload.errors) === null || _payload_errors === void 0 ? void 0 : _payload_errors.length) {\n            throw new Error(payload.errors.map((err)=>err.message).join(\"; \"));\n        }\n        if (!((_payload_data = payload.data) === null || _payload_data === void 0 ? void 0 : _payload_data.project)) {\n            throw new Error(\"Project not found or access denied.\");\n        }\n        projectMeta = {\n            id: payload.data.project.id,\n            name: payload.data.project.name,\n            webUrl: payload.data.project.webUrl\n        };\n        const currentIssues = payload.data.project.issues.nodes.map((node)=>transformIssueNode(node, range));\n        issues.push(...currentIssues);\n        pageInfo = payload.data.project.issues.pageInfo;\n    }while (pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.hasNextPage);\n    const summary = buildTimeSummary(issues);\n    return {\n        project: projectMeta !== null && projectMeta !== void 0 ? projectMeta : {\n            id: \"unknown\",\n            name: projectFullPath,\n            webUrl: \"\"\n        },\n        issues,\n        summary,\n        range,\n        generatedAt: new Date().toISOString()\n    };\n}\nfunction transformIssueNode(node, range) {\n    var _node_timelogs, _node_labels_nodes, _node_labels;\n    var _node_timelogs_nodes;\n    const timelogs = ((_node_timelogs_nodes = (_node_timelogs = node.timelogs) === null || _node_timelogs === void 0 ? void 0 : _node_timelogs.nodes) !== null && _node_timelogs_nodes !== void 0 ? _node_timelogs_nodes : []).filter((log)=>{\n        if (!log || log.timeSpent <= 0) {\n            return false;\n        }\n        return isWithinRange(log.spentAt, range);\n    }).map((log)=>{\n        var _log_user, _log_user1, _log_user2;\n        var _log_user_id, _log_user_name, _log_user_username;\n        return {\n            id: log.id,\n            spentAt: log.spentAt,\n            seconds: log.timeSpent,\n            summary: log.summary,\n            user: {\n                id: (_log_user_id = (_log_user = log.user) === null || _log_user === void 0 ? void 0 : _log_user.id) !== null && _log_user_id !== void 0 ? _log_user_id : \"unknown\",\n                name: (_log_user_name = (_log_user1 = log.user) === null || _log_user1 === void 0 ? void 0 : _log_user1.name) !== null && _log_user_name !== void 0 ? _log_user_name : \"Unknown\",\n                username: (_log_user_username = (_log_user2 = log.user) === null || _log_user2 === void 0 ? void 0 : _log_user2.username) !== null && _log_user_username !== void 0 ? _log_user_username : \"unknown\"\n            }\n        };\n    });\n    var _node_labels_nodes_map;\n    return {\n        id: node.id,\n        iid: node.iid,\n        title: node.title,\n        webUrl: node.webUrl,\n        state: node.state,\n        labels: (_node_labels_nodes_map = (_node_labels = node.labels) === null || _node_labels === void 0 ? void 0 : (_node_labels_nodes = _node_labels.nodes) === null || _node_labels_nodes === void 0 ? void 0 : _node_labels_nodes.map((label)=>label.title)) !== null && _node_labels_nodes_map !== void 0 ? _node_labels_nodes_map : [],\n        epic: node.epic ? {\n            id: node.epic.id,\n            iid: node.epic.iid,\n            title: node.epic.title,\n            webUrl: node.epic.webUrl\n        } : null,\n        timelogs\n    };\n}\nfunction isWithinRange(spentAt, range) {\n    if (!range.from && !range.to) {\n        return true;\n    }\n    const timestamp = Date.parse(spentAt);\n    if (Number.isNaN(timestamp)) {\n        return true;\n    }\n    if (range.from) {\n        const fromTs = Date.parse(range.from);\n        if (!Number.isNaN(fromTs) && timestamp < fromTs) {\n            return false;\n        }\n    }\n    if (range.to) {\n        const toTs = Date.parse(range.to);\n        if (!Number.isNaN(toTs) && timestamp >= toTs) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction buildTimeSummary(issues) {\n    let totalSeconds = 0;\n    const byUser = new Map();\n    const byIssue = new Map();\n    const byEpic = new Map();\n    const byDate = new Map();\n    for (const issue of issues){\n        var _issue_epic, _issue_epic1;\n        let issueSeconds = 0;\n        for (const timelog of issue.timelogs){\n            totalSeconds += timelog.seconds;\n            issueSeconds += timelog.seconds;\n            const dateKey = timelog.spentAt ? timelog.spentAt.slice(0, 10) : \"unknown\";\n            var _byDate_get;\n            byDate.set(dateKey, ((_byDate_get = byDate.get(dateKey)) !== null && _byDate_get !== void 0 ? _byDate_get : 0) + timelog.seconds);\n            const userKey = timelog.user.username || timelog.user.id;\n            var _byUser_get;\n            const userGroup = (_byUser_get = byUser.get(userKey)) !== null && _byUser_get !== void 0 ? _byUser_get : {\n                label: timelog.user.name,\n                seconds: 0,\n                hints: {\n                    username: timelog.user.username\n                }\n            };\n            userGroup.seconds += timelog.seconds;\n            byUser.set(userKey, userGroup);\n        }\n        var _byIssue_get;\n        const issueGroup = (_byIssue_get = byIssue.get(issue.id)) !== null && _byIssue_get !== void 0 ? _byIssue_get : {\n            label: \"#\".concat(issue.iid, \" \").concat(issue.title),\n            seconds: 0,\n            hints: {\n                issueUrl: issue.webUrl,\n                state: issue.state\n            }\n        };\n        issueGroup.seconds += issueSeconds;\n        byIssue.set(issue.id, issueGroup);\n        var _issue_epic_id;\n        const epicKey = (_issue_epic_id = (_issue_epic = issue.epic) === null || _issue_epic === void 0 ? void 0 : _issue_epic.id) !== null && _issue_epic_id !== void 0 ? _issue_epic_id : \"unassigned\";\n        const epicLabel = issue.epic ? issue.epic.title : \"No epic\";\n        var _issue_epic_webUrl, _byEpic_get;\n        const epicGroup = (_byEpic_get = byEpic.get(epicKey)) !== null && _byEpic_get !== void 0 ? _byEpic_get : {\n            label: epicLabel,\n            seconds: 0,\n            hints: {\n                epicUrl: (_issue_epic_webUrl = (_issue_epic1 = issue.epic) === null || _issue_epic1 === void 0 ? void 0 : _issue_epic1.webUrl) !== null && _issue_epic_webUrl !== void 0 ? _issue_epic_webUrl : undefined\n            }\n        };\n        epicGroup.seconds += issueSeconds;\n        byEpic.set(epicKey, epicGroup);\n    }\n    return {\n        totalSeconds,\n        byUser: Array.from(byUser.values()).sort((a, b)=>b.seconds - a.seconds),\n        byIssue: Array.from(byIssue.values()).sort((a, b)=>b.seconds - a.seconds),\n        byEpic: Array.from(byEpic.values()).sort((a, b)=>b.seconds - a.seconds),\n        byDate: Array.from(byDate.entries()).map((param)=>{\n            let [date, seconds] = param;\n            return {\n                date,\n                seconds\n            };\n        }).sort((a, b)=>a.date.localeCompare(b.date))\n    };\n}\nfunction secondsToHours(seconds) {\n    return Math.round(seconds / 3600 * 100) / 100;\n}\nfunction formatDuration(seconds) {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor(seconds % 3600 / 60);\n    if (hours === 0 && minutes === 0) {\n        return \"<1m\";\n    }\n    if (hours === 0) {\n        return \"\".concat(minutes, \"m\");\n    }\n    if (minutes === 0) {\n        return \"\".concat(hours, \"h\");\n    }\n    return \"\".concat(hours, \"h \").concat(minutes, \"m\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0MsSUFBTUEsRUFBRTVDLE9BQU8sR0FBRzJDLEVBQUUzQyxPQUFPO1FBQzFFcUIsUUFBUW1CLE1BQU0vQixJQUFJLENBQUNZLE9BQU9vQixNQUFNLElBQUlDLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFNUMsT0FBTyxHQUFHMkMsRUFBRTNDLE9BQU87UUFDeEVzQixRQUFRa0IsTUFBTS9CLElBQUksQ0FBQ2EsT0FBT3VCLE9BQU8sSUFDOUJ0RSxHQUFHLENBQUM7Z0JBQUMsQ0FBQ3VFLE1BQU05QyxRQUFRO21CQUFNO2dCQUFFOEM7Z0JBQU05QztZQUFRO1dBQzFDMEMsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVHLElBQUksQ0FBQ0MsYUFBYSxDQUFDSCxFQUFFRSxJQUFJO0lBQy9DO0FBQ0Y7QUFFTyxTQUFTRSxlQUFlaEQsT0FBZTtJQUM1QyxPQUFPaUQsS0FBS0MsS0FBSyxDQUFDLFVBQVcsT0FBUSxPQUFPO0FBQzlDO0FBRU8sU0FBU0MsZUFBZW5ELE9BQWU7SUFDNUMsTUFBTW9ELFFBQVFILEtBQUtJLEtBQUssQ0FBQ3JELFVBQVU7SUFDbkMsTUFBTXNELFVBQVVMLEtBQUtJLEtBQUssQ0FBQyxVQUFXLE9BQVE7SUFDOUMsSUFBSUQsVUFBVSxLQUFLRSxZQUFZLEdBQUc7UUFDaEMsT0FBTztJQUNUO0lBQ0EsSUFBSUYsVUFBVSxHQUFHO1FBQ2YsT0FBTyxHQUFXLE9BQVJFLFNBQVE7SUFDcEI7SUFDQSxJQUFJQSxZQUFZLEdBQUc7UUFDakIsT0FBTyxHQUFTLE9BQU5GLE9BQU07SUFDbEI7SUFDQSxPQUFPLEdBQWFFLE9BQVZGLE9BQU0sTUFBWSxPQUFSRSxTQUFRO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvZ2l0bGFiLnRzPzk5ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgREVGQVVMVF9HUkFQSFFMX0VORFBPSU5UID0gXCJodHRwczovL2dpdGxhYi5jb20vYXBpL2dyYXBocWxcIjtcbmNvbnN0IERFRkFVTFRfSVNTVUVfUEFHRV9TSVpFID0gMjA7XG5jb25zdCBERUZBVUxUX1RJTUVMT0dfUEFHRV9TSVpFID0gMTAwO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdpdExhYkNyZWRlbnRpYWxzIHtcbiAgYXBpVXJsPzogc3RyaW5nO1xuICB0b2tlbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVSYW5nZUZpbHRlciB7XG4gIGZyb20/OiBzdHJpbmc7XG4gIHRvPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdpdExhYklzc3VlVGltZWxvZyB7XG4gIGlkOiBzdHJpbmc7XG4gIHNwZW50QXQ6IHN0cmluZztcbiAgc2Vjb25kczogbnVtYmVyO1xuICB1c2VyOiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgdXNlcm5hbWU6IHN0cmluZztcbiAgfTtcbiAgc3VtbWFyeT86IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2l0TGFiSXNzdWVUaW1lIHtcbiAgaWQ6IHN0cmluZztcbiAgaWlkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHdlYlVybDogc3RyaW5nO1xuICBzdGF0ZTogc3RyaW5nO1xuICBsYWJlbHM6IHN0cmluZ1tdO1xuICBlcGljPzoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgaWlkPzogc3RyaW5nIHwgbnVsbDtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHdlYlVybD86IHN0cmluZyB8IG51bGw7XG4gIH0gfCBudWxsO1xuICB0aW1lbG9nczogR2l0TGFiSXNzdWVUaW1lbG9nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdFRpbWVSZXBvcnQge1xuICBwcm9qZWN0OiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgd2ViVXJsOiBzdHJpbmc7XG4gIH07XG4gIGlzc3VlczogR2l0TGFiSXNzdWVUaW1lW107XG4gIHN1bW1hcnk6IFRpbWVTdW1tYXJ5O1xuICByYW5nZTogVGltZVJhbmdlRmlsdGVyO1xuICBnZW5lcmF0ZWRBdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVTdW1tYXJ5R3JvdXAge1xuICBsYWJlbDogc3RyaW5nO1xuICBzZWNvbmRzOiBudW1iZXI7XG4gIGhpbnRzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaW1lU3VtbWFyeSB7XG4gIHRvdGFsU2Vjb25kczogbnVtYmVyO1xuICBieVVzZXI6IFRpbWVTdW1tYXJ5R3JvdXBbXTtcbiAgYnlJc3N1ZTogVGltZVN1bW1hcnlHcm91cFtdO1xuICBieUVwaWM6IFRpbWVTdW1tYXJ5R3JvdXBbXTtcbiAgYnlEYXRlOiB7IGRhdGU6IHN0cmluZzsgc2Vjb25kczogbnVtYmVyIH1bXTtcbn1cblxuaW50ZXJmYWNlIEdyYXBoUUxJc3N1ZU5vZGUge1xuICBpZDogc3RyaW5nO1xuICBpaWQ6IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgd2ViVXJsOiBzdHJpbmc7XG4gIHN0YXRlOiBzdHJpbmc7XG4gIGxhYmVsczogeyBub2RlczogQXJyYXk8eyB0aXRsZTogc3RyaW5nIH0+IH07XG4gIGVwaWM/OiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBpaWQ6IHN0cmluZyB8IG51bGw7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICB3ZWJVcmw6IHN0cmluZyB8IG51bGw7XG4gIH0gfCBudWxsO1xuICB0aW1lbG9nczoge1xuICAgIG5vZGVzOiBBcnJheTx7XG4gICAgICBpZDogc3RyaW5nO1xuICAgICAgc3BlbnRBdDogc3RyaW5nO1xuICAgICAgdGltZVNwZW50OiBudW1iZXI7XG4gICAgICBzdW1tYXJ5OiBzdHJpbmcgfCBudWxsO1xuICAgICAgdXNlcj86IHtcbiAgICAgICAgaWQ6IHN0cmluZztcbiAgICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgICB1c2VybmFtZTogc3RyaW5nO1xuICAgICAgfSB8IG51bGw7XG4gICAgfT47XG4gIH07XG59XG5cbmludGVyZmFjZSBHcmFwaFFMUmVzcG9uc2U8VD4ge1xuICBkYXRhPzogVDtcbiAgZXJyb3JzPzogQXJyYXk8eyBtZXNzYWdlOiBzdHJpbmcgfT47XG59XG5cbmludGVyZmFjZSBJc3N1ZVBhZ2VQYXlsb2FkIHtcbiAgcHJvamVjdDoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHdlYlVybDogc3RyaW5nO1xuICAgIGlzc3Vlczoge1xuICAgICAgbm9kZXM6IEdyYXBoUUxJc3N1ZU5vZGVbXTtcbiAgICAgIHBhZ2VJbmZvOiB7XG4gICAgICAgIGhhc05leHRQYWdlOiBib29sZWFuO1xuICAgICAgICBlbmRDdXJzb3I6IHN0cmluZyB8IG51bGw7XG4gICAgICB9O1xuICAgIH07XG4gIH0gfCBudWxsO1xufVxuXG5jb25zdCBJU1NVRV9USU1FTE9HU19RVUVSWSA9IGBcbiAgcXVlcnkgUHJvamVjdElzc3VlVGltZWxvZ3MoXG4gICAgJGZ1bGxQYXRoOiBJRCEsXG4gICAgJGlzc3Vlc0ZpcnN0OiBJbnQhLFxuICAgICRpc3N1ZXNBZnRlcjogU3RyaW5nLFxuICAgICR0aW1lbG9nRmlyc3Q6IEludCFcbiAgKSB7XG4gICAgcHJvamVjdChmdWxsUGF0aDogJGZ1bGxQYXRoKSB7XG4gICAgICBpZFxuICAgICAgbmFtZVxuICAgICAgd2ViVXJsXG4gICAgICBpc3N1ZXMoZmlyc3Q6ICRpc3N1ZXNGaXJzdCwgYWZ0ZXI6ICRpc3N1ZXNBZnRlciwgc29ydDogVVBEQVRFRF9ERVNDKSB7XG4gICAgICAgIG5vZGVzIHtcbiAgICAgICAgICBpZFxuICAgICAgICAgIGlpZFxuICAgICAgICAgIHRpdGxlXG4gICAgICAgICAgd2ViVXJsXG4gICAgICAgICAgc3RhdGVcbiAgICAgICAgICBsYWJlbHMoZmlyc3Q6IDEwKSB7XG4gICAgICAgICAgICBub2RlcyB7XG4gICAgICAgICAgICAgIHRpdGxlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVwaWMge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIGlpZFxuICAgICAgICAgICAgdGl0bGVcbiAgICAgICAgICAgIHdlYlVybFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aW1lbG9ncyhmaXJzdDogJHRpbWVsb2dGaXJzdCkge1xuICAgICAgICAgICAgbm9kZXMge1xuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICBzcGVudEF0XG4gICAgICAgICAgICAgIHRpbWVTcGVudFxuICAgICAgICAgICAgICBzdW1tYXJ5XG4gICAgICAgICAgICAgIHVzZXIge1xuICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgICAgIHVzZXJuYW1lXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFnZUluZm8ge1xuICAgICAgICAgIGhhc05leHRQYWdlXG4gICAgICAgICAgZW5kQ3Vyc29yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbmA7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFByb2plY3RUaW1lUmVwb3J0KFxuICBwcm9qZWN0RnVsbFBhdGg6IHN0cmluZyxcbiAgY3JlZGVudGlhbHM6IEdpdExhYkNyZWRlbnRpYWxzLFxuICByYW5nZTogVGltZVJhbmdlRmlsdGVyLFxuICBpc3N1ZVBhZ2VTaXplOiBudW1iZXIgPSBERUZBVUxUX0lTU1VFX1BBR0VfU0laRSxcbiAgdGltZWxvZ1BhZ2VTaXplOiBudW1iZXIgPSBERUZBVUxUX1RJTUVMT0dfUEFHRV9TSVpFXG4pOiBQcm9taXNlPFByb2plY3RUaW1lUmVwb3J0PiB7XG4gIGNvbnN0IGFwaVVybCA9IGNyZWRlbnRpYWxzLmFwaVVybD8udHJpbSgpIHx8IERFRkFVTFRfR1JBUEhRTF9FTkRQT0lOVDtcbiAgY29uc3QgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7Y3JlZGVudGlhbHMudG9rZW59YFxuICB9O1xuXG4gIGlmICghcHJvamVjdEZ1bGxQYXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBHaXRMYWIgcHJvamVjdCBmdWxsIHBhdGguXCIpO1xuICB9XG5cbiAgaWYgKCFjcmVkZW50aWFscy50b2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgR2l0TGFiIGFjY2VzcyB0b2tlbi5cIik7XG4gIH1cblxuICBjb25zdCBpc3N1ZXM6IEdpdExhYklzc3VlVGltZVtdID0gW107XG4gIGxldCBwYWdlSW5mbzogeyBoYXNOZXh0UGFnZTogYm9vbGVhbjsgZW5kQ3Vyc29yOiBzdHJpbmcgfCBudWxsIH0gfCBudWxsID0gbnVsbDtcbiAgbGV0IHByb2plY3RNZXRhOiB7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgd2ViVXJsOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsO1xuXG4gIGRvIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFwaVVybCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHF1ZXJ5OiBJU1NVRV9USU1FTE9HU19RVUVSWSxcbiAgICAgICAgdmFyaWFibGVzOiB7XG4gICAgICAgICAgZnVsbFBhdGg6IHByb2plY3RGdWxsUGF0aCxcbiAgICAgICAgICBpc3N1ZXNGaXJzdDogaXNzdWVQYWdlU2l6ZSxcbiAgICAgICAgICBpc3N1ZXNBZnRlcjogcGFnZUluZm8/LmVuZEN1cnNvciA/PyBudWxsLFxuICAgICAgICAgIHRpbWVsb2dGaXJzdDogdGltZWxvZ1BhZ2VTaXplXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYEdpdExhYiBHcmFwaFFMIHJlc3BvbmRlZCB3aXRoICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXlsb2FkID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSkgYXMgR3JhcGhRTFJlc3BvbnNlPElzc3VlUGFnZVBheWxvYWQ+O1xuXG4gICAgaWYgKHBheWxvYWQuZXJyb3JzPy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwYXlsb2FkLmVycm9ycy5tYXAoKGVycikgPT4gZXJyLm1lc3NhZ2UpLmpvaW4oXCI7IFwiKSk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXlsb2FkLmRhdGE/LnByb2plY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb2plY3Qgbm90IGZvdW5kIG9yIGFjY2VzcyBkZW5pZWQuXCIpO1xuICAgIH1cblxuICAgIHByb2plY3RNZXRhID0ge1xuICAgICAgaWQ6IHBheWxvYWQuZGF0YS5wcm9qZWN0LmlkLFxuICAgICAgbmFtZTogcGF5bG9hZC5kYXRhLnByb2plY3QubmFtZSxcbiAgICAgIHdlYlVybDogcGF5bG9hZC5kYXRhLnByb2plY3Qud2ViVXJsXG4gICAgfTtcblxuICAgIGNvbnN0IGN1cnJlbnRJc3N1ZXMgPSBwYXlsb2FkLmRhdGEucHJvamVjdC5pc3N1ZXMubm9kZXMubWFwKChub2RlKSA9PlxuICAgICAgdHJhbnNmb3JtSXNzdWVOb2RlKG5vZGUsIHJhbmdlKVxuICAgICk7XG4gICAgaXNzdWVzLnB1c2goLi4uY3VycmVudElzc3Vlcyk7XG5cbiAgICBwYWdlSW5mbyA9IHBheWxvYWQuZGF0YS5wcm9qZWN0Lmlzc3Vlcy5wYWdlSW5mbztcbiAgfSB3aGlsZSAocGFnZUluZm8/Lmhhc05leHRQYWdlKTtcblxuICBjb25zdCBzdW1tYXJ5ID0gYnVpbGRUaW1lU3VtbWFyeShpc3N1ZXMpO1xuXG4gIHJldHVybiB7XG4gICAgcHJvamVjdDogcHJvamVjdE1ldGEgPz8ge1xuICAgICAgaWQ6IFwidW5rbm93blwiLFxuICAgICAgbmFtZTogcHJvamVjdEZ1bGxQYXRoLFxuICAgICAgd2ViVXJsOiBcIlwiXG4gICAgfSxcbiAgICBpc3N1ZXMsXG4gICAgc3VtbWFyeSxcbiAgICByYW5nZSxcbiAgICBnZW5lcmF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUlzc3VlTm9kZShcbiAgbm9kZTogR3JhcGhRTElzc3VlTm9kZSxcbiAgcmFuZ2U6IFRpbWVSYW5nZUZpbHRlclxuKTogR2l0TGFiSXNzdWVUaW1lIHtcbiAgY29uc3QgdGltZWxvZ3MgPSAobm9kZS50aW1lbG9ncz8ubm9kZXMgPz8gW10pXG4gICAgLmZpbHRlcigobG9nKTogbG9nIGlzIE5vbk51bGxhYmxlPHR5cGVvZiBsb2c+ID0+IHtcbiAgICAgIGlmICghbG9nIHx8IGxvZy50aW1lU3BlbnQgPD0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNXaXRoaW5SYW5nZShsb2cuc3BlbnRBdCwgcmFuZ2UpO1xuICAgIH0pXG4gICAgLm1hcCgobG9nKSA9PiAoe1xuICAgICAgaWQ6IGxvZy5pZCxcbiAgICAgIHNwZW50QXQ6IGxvZy5zcGVudEF0LFxuICAgICAgc2Vjb25kczogbG9nLnRpbWVTcGVudCxcbiAgICAgIHN1bW1hcnk6IGxvZy5zdW1tYXJ5LFxuICAgICAgdXNlcjoge1xuICAgICAgICBpZDogbG9nLnVzZXI/LmlkID8/IFwidW5rbm93blwiLFxuICAgICAgICBuYW1lOiBsb2cudXNlcj8ubmFtZSA/PyBcIlVua25vd25cIixcbiAgICAgICAgdXNlcm5hbWU6IGxvZy51c2VyPy51c2VybmFtZSA/PyBcInVua25vd25cIlxuICAgICAgfVxuICAgIH0pKTtcblxuICByZXR1cm4ge1xuICAgIGlkOiBub2RlLmlkLFxuICAgIGlpZDogbm9kZS5paWQsXG4gICAgdGl0bGU6IG5vZGUudGl0bGUsXG4gICAgd2ViVXJsOiBub2RlLndlYlVybCxcbiAgICBzdGF0ZTogbm9kZS5zdGF0ZSxcbiAgICBsYWJlbHM6IG5vZGUubGFiZWxzPy5ub2Rlcz8ubWFwKChsYWJlbCkgPT4gbGFiZWwudGl0bGUpID8/IFtdLFxuICAgIGVwaWM6IG5vZGUuZXBpY1xuICAgICAgPyB7XG4gICAgICAgICAgaWQ6IG5vZGUuZXBpYy5pZCxcbiAgICAgICAgICBpaWQ6IG5vZGUuZXBpYy5paWQsXG4gICAgICAgICAgdGl0bGU6IG5vZGUuZXBpYy50aXRsZSxcbiAgICAgICAgICB3ZWJVcmw6IG5vZGUuZXBpYy53ZWJVcmxcbiAgICAgICAgfVxuICAgICAgOiBudWxsLFxuICAgIHRpbWVsb2dzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzV2l0aGluUmFuZ2Uoc3BlbnRBdDogc3RyaW5nLCByYW5nZTogVGltZVJhbmdlRmlsdGVyKTogYm9vbGVhbiB7XG4gIGlmICghcmFuZ2UuZnJvbSAmJiAhcmFuZ2UudG8pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUucGFyc2Uoc3BlbnRBdCk7XG4gIGlmIChOdW1iZXIuaXNOYU4odGltZXN0YW1wKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHJhbmdlLmZyb20pIHtcbiAgICBjb25zdCBmcm9tVHMgPSBEYXRlLnBhcnNlKHJhbmdlLmZyb20pO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKGZyb21UcykgJiYgdGltZXN0YW1wIDwgZnJvbVRzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJhbmdlLnRvKSB7XG4gICAgY29uc3QgdG9UcyA9IERhdGUucGFyc2UocmFuZ2UudG8pO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHRvVHMpICYmIHRpbWVzdGFtcCA+PSB0b1RzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVGltZVN1bW1hcnkoaXNzdWVzOiBHaXRMYWJJc3N1ZVRpbWVbXSk6IFRpbWVTdW1tYXJ5IHtcbiAgbGV0IHRvdGFsU2Vjb25kcyA9IDA7XG4gIGNvbnN0IGJ5VXNlciA9IG5ldyBNYXA8c3RyaW5nLCBUaW1lU3VtbWFyeUdyb3VwPigpO1xuICBjb25zdCBieUlzc3VlID0gbmV3IE1hcDxzdHJpbmcsIFRpbWVTdW1tYXJ5R3JvdXA+KCk7XG4gIGNvbnN0IGJ5RXBpYyA9IG5ldyBNYXA8c3RyaW5nLCBUaW1lU3VtbWFyeUdyb3VwPigpO1xuICBjb25zdCBieURhdGUgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gIGZvciAoY29uc3QgaXNzdWUgb2YgaXNzdWVzKSB7XG4gICAgbGV0IGlzc3VlU2Vjb25kcyA9IDA7XG4gICAgZm9yIChjb25zdCB0aW1lbG9nIG9mIGlzc3VlLnRpbWVsb2dzKSB7XG4gICAgICB0b3RhbFNlY29uZHMgKz0gdGltZWxvZy5zZWNvbmRzO1xuICAgICAgaXNzdWVTZWNvbmRzICs9IHRpbWVsb2cuc2Vjb25kcztcblxuICAgICAgY29uc3QgZGF0ZUtleSA9IHRpbWVsb2cuc3BlbnRBdCA/IHRpbWVsb2cuc3BlbnRBdC5zbGljZSgwLCAxMCkgOiBcInVua25vd25cIjtcbiAgICAgIGJ5RGF0ZS5zZXQoZGF0ZUtleSwgKGJ5RGF0ZS5nZXQoZGF0ZUtleSkgPz8gMCkgKyB0aW1lbG9nLnNlY29uZHMpO1xuXG4gICAgICBjb25zdCB1c2VyS2V5ID0gdGltZWxvZy51c2VyLnVzZXJuYW1lIHx8IHRpbWVsb2cudXNlci5pZDtcbiAgICAgIGNvbnN0IHVzZXJHcm91cCA9IGJ5VXNlci5nZXQodXNlcktleSkgPz8ge1xuICAgICAgICBsYWJlbDogdGltZWxvZy51c2VyLm5hbWUsXG4gICAgICAgIHNlY29uZHM6IDAsXG4gICAgICAgIGhpbnRzOiB7XG4gICAgICAgICAgdXNlcm5hbWU6IHRpbWVsb2cudXNlci51c2VybmFtZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXNlckdyb3VwLnNlY29uZHMgKz0gdGltZWxvZy5zZWNvbmRzO1xuICAgICAgYnlVc2VyLnNldCh1c2VyS2V5LCB1c2VyR3JvdXApO1xuICAgIH1cblxuICAgIGNvbnN0IGlzc3VlR3JvdXAgPSBieUlzc3VlLmdldChpc3N1ZS5pZCkgPz8ge1xuICAgICAgbGFiZWw6IGAjJHtpc3N1ZS5paWR9ICR7aXNzdWUudGl0bGV9YCxcbiAgICAgIHNlY29uZHM6IDAsXG4gICAgICBoaW50czoge1xuICAgICAgICBpc3N1ZVVybDogaXNzdWUud2ViVXJsLFxuICAgICAgICBzdGF0ZTogaXNzdWUuc3RhdGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGlzc3VlR3JvdXAuc2Vjb25kcyArPSBpc3N1ZVNlY29uZHM7XG4gICAgYnlJc3N1ZS5zZXQoaXNzdWUuaWQsIGlzc3VlR3JvdXApO1xuXG4gICAgY29uc3QgZXBpY0tleSA9IGlzc3VlLmVwaWM/LmlkID8/IFwidW5hc3NpZ25lZFwiO1xuICAgIGNvbnN0IGVwaWNMYWJlbCA9IGlzc3VlLmVwaWMgPyBpc3N1ZS5lcGljLnRpdGxlIDogXCJObyBlcGljXCI7XG4gICAgY29uc3QgZXBpY0dyb3VwID0gYnlFcGljLmdldChlcGljS2V5KSA/PyB7XG4gICAgICBsYWJlbDogZXBpY0xhYmVsLFxuICAgICAgc2Vjb25kczogMCxcbiAgICAgIGhpbnRzOiB7XG4gICAgICAgIGVwaWNVcmw6IGlzc3VlLmVwaWM/LndlYlVybCA/PyB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9O1xuICAgIGVwaWNHcm91cC5zZWNvbmRzICs9IGlzc3VlU2Vjb25kcztcbiAgICBieUVwaWMuc2V0KGVwaWNLZXksIGVwaWNHcm91cCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvdGFsU2Vjb25kcyxcbiAgICBieVVzZXI6IEFycmF5LmZyb20oYnlVc2VyLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiBiLnNlY29uZHMgLSBhLnNlY29uZHMpLFxuICAgIGJ5SXNzdWU6IEFycmF5LmZyb20oYnlJc3N1ZS52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4gYi5zZWNvbmRzIC0gYS5zZWNvbmRzKSxcbiAgICBieUVwaWM6IEFycmF5LmZyb20oYnlFcGljLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiBiLnNlY29uZHMgLSBhLnNlY29uZHMpLFxuICAgIGJ5RGF0ZTogQXJyYXkuZnJvbShieURhdGUuZW50cmllcygpKVxuICAgICAgLm1hcCgoW2RhdGUsIHNlY29uZHNdKSA9PiAoeyBkYXRlLCBzZWNvbmRzIH0pKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZGF0ZS5sb2NhbGVDb21wYXJlKGIuZGF0ZSkpXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWNvbmRzVG9Ib3VycyhzZWNvbmRzOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5yb3VuZCgoc2Vjb25kcyAvIDM2MDApICogMTAwKSAvIDEwMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdER1cmF0aW9uKHNlY29uZHM6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gMzYwMCk7XG4gIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKChzZWNvbmRzICUgMzYwMCkgLyA2MCk7XG4gIGlmIChob3VycyA9PT0gMCAmJiBtaW51dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIFwiPDFtXCI7XG4gIH1cbiAgaWYgKGhvdXJzID09PSAwKSB7XG4gICAgcmV0dXJuIGAke21pbnV0ZXN9bWA7XG4gIH1cbiAgaWYgKG1pbnV0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gYCR7aG91cnN9aGA7XG4gIH1cbiAgcmV0dXJuIGAke2hvdXJzfWggJHttaW51dGVzfW1gO1xufVxuIl0sIm5hbWVzIjpbIkRFRkFVTFRfR1JBUEhRTF9FTkRQT0lOVCIsIkRFRkFVTFRfSVNTVUVfUEFHRV9TSVpFIiwiREVGQVVMVF9USU1FTE9HX1BBR0VfU0laRSIsIklTU1VFX1RJTUVMT0dTX1FVRVJZIiwiZmV0Y2hQcm9qZWN0VGltZVJlcG9ydCIsInByb2plY3RGdWxsUGF0aCIsImNyZWRlbnRpYWxzIiwicmFuZ2UiLCJpc3N1ZVBhZ2VTaXplIiwidGltZWxvZ1BhZ2VTaXplIiwiYXBpVXJsIiwidHJpbSIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwidG9rZW4iLCJFcnJvciIsImlzc3VlcyIsInBhZ2VJbmZvIiwicHJvamVjdE1ldGEiLCJwYXlsb2FkIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicXVlcnkiLCJ2YXJpYWJsZXMiLCJmdWxsUGF0aCIsImlzc3Vlc0ZpcnN0IiwiaXNzdWVzQWZ0ZXIiLCJlbmRDdXJzb3IiLCJ0aW1lbG9nRmlyc3QiLCJvayIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwianNvbiIsImVycm9ycyIsImxlbmd0aCIsIm1hcCIsImVyciIsImpvaW4iLCJkYXRhIiwicHJvamVjdCIsImlkIiwibmFtZSIsIndlYlVybCIsImN1cnJlbnRJc3N1ZXMiLCJub2RlcyIsIm5vZGUiLCJ0cmFuc2Zvcm1Jc3N1ZU5vZGUiLCJwdXNoIiwiaGFzTmV4dFBhZ2UiLCJzdW1tYXJ5IiwiYnVpbGRUaW1lU3VtbWFyeSIsImdlbmVyYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidGltZWxvZ3MiLCJmaWx0ZXIiLCJsb2ciLCJ0aW1lU3BlbnQiLCJpc1dpdGhpblJhbmdlIiwic3BlbnRBdCIsInNlY29uZHMiLCJ1c2VyIiwidXNlcm5hbWUiLCJpaWQiLCJ0aXRsZSIsInN0YXRlIiwibGFiZWxzIiwibGFiZWwiLCJlcGljIiwiZnJvbSIsInRvIiwidGltZXN0YW1wIiwicGFyc2UiLCJOdW1iZXIiLCJpc05hTiIsImZyb21UcyIsInRvVHMiLCJ0b3RhbFNlY29uZHMiLCJieVVzZXIiLCJNYXAiLCJieUlzc3VlIiwiYnlFcGljIiwiYnlEYXRlIiwiaXNzdWUiLCJpc3N1ZVNlY29uZHMiLCJ0aW1lbG9nIiwiZGF0ZUtleSIsInNsaWNlIiwic2V0IiwiZ2V0IiwidXNlcktleSIsInVzZXJHcm91cCIsImhpbnRzIiwiaXNzdWVHcm91cCIsImlzc3VlVXJsIiwiZXBpY0tleSIsImVwaWNMYWJlbCIsImVwaWNHcm91cCIsImVwaWNVcmwiLCJ1bmRlZmluZWQiLCJBcnJheSIsInZhbHVlcyIsInNvcnQiLCJhIiwiYiIsImVudHJpZXMiLCJkYXRlIiwibG9jYWxlQ29tcGFyZSIsInNlY29uZHNUb0hvdXJzIiwiTWF0aCIsInJvdW5kIiwiZm9ybWF0RHVyYXRpb24iLCJob3VycyIsImZsb29yIiwibWludXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/gitlab.ts\n"));

/***/ })

});