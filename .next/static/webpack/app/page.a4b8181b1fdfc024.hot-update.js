"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/gitlab.ts":
/*!***************************!*\
  !*** ./app/lib/gitlab.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchCommitActivityByDay: function() { return /* binding */ fetchCommitActivityByDay; },\n/* harmony export */   fetchProjectTimeReport: function() { return /* binding */ fetchProjectTimeReport; },\n/* harmony export */   formatDuration: function() { return /* binding */ formatDuration; },\n/* harmony export */   secondsToHours: function() { return /* binding */ secondsToHours; }\n/* harmony export */ });\nconst DEFAULT_GRAPHQL_ENDPOINT = \"https://gitlab.com/api/graphql\";\nconst DEFAULT_ISSUE_PAGE_SIZE = 20;\nconst DEFAULT_TIMELOG_PAGE_SIZE = 100;\nconst DEFAULT_REST_ENDPOINT = \"https://gitlab.com/api/v4\";\nconst ISSUE_TIMELOGS_QUERY = \"\\n  query ProjectIssueTimelogs(\\n    $fullPath: ID!,\\n    $issuesFirst: Int!,\\n    $issuesAfter: String,\\n    $timelogFirst: Int!\\n  ) {\\n    project(fullPath: $fullPath) {\\n      id\\n      name\\n      webUrl\\n      issues(first: $issuesFirst, after: $issuesAfter, sort: UPDATED_DESC) {\\n        nodes {\\n          id\\n          iid\\n          title\\n          webUrl\\n          state\\n          labels(first: 10) {\\n            nodes {\\n              title\\n            }\\n          }\\n          epic {\\n            id\\n            iid\\n            title\\n            webUrl\\n          }\\n          timelogs(first: $timelogFirst) {\\n            nodes {\\n              id\\n              spentAt\\n              timeSpent\\n              summary\\n              user {\\n                id\\n                name\\n                username\\n              }\\n            }\\n          }\\n        }\\n        pageInfo {\\n          hasNextPage\\n          endCursor\\n        }\\n      }\\n    }\\n  }\\n\";\nasync function fetchProjectTimeReport(projectFullPath, credentials, range) {\n    let issuePageSize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : DEFAULT_ISSUE_PAGE_SIZE, timelogPageSize = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : DEFAULT_TIMELOG_PAGE_SIZE;\n    var _credentials_apiUrl;\n    const apiUrl = ((_credentials_apiUrl = credentials.apiUrl) === null || _credentials_apiUrl === void 0 ? void 0 : _credentials_apiUrl.trim()) || DEFAULT_GRAPHQL_ENDPOINT;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(credentials.token)\n    };\n    if (!projectFullPath) {\n        throw new Error(\"Missing GitLab project full path.\");\n    }\n    if (!credentials.token) {\n        throw new Error(\"Missing GitLab access token.\");\n    }\n    const issues = [];\n    let pageInfo = null;\n    let projectMeta = null;\n    do {\n        var _payload_errors, _payload_data;\n        var _pageInfo_endCursor;\n        const response = await fetch(apiUrl, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({\n                query: ISSUE_TIMELOGS_QUERY,\n                variables: {\n                    fullPath: projectFullPath,\n                    issuesFirst: issuePageSize,\n                    issuesAfter: (_pageInfo_endCursor = pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.endCursor) !== null && _pageInfo_endCursor !== void 0 ? _pageInfo_endCursor : null,\n                    timelogFirst: timelogPageSize\n                }\n            })\n        });\n        if (!response.ok) {\n            const message = \"GitLab GraphQL responded with \".concat(response.status, \" \").concat(response.statusText);\n            throw new Error(message);\n        }\n        const payload = await response.json();\n        if ((_payload_errors = payload.errors) === null || _payload_errors === void 0 ? void 0 : _payload_errors.length) {\n            throw new Error(payload.errors.map((err)=>err.message).join(\"; \"));\n        }\n        if (!((_payload_data = payload.data) === null || _payload_data === void 0 ? void 0 : _payload_data.project)) {\n            throw new Error(\"Project not found or access denied.\");\n        }\n        projectMeta = {\n            id: payload.data.project.id,\n            name: payload.data.project.name,\n            webUrl: payload.data.project.webUrl\n        };\n        const currentIssues = payload.data.project.issues.nodes.map((node)=>transformIssueNode(node, range));\n        issues.push(...currentIssues);\n        pageInfo = payload.data.project.issues.pageInfo;\n    }while (pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.hasNextPage);\n    const summary = buildTimeSummary(issues);\n    return {\n        project: projectMeta !== null && projectMeta !== void 0 ? projectMeta : {\n            id: \"unknown\",\n            name: projectFullPath,\n            webUrl: \"\"\n        },\n        issues,\n        summary,\n        range,\n        generatedAt: new Date().toISOString(),\n        commitActivity: [],\n        commitRange: null\n    };\n}\nfunction transformIssueNode(node, range) {\n    var _node_timelogs, _node_labels_nodes, _node_labels;\n    var _node_timelogs_nodes;\n    const timelogs = ((_node_timelogs_nodes = (_node_timelogs = node.timelogs) === null || _node_timelogs === void 0 ? void 0 : _node_timelogs.nodes) !== null && _node_timelogs_nodes !== void 0 ? _node_timelogs_nodes : []).filter((log)=>{\n        if (!log || log.timeSpent <= 0) {\n            return false;\n        }\n        return isWithinRange(log.spentAt, range);\n    }).map((log)=>{\n        var _log_user, _log_user1, _log_user2;\n        var _log_user_id, _log_user_name, _log_user_username;\n        return {\n            id: log.id,\n            spentAt: log.spentAt,\n            seconds: log.timeSpent,\n            summary: log.summary,\n            user: {\n                id: (_log_user_id = (_log_user = log.user) === null || _log_user === void 0 ? void 0 : _log_user.id) !== null && _log_user_id !== void 0 ? _log_user_id : \"unknown\",\n                name: (_log_user_name = (_log_user1 = log.user) === null || _log_user1 === void 0 ? void 0 : _log_user1.name) !== null && _log_user_name !== void 0 ? _log_user_name : \"Unknown\",\n                username: (_log_user_username = (_log_user2 = log.user) === null || _log_user2 === void 0 ? void 0 : _log_user2.username) !== null && _log_user_username !== void 0 ? _log_user_username : \"unknown\"\n            }\n        };\n    });\n    var _node_labels_nodes_map;\n    return {\n        id: node.id,\n        iid: node.iid,\n        title: node.title,\n        webUrl: node.webUrl,\n        state: node.state,\n        labels: (_node_labels_nodes_map = (_node_labels = node.labels) === null || _node_labels === void 0 ? void 0 : (_node_labels_nodes = _node_labels.nodes) === null || _node_labels_nodes === void 0 ? void 0 : _node_labels_nodes.map((label)=>label.title)) !== null && _node_labels_nodes_map !== void 0 ? _node_labels_nodes_map : [],\n        epic: node.epic ? {\n            id: node.epic.id,\n            iid: node.epic.iid,\n            title: node.epic.title,\n            webUrl: node.epic.webUrl\n        } : null,\n        timelogs\n    };\n}\nfunction isWithinRange(spentAt, range) {\n    if (!range.from && !range.to) {\n        return true;\n    }\n    const timestamp = Date.parse(spentAt);\n    if (Number.isNaN(timestamp)) {\n        return true;\n    }\n    if (range.from) {\n        const fromTs = Date.parse(range.from);\n        if (!Number.isNaN(fromTs) && timestamp < fromTs) {\n            return false;\n        }\n    }\n    if (range.to) {\n        const toTs = Date.parse(range.to);\n        if (!Number.isNaN(toTs) && timestamp >= toTs) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction buildTimeSummary(issues) {\n    let totalSeconds = 0;\n    const byUser = new Map();\n    const byIssue = new Map();\n    const byEpic = new Map();\n    const byDate = new Map();\n    const byLabel = new Map();\n    const byState = new Map();\n    const weeklyBuckets = new Map();\n    for (const issue of issues){\n        var _issue_epic, _issue_epic1;\n        let issueSeconds = 0;\n        for (const timelog of issue.timelogs){\n            totalSeconds += timelog.seconds;\n            issueSeconds += timelog.seconds;\n            const dateKey = timelog.spentAt ? timelog.spentAt.slice(0, 10) : \"unknown\";\n            var _byDate_get;\n            byDate.set(dateKey, ((_byDate_get = byDate.get(dateKey)) !== null && _byDate_get !== void 0 ? _byDate_get : 0) + timelog.seconds);\n            const userKey = timelog.user.username || timelog.user.id;\n            var _byUser_get;\n            const userGroup = (_byUser_get = byUser.get(userKey)) !== null && _byUser_get !== void 0 ? _byUser_get : {\n                label: timelog.user.name,\n                seconds: 0,\n                hints: {\n                    username: timelog.user.username\n                }\n            };\n            userGroup.seconds += timelog.seconds;\n            byUser.set(userKey, userGroup);\n            const weekBucket = getWeekBucket(timelog.spentAt);\n            if (weekBucket) {\n                var _weeklyBuckets_get;\n                const aggregate = (_weeklyBuckets_get = weeklyBuckets.get(weekBucket.key)) !== null && _weeklyBuckets_get !== void 0 ? _weeklyBuckets_get : {\n                    weekStart: weekBucket.start,\n                    label: weekBucket.label,\n                    totals: new Map(),\n                    totalSeconds: 0\n                };\n                var _aggregate_totals_get;\n                const userTotals = (_aggregate_totals_get = aggregate.totals.get(userKey)) !== null && _aggregate_totals_get !== void 0 ? _aggregate_totals_get : {\n                    userId: timelog.user.id,\n                    userName: timelog.user.name,\n                    username: timelog.user.username,\n                    seconds: 0\n                };\n                userTotals.seconds += timelog.seconds;\n                aggregate.totals.set(userKey, userTotals);\n                aggregate.totalSeconds += timelog.seconds;\n                weeklyBuckets.set(weekBucket.key, aggregate);\n            }\n        }\n        var _byIssue_get;\n        const issueGroup = (_byIssue_get = byIssue.get(issue.id)) !== null && _byIssue_get !== void 0 ? _byIssue_get : {\n            label: \"#\".concat(issue.iid, \" \").concat(issue.title),\n            seconds: 0,\n            hints: {\n                issueUrl: issue.webUrl,\n                state: issue.state\n            }\n        };\n        issueGroup.seconds += issueSeconds;\n        byIssue.set(issue.id, issueGroup);\n        var _issue_epic_id;\n        const epicKey = (_issue_epic_id = (_issue_epic = issue.epic) === null || _issue_epic === void 0 ? void 0 : _issue_epic.id) !== null && _issue_epic_id !== void 0 ? _issue_epic_id : \"unassigned\";\n        const epicLabel = issue.epic ? issue.epic.title : \"No epic\";\n        var _issue_epic_webUrl, _byEpic_get;\n        const epicGroup = (_byEpic_get = byEpic.get(epicKey)) !== null && _byEpic_get !== void 0 ? _byEpic_get : {\n            label: epicLabel,\n            seconds: 0,\n            hints: {\n                epicUrl: (_issue_epic_webUrl = (_issue_epic1 = issue.epic) === null || _issue_epic1 === void 0 ? void 0 : _issue_epic1.webUrl) !== null && _issue_epic_webUrl !== void 0 ? _issue_epic_webUrl : undefined\n            }\n        };\n        epicGroup.seconds += issueSeconds;\n        byEpic.set(epicKey, epicGroup);\n        const stateKey = issue.state || \"unknown\";\n        var _byState_get;\n        const stateGroup = (_byState_get = byState.get(stateKey)) !== null && _byState_get !== void 0 ? _byState_get : {\n            label: stateKey,\n            seconds: 0\n        };\n        stateGroup.seconds += issueSeconds;\n        byState.set(stateKey, stateGroup);\n        for (const label of issue.labels){\n            var _byLabel_get;\n            const labelGroup = (_byLabel_get = byLabel.get(label)) !== null && _byLabel_get !== void 0 ? _byLabel_get : {\n                label,\n                seconds: 0\n            };\n            labelGroup.seconds += issueSeconds;\n            byLabel.set(label, labelGroup);\n        }\n    }\n    return {\n        totalSeconds,\n        byUser: Array.from(byUser.values()).sort((a, b)=>b.seconds - a.seconds),\n        byIssue: Array.from(byIssue.values()).sort((a, b)=>b.seconds - a.seconds),\n        byEpic: Array.from(byEpic.values()).sort((a, b)=>b.seconds - a.seconds),\n        byLabel: Array.from(byLabel.values()).sort((a, b)=>b.seconds - a.seconds),\n        byState: Array.from(byState.values()).sort((a, b)=>b.seconds - a.seconds),\n        byDate: Array.from(byDate.entries()).map((param)=>{\n            let [date, seconds] = param;\n            return {\n                date,\n                seconds\n            };\n        }).sort((a, b)=>a.date.localeCompare(b.date)),\n        weeklyByUser: Array.from(weeklyBuckets.values()).map((bucket)=>({\n                weekStart: bucket.weekStart,\n                label: bucket.label,\n                totals: Array.from(bucket.totals.values()).sort((a, b)=>b.seconds - a.seconds),\n                totalSeconds: bucket.totalSeconds\n            })).sort((a, b)=>a.weekStart.localeCompare(b.weekStart))\n    };\n}\nfunction secondsToHours(seconds) {\n    return Math.round(seconds / 3600 * 100) / 100;\n}\nfunction formatDuration(seconds) {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor(seconds % 3600 / 60);\n    if (hours === 0 && minutes === 0) {\n        return \"<1m\";\n    }\n    if (hours === 0) {\n        return \"\".concat(minutes, \"m\");\n    }\n    if (minutes === 0) {\n        return \"\".concat(hours, \"h\");\n    }\n    return \"\".concat(hours, \"h \").concat(minutes, \"m\");\n}\nfunction getWeekBucket(spentAt) {\n    const timestamp = Date.parse(spentAt);\n    if (Number.isNaN(timestamp)) {\n        return null;\n    }\n    const weekStartDate = startOfWeek(new Date(timestamp));\n    const start = isoDateOnly(weekStartDate);\n    return {\n        key: start,\n        start,\n        label: formatWeekLabel(weekStartDate)\n    };\n}\nfunction startOfWeek(date) {\n    const start = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));\n    const day = start.getUTCDay();\n    const diff = day === 0 ? -6 : 1 - day;\n    start.setUTCDate(start.getUTCDate() + diff);\n    return start;\n}\nfunction isoDateOnly(date) {\n    return date.toISOString().slice(0, 10);\n}\nfunction formatWeekLabel(date) {\n    const formatter = new Intl.DateTimeFormat(undefined, {\n        month: \"short\",\n        day: \"numeric\"\n    });\n    return \"Week of \".concat(formatter.format(date));\n}\nfunction resolveRestEndpoint(graphqlUrl) {\n    if (!graphqlUrl) {\n        return DEFAULT_REST_ENDPOINT;\n    }\n    if (graphqlUrl.endsWith(\"/api/graphql\")) {\n        return graphqlUrl.replace(\"/api/graphql\", \"/api/v4\");\n    }\n    return DEFAULT_REST_ENDPOINT;\n}\nasync function fetchCommitActivityByDay(projectFullPath, credentials, month) {\n    if (!projectFullPath) {\n        throw new Error(\"Missing GitLab project full path.\");\n    }\n    if (!credentials.token) {\n        throw new Error(\"Missing GitLab access token.\");\n    }\n    if (!month || !/^\\d{4}-\\d{2}$/.test(month)) {\n        throw new Error(\"Field 'commitMonth' must use YYYY-MM format.\");\n    }\n    const [yearStr, monthStr] = month.split(\"-\");\n    const year = Number(yearStr);\n    const monthIndex = Number(monthStr) - 1;\n    const startDate = new Date(Date.UTC(year, monthIndex, 1));\n    const endDate = new Date(Date.UTC(year, monthIndex + 1, 1));\n    const since = startDate.toISOString();\n    const until = endDate.toISOString();\n    const restBase = resolveRestEndpoint(credentials.apiUrl);\n    const encodedProject = encodeURIComponent(projectFullPath);\n    const perPage = 100;\n    let page = 1;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(credentials.token)\n    };\n    const counts = new Map();\n    while(true){\n        const url = \"\".concat(restBase, \"/projects/\").concat(encodedProject, \"/repository/commits?since=\").concat(encodeURIComponent(since), \"&until=\").concat(encodeURIComponent(until), \"&per_page=\").concat(perPage, \"&page=\").concat(page, \"&with_stats=false\");\n        const response = await fetch(url, {\n            headers\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch commit activity (\".concat(response.status, \" \").concat(response.statusText, \").\"));\n        }\n        const payload = await response.json();\n        for (const commit of payload){\n            if (!(commit === null || commit === void 0 ? void 0 : commit.committed_date)) {\n                continue;\n            }\n            const dayKey = commit.committed_date.slice(0, 10);\n            var _counts_get;\n            counts.set(dayKey, ((_counts_get = counts.get(dayKey)) !== null && _counts_get !== void 0 ? _counts_get : 0) + 1);\n        }\n        const nextPage = response.headers.get(\"x-next-page\");\n        if (!nextPage) {\n            break;\n        }\n        const parsed = Number(nextPage);\n        if (!Number.isFinite(parsed) || parsed <= page) {\n            break;\n        }\n        page = parsed;\n    }\n    const days = [];\n    for(let cursor = new Date(startDate); cursor < endDate; cursor.setUTCDate(cursor.getUTCDate() + 1)){\n        const key = isoDateOnly(cursor);\n        var _counts_get1;\n        days.push({\n            date: key,\n            count: (_counts_get1 = counts.get(key)) !== null && _counts_get1 !== void 0 ? _counts_get1 : 0\n        });\n    }\n    return {\n        days,\n        range: {\n            month,\n            from: since,\n            to: until\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEtBQUssTUFBTThJLFVBQVVoSyxRQUFTO1lBQzVCLElBQUksRUFBQ2dLLG1CQUFBQSw2QkFBQUEsT0FBUUMsY0FBYyxHQUFFO2dCQUMzQjtZQUNGO1lBQ0EsTUFBTUMsU0FBU0YsT0FBT0MsY0FBYyxDQUFDbkYsS0FBSyxDQUFDLEdBQUc7Z0JBQzFCZ0Y7WUFBcEJBLE9BQU8vRSxHQUFHLENBQUNtRixRQUFRLENBQUNKLENBQUFBLGNBQUFBLE9BQU85RSxHQUFHLENBQUNrRixxQkFBWEoseUJBQUFBLGNBQXNCLEtBQUs7UUFDakQ7UUFFQSxNQUFNSyxXQUFXbEssU0FBU1IsT0FBTyxDQUFDdUYsR0FBRyxDQUFDO1FBQ3RDLElBQUksQ0FBQ21GLFVBQVU7WUFDYjtRQUNGO1FBQ0EsTUFBTUMsU0FBU3ZHLE9BQU9zRztRQUN0QixJQUFJLENBQUN0RyxPQUFPd0csUUFBUSxDQUFDRCxXQUFXQSxVQUFVUCxNQUFNO1lBQzlDO1FBQ0Y7UUFDQUEsT0FBT087SUFDVDtJQUVBLE1BQU1FLE9BQTRCLEVBQUU7SUFDcEMsSUFDRSxJQUFJQyxTQUFTLElBQUlqSSxLQUFLK0csWUFDdEJrQixTQUFTakIsU0FDVGlCLE9BQU9uQyxVQUFVLENBQUNtQyxPQUFPdkMsVUFBVSxLQUFLLEdBQ3hDO1FBQ0EsTUFBTXpDLE1BQU1vQyxZQUFZNEM7WUFHZlQ7UUFGVFEsS0FBS3JJLElBQUksQ0FBQztZQUNSNkUsTUFBTXZCO1lBQ05pRixPQUFPVixDQUFBQSxlQUFBQSxPQUFPOUUsR0FBRyxDQUFDTyxrQkFBWHVFLDBCQUFBQSxlQUFtQjtRQUM1QjtJQUNGO0lBRUEsT0FBTztRQUNMUTtRQUNBbEwsT0FBTztZQUNMb0o7WUFDQS9FLE1BQU04RjtZQUNON0YsSUFBSThGO1FBQ047SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvZ2l0bGFiLnRzPzk5ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgREVGQVVMVF9HUkFQSFFMX0VORFBPSU5UID0gXCJodHRwczovL2dpdGxhYi5jb20vYXBpL2dyYXBocWxcIjtcbmNvbnN0IERFRkFVTFRfSVNTVUVfUEFHRV9TSVpFID0gMjA7XG5jb25zdCBERUZBVUxUX1RJTUVMT0dfUEFHRV9TSVpFID0gMTAwO1xuY29uc3QgREVGQVVMVF9SRVNUX0VORFBPSU5UID0gXCJodHRwczovL2dpdGxhYi5jb20vYXBpL3Y0XCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2l0TGFiQ3JlZGVudGlhbHMge1xuICBhcGlVcmw/OiBzdHJpbmc7XG4gIHRva2VuOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGltZVJhbmdlRmlsdGVyIHtcbiAgZnJvbT86IHN0cmluZztcbiAgdG8/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2Vla2x5VXNlclRvdGFsIHtcbiAgdXNlcklkOiBzdHJpbmc7XG4gIHVzZXJOYW1lOiBzdHJpbmc7XG4gIHVzZXJuYW1lOiBzdHJpbmc7XG4gIHNlY29uZHM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXZWVrbHlVc2VyU3VtbWFyeSB7XG4gIHdlZWtTdGFydDogc3RyaW5nO1xuICBsYWJlbDogc3RyaW5nO1xuICB0b3RhbHM6IFdlZWtseVVzZXJUb3RhbFtdO1xuICB0b3RhbFNlY29uZHM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21taXRBY3Rpdml0eURheSB7XG4gIGRhdGU6IHN0cmluZztcbiAgY291bnQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21taXRSYW5nZSB7XG4gIG1vbnRoOiBzdHJpbmc7XG4gIGZyb206IHN0cmluZztcbiAgdG86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHaXRMYWJJc3N1ZVRpbWVsb2cge1xuICBpZDogc3RyaW5nO1xuICBzcGVudEF0OiBzdHJpbmc7XG4gIHNlY29uZHM6IG51bWJlcjtcbiAgdXNlcjoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gIH07XG4gIHN1bW1hcnk/OiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdpdExhYklzc3VlVGltZSB7XG4gIGlkOiBzdHJpbmc7XG4gIGlpZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICB3ZWJVcmw6IHN0cmluZztcbiAgc3RhdGU6IHN0cmluZztcbiAgbGFiZWxzOiBzdHJpbmdbXTtcbiAgZXBpYz86IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGlpZD86IHN0cmluZyB8IG51bGw7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICB3ZWJVcmw/OiBzdHJpbmcgfCBudWxsO1xuICB9IHwgbnVsbDtcbiAgdGltZWxvZ3M6IEdpdExhYklzc3VlVGltZWxvZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2plY3RUaW1lUmVwb3J0IHtcbiAgcHJvamVjdDoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHdlYlVybDogc3RyaW5nO1xuICB9O1xuICBpc3N1ZXM6IEdpdExhYklzc3VlVGltZVtdO1xuICBzdW1tYXJ5OiBUaW1lU3VtbWFyeTtcbiAgcmFuZ2U6IFRpbWVSYW5nZUZpbHRlcjtcbiAgZ2VuZXJhdGVkQXQ6IHN0cmluZztcbiAgY29tbWl0QWN0aXZpdHk/OiBDb21taXRBY3Rpdml0eURheVtdO1xuICBjb21taXRSYW5nZT86IENvbW1pdFJhbmdlIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaW1lU3VtbWFyeUdyb3VwIHtcbiAgbGFiZWw6IHN0cmluZztcbiAgc2Vjb25kczogbnVtYmVyO1xuICBoaW50cz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGltZVN1bW1hcnkge1xuICB0b3RhbFNlY29uZHM6IG51bWJlcjtcbiAgYnlVc2VyOiBUaW1lU3VtbWFyeUdyb3VwW107XG4gIGJ5SXNzdWU6IFRpbWVTdW1tYXJ5R3JvdXBbXTtcbiAgYnlFcGljOiBUaW1lU3VtbWFyeUdyb3VwW107XG4gIGJ5TGFiZWw6IFRpbWVTdW1tYXJ5R3JvdXBbXTtcbiAgYnlTdGF0ZTogVGltZVN1bW1hcnlHcm91cFtdO1xuICBieURhdGU6IHsgZGF0ZTogc3RyaW5nOyBzZWNvbmRzOiBudW1iZXIgfVtdO1xuICB3ZWVrbHlCeVVzZXI6IFdlZWtseVVzZXJTdW1tYXJ5W107XG59XG5cbmludGVyZmFjZSBHcmFwaFFMSXNzdWVOb2RlIHtcbiAgaWQ6IHN0cmluZztcbiAgaWlkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHdlYlVybDogc3RyaW5nO1xuICBzdGF0ZTogc3RyaW5nO1xuICBsYWJlbHM6IHsgbm9kZXM6IEFycmF5PHsgdGl0bGU6IHN0cmluZyB9PiB9O1xuICBlcGljPzoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgaWlkOiBzdHJpbmcgfCBudWxsO1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgd2ViVXJsOiBzdHJpbmcgfCBudWxsO1xuICB9IHwgbnVsbDtcbiAgdGltZWxvZ3M6IHtcbiAgICBub2RlczogQXJyYXk8e1xuICAgICAgaWQ6IHN0cmluZztcbiAgICAgIHNwZW50QXQ6IHN0cmluZztcbiAgICAgIHRpbWVTcGVudDogbnVtYmVyO1xuICAgICAgc3VtbWFyeTogc3RyaW5nIHwgbnVsbDtcbiAgICAgIHVzZXI/OiB7XG4gICAgICAgIGlkOiBzdHJpbmc7XG4gICAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgICAgdXNlcm5hbWU6IHN0cmluZztcbiAgICAgIH0gfCBudWxsO1xuICAgIH0+O1xuICB9O1xufVxuXG5pbnRlcmZhY2UgR3JhcGhRTFJlc3BvbnNlPFQ+IHtcbiAgZGF0YT86IFQ7XG4gIGVycm9ycz86IEFycmF5PHsgbWVzc2FnZTogc3RyaW5nIH0+O1xufVxuXG5pbnRlcmZhY2UgSXNzdWVQYWdlUGF5bG9hZCB7XG4gIHByb2plY3Q6IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB3ZWJVcmw6IHN0cmluZztcbiAgICBpc3N1ZXM6IHtcbiAgICAgIG5vZGVzOiBHcmFwaFFMSXNzdWVOb2RlW107XG4gICAgICBwYWdlSW5mbzoge1xuICAgICAgICBoYXNOZXh0UGFnZTogYm9vbGVhbjtcbiAgICAgICAgZW5kQ3Vyc29yOiBzdHJpbmcgfCBudWxsO1xuICAgICAgfTtcbiAgICB9O1xuICB9IHwgbnVsbDtcbn1cblxuY29uc3QgSVNTVUVfVElNRUxPR1NfUVVFUlkgPSBgXG4gIHF1ZXJ5IFByb2plY3RJc3N1ZVRpbWVsb2dzKFxuICAgICRmdWxsUGF0aDogSUQhLFxuICAgICRpc3N1ZXNGaXJzdDogSW50ISxcbiAgICAkaXNzdWVzQWZ0ZXI6IFN0cmluZyxcbiAgICAkdGltZWxvZ0ZpcnN0OiBJbnQhXG4gICkge1xuICAgIHByb2plY3QoZnVsbFBhdGg6ICRmdWxsUGF0aCkge1xuICAgICAgaWRcbiAgICAgIG5hbWVcbiAgICAgIHdlYlVybFxuICAgICAgaXNzdWVzKGZpcnN0OiAkaXNzdWVzRmlyc3QsIGFmdGVyOiAkaXNzdWVzQWZ0ZXIsIHNvcnQ6IFVQREFURURfREVTQykge1xuICAgICAgICBub2RlcyB7XG4gICAgICAgICAgaWRcbiAgICAgICAgICBpaWRcbiAgICAgICAgICB0aXRsZVxuICAgICAgICAgIHdlYlVybFxuICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgbGFiZWxzKGZpcnN0OiAxMCkge1xuICAgICAgICAgICAgbm9kZXMge1xuICAgICAgICAgICAgICB0aXRsZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlcGljIHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgICBpaWRcbiAgICAgICAgICAgIHRpdGxlXG4gICAgICAgICAgICB3ZWJVcmxcbiAgICAgICAgICB9XG4gICAgICAgICAgdGltZWxvZ3MoZmlyc3Q6ICR0aW1lbG9nRmlyc3QpIHtcbiAgICAgICAgICAgIG5vZGVzIHtcbiAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgc3BlbnRBdFxuICAgICAgICAgICAgICB0aW1lU3BlbnRcbiAgICAgICAgICAgICAgc3VtbWFyeVxuICAgICAgICAgICAgICB1c2VyIHtcbiAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICB1c2VybmFtZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhZ2VJbmZvIHtcbiAgICAgICAgICBoYXNOZXh0UGFnZVxuICAgICAgICAgIGVuZEN1cnNvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5gO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQcm9qZWN0VGltZVJlcG9ydChcbiAgcHJvamVjdEZ1bGxQYXRoOiBzdHJpbmcsXG4gIGNyZWRlbnRpYWxzOiBHaXRMYWJDcmVkZW50aWFscyxcbiAgcmFuZ2U6IFRpbWVSYW5nZUZpbHRlcixcbiAgaXNzdWVQYWdlU2l6ZTogbnVtYmVyID0gREVGQVVMVF9JU1NVRV9QQUdFX1NJWkUsXG4gIHRpbWVsb2dQYWdlU2l6ZTogbnVtYmVyID0gREVGQVVMVF9USU1FTE9HX1BBR0VfU0laRVxuKTogUHJvbWlzZTxQcm9qZWN0VGltZVJlcG9ydD4ge1xuICBjb25zdCBhcGlVcmwgPSBjcmVkZW50aWFscy5hcGlVcmw/LnRyaW0oKSB8fCBERUZBVUxUX0dSQVBIUUxfRU5EUE9JTlQ7XG4gIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NyZWRlbnRpYWxzLnRva2VufWBcbiAgfTtcblxuICBpZiAoIXByb2plY3RGdWxsUGF0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgR2l0TGFiIHByb2plY3QgZnVsbCBwYXRoLlwiKTtcbiAgfVxuXG4gIGlmICghY3JlZGVudGlhbHMudG9rZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIEdpdExhYiBhY2Nlc3MgdG9rZW4uXCIpO1xuICB9XG5cbiAgY29uc3QgaXNzdWVzOiBHaXRMYWJJc3N1ZVRpbWVbXSA9IFtdO1xuICBsZXQgcGFnZUluZm86IHsgaGFzTmV4dFBhZ2U6IGJvb2xlYW47IGVuZEN1cnNvcjogc3RyaW5nIHwgbnVsbCB9IHwgbnVsbCA9IG51bGw7XG4gIGxldCBwcm9qZWN0TWV0YTogeyBpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmc7IHdlYlVybDogc3RyaW5nIH0gfCBudWxsID0gbnVsbDtcblxuICBkbyB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGlVcmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBxdWVyeTogSVNTVUVfVElNRUxPR1NfUVVFUlksXG4gICAgICAgIHZhcmlhYmxlczoge1xuICAgICAgICAgIGZ1bGxQYXRoOiBwcm9qZWN0RnVsbFBhdGgsXG4gICAgICAgICAgaXNzdWVzRmlyc3Q6IGlzc3VlUGFnZVNpemUsXG4gICAgICAgICAgaXNzdWVzQWZ0ZXI6IHBhZ2VJbmZvPy5lbmRDdXJzb3IgPz8gbnVsbCxcbiAgICAgICAgICB0aW1lbG9nRmlyc3Q6IHRpbWVsb2dQYWdlU2l6ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBHaXRMYWIgR3JhcGhRTCByZXNwb25kZWQgd2l0aCAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWA7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpIGFzIEdyYXBoUUxSZXNwb25zZTxJc3N1ZVBhZ2VQYXlsb2FkPjtcblxuICAgIGlmIChwYXlsb2FkLmVycm9ycz8ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocGF5bG9hZC5lcnJvcnMubWFwKChlcnIpID0+IGVyci5tZXNzYWdlKS5qb2luKFwiOyBcIikpO1xuICAgIH1cblxuICAgIGlmICghcGF5bG9hZC5kYXRhPy5wcm9qZWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9qZWN0IG5vdCBmb3VuZCBvciBhY2Nlc3MgZGVuaWVkLlwiKTtcbiAgICB9XG5cbiAgICBwcm9qZWN0TWV0YSA9IHtcbiAgICAgIGlkOiBwYXlsb2FkLmRhdGEucHJvamVjdC5pZCxcbiAgICAgIG5hbWU6IHBheWxvYWQuZGF0YS5wcm9qZWN0Lm5hbWUsXG4gICAgICB3ZWJVcmw6IHBheWxvYWQuZGF0YS5wcm9qZWN0LndlYlVybFxuICAgIH07XG5cbiAgICBjb25zdCBjdXJyZW50SXNzdWVzID0gcGF5bG9hZC5kYXRhLnByb2plY3QuaXNzdWVzLm5vZGVzLm1hcCgobm9kZSkgPT5cbiAgICAgIHRyYW5zZm9ybUlzc3VlTm9kZShub2RlLCByYW5nZSlcbiAgICApO1xuICAgIGlzc3Vlcy5wdXNoKC4uLmN1cnJlbnRJc3N1ZXMpO1xuXG4gICAgcGFnZUluZm8gPSBwYXlsb2FkLmRhdGEucHJvamVjdC5pc3N1ZXMucGFnZUluZm87XG4gIH0gd2hpbGUgKHBhZ2VJbmZvPy5oYXNOZXh0UGFnZSk7XG5cbiAgY29uc3Qgc3VtbWFyeSA9IGJ1aWxkVGltZVN1bW1hcnkoaXNzdWVzKTtcblxuICByZXR1cm4ge1xuICAgIHByb2plY3Q6IHByb2plY3RNZXRhID8/IHtcbiAgICAgIGlkOiBcInVua25vd25cIixcbiAgICAgIG5hbWU6IHByb2plY3RGdWxsUGF0aCxcbiAgICAgIHdlYlVybDogXCJcIlxuICAgIH0sXG4gICAgaXNzdWVzLFxuICAgIHN1bW1hcnksXG4gICAgcmFuZ2UsXG4gICAgZ2VuZXJhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBjb21taXRBY3Rpdml0eTogW10sXG4gICAgY29tbWl0UmFuZ2U6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtSXNzdWVOb2RlKFxuICBub2RlOiBHcmFwaFFMSXNzdWVOb2RlLFxuICByYW5nZTogVGltZVJhbmdlRmlsdGVyXG4pOiBHaXRMYWJJc3N1ZVRpbWUge1xuICBjb25zdCB0aW1lbG9ncyA9IChub2RlLnRpbWVsb2dzPy5ub2RlcyA/PyBbXSlcbiAgICAuZmlsdGVyKChsb2cpOiBsb2cgaXMgTm9uTnVsbGFibGU8dHlwZW9mIGxvZz4gPT4ge1xuICAgICAgaWYgKCFsb2cgfHwgbG9nLnRpbWVTcGVudCA8PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1dpdGhpblJhbmdlKGxvZy5zcGVudEF0LCByYW5nZSk7XG4gICAgfSlcbiAgICAubWFwKChsb2cpID0+ICh7XG4gICAgICBpZDogbG9nLmlkLFxuICAgICAgc3BlbnRBdDogbG9nLnNwZW50QXQsXG4gICAgICBzZWNvbmRzOiBsb2cudGltZVNwZW50LFxuICAgICAgc3VtbWFyeTogbG9nLnN1bW1hcnksXG4gICAgICB1c2VyOiB7XG4gICAgICAgIGlkOiBsb2cudXNlcj8uaWQgPz8gXCJ1bmtub3duXCIsXG4gICAgICAgIG5hbWU6IGxvZy51c2VyPy5uYW1lID8/IFwiVW5rbm93blwiLFxuICAgICAgICB1c2VybmFtZTogbG9nLnVzZXI/LnVzZXJuYW1lID8/IFwidW5rbm93blwiXG4gICAgICB9XG4gICAgfSkpO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6IG5vZGUuaWQsXG4gICAgaWlkOiBub2RlLmlpZCxcbiAgICB0aXRsZTogbm9kZS50aXRsZSxcbiAgICB3ZWJVcmw6IG5vZGUud2ViVXJsLFxuICAgIHN0YXRlOiBub2RlLnN0YXRlLFxuICAgIGxhYmVsczogbm9kZS5sYWJlbHM/Lm5vZGVzPy5tYXAoKGxhYmVsKSA9PiBsYWJlbC50aXRsZSkgPz8gW10sXG4gICAgZXBpYzogbm9kZS5lcGljXG4gICAgICA/IHtcbiAgICAgICAgICBpZDogbm9kZS5lcGljLmlkLFxuICAgICAgICAgIGlpZDogbm9kZS5lcGljLmlpZCxcbiAgICAgICAgICB0aXRsZTogbm9kZS5lcGljLnRpdGxlLFxuICAgICAgICAgIHdlYlVybDogbm9kZS5lcGljLndlYlVybFxuICAgICAgICB9XG4gICAgICA6IG51bGwsXG4gICAgdGltZWxvZ3NcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNXaXRoaW5SYW5nZShzcGVudEF0OiBzdHJpbmcsIHJhbmdlOiBUaW1lUmFuZ2VGaWx0ZXIpOiBib29sZWFuIHtcbiAgaWYgKCFyYW5nZS5mcm9tICYmICFyYW5nZS50bykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5wYXJzZShzcGVudEF0KTtcbiAgaWYgKE51bWJlci5pc05hTih0aW1lc3RhbXApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAocmFuZ2UuZnJvbSkge1xuICAgIGNvbnN0IGZyb21UcyA9IERhdGUucGFyc2UocmFuZ2UuZnJvbSk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4oZnJvbVRzKSAmJiB0aW1lc3RhbXAgPCBmcm9tVHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAocmFuZ2UudG8pIHtcbiAgICBjb25zdCB0b1RzID0gRGF0ZS5wYXJzZShyYW5nZS50byk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4odG9UcykgJiYgdGltZXN0YW1wID49IHRvVHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYnVpbGRUaW1lU3VtbWFyeShpc3N1ZXM6IEdpdExhYklzc3VlVGltZVtdKTogVGltZVN1bW1hcnkge1xuICBsZXQgdG90YWxTZWNvbmRzID0gMDtcbiAgY29uc3QgYnlVc2VyID0gbmV3IE1hcDxzdHJpbmcsIFRpbWVTdW1tYXJ5R3JvdXA+KCk7XG4gIGNvbnN0IGJ5SXNzdWUgPSBuZXcgTWFwPHN0cmluZywgVGltZVN1bW1hcnlHcm91cD4oKTtcbiAgY29uc3QgYnlFcGljID0gbmV3IE1hcDxzdHJpbmcsIFRpbWVTdW1tYXJ5R3JvdXA+KCk7XG4gIGNvbnN0IGJ5RGF0ZSA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gIGNvbnN0IGJ5TGFiZWwgPSBuZXcgTWFwPHN0cmluZywgVGltZVN1bW1hcnlHcm91cD4oKTtcbiAgY29uc3QgYnlTdGF0ZSA9IG5ldyBNYXA8c3RyaW5nLCBUaW1lU3VtbWFyeUdyb3VwPigpO1xuICBjb25zdCB3ZWVrbHlCdWNrZXRzID0gbmV3IE1hcDxcbiAgICBzdHJpbmcsXG4gICAge1xuICAgICAgd2Vla1N0YXJ0OiBzdHJpbmc7XG4gICAgICBsYWJlbDogc3RyaW5nO1xuICAgICAgdG90YWxzOiBNYXA8c3RyaW5nLCBXZWVrbHlVc2VyVG90YWw+O1xuICAgICAgdG90YWxTZWNvbmRzOiBudW1iZXI7XG4gICAgfVxuICA+KCk7XG5cbiAgZm9yIChjb25zdCBpc3N1ZSBvZiBpc3N1ZXMpIHtcbiAgICBsZXQgaXNzdWVTZWNvbmRzID0gMDtcbiAgICBmb3IgKGNvbnN0IHRpbWVsb2cgb2YgaXNzdWUudGltZWxvZ3MpIHtcbiAgICAgIHRvdGFsU2Vjb25kcyArPSB0aW1lbG9nLnNlY29uZHM7XG4gICAgICBpc3N1ZVNlY29uZHMgKz0gdGltZWxvZy5zZWNvbmRzO1xuXG4gICAgICBjb25zdCBkYXRlS2V5ID0gdGltZWxvZy5zcGVudEF0ID8gdGltZWxvZy5zcGVudEF0LnNsaWNlKDAsIDEwKSA6IFwidW5rbm93blwiO1xuICAgICAgYnlEYXRlLnNldChkYXRlS2V5LCAoYnlEYXRlLmdldChkYXRlS2V5KSA/PyAwKSArIHRpbWVsb2cuc2Vjb25kcyk7XG5cbiAgICAgIGNvbnN0IHVzZXJLZXkgPSB0aW1lbG9nLnVzZXIudXNlcm5hbWUgfHwgdGltZWxvZy51c2VyLmlkO1xuICAgICAgY29uc3QgdXNlckdyb3VwID0gYnlVc2VyLmdldCh1c2VyS2V5KSA/PyB7XG4gICAgICAgIGxhYmVsOiB0aW1lbG9nLnVzZXIubmFtZSxcbiAgICAgICAgc2Vjb25kczogMCxcbiAgICAgICAgaGludHM6IHtcbiAgICAgICAgICB1c2VybmFtZTogdGltZWxvZy51c2VyLnVzZXJuYW1lXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1c2VyR3JvdXAuc2Vjb25kcyArPSB0aW1lbG9nLnNlY29uZHM7XG4gICAgICBieVVzZXIuc2V0KHVzZXJLZXksIHVzZXJHcm91cCk7XG5cbiAgICAgIGNvbnN0IHdlZWtCdWNrZXQgPSBnZXRXZWVrQnVja2V0KHRpbWVsb2cuc3BlbnRBdCk7XG4gICAgICBpZiAod2Vla0J1Y2tldCkge1xuICAgICAgICBjb25zdCBhZ2dyZWdhdGUgPVxuICAgICAgICAgIHdlZWtseUJ1Y2tldHMuZ2V0KHdlZWtCdWNrZXQua2V5KSA/P1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdlZWtTdGFydDogd2Vla0J1Y2tldC5zdGFydCxcbiAgICAgICAgICAgIGxhYmVsOiB3ZWVrQnVja2V0LmxhYmVsLFxuICAgICAgICAgICAgdG90YWxzOiBuZXcgTWFwPHN0cmluZywgV2Vla2x5VXNlclRvdGFsPigpLFxuICAgICAgICAgICAgdG90YWxTZWNvbmRzOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXNlclRvdGFscyA9XG4gICAgICAgICAgYWdncmVnYXRlLnRvdGFscy5nZXQodXNlcktleSkgPz9cbiAgICAgICAgICB7XG4gICAgICAgICAgICB1c2VySWQ6IHRpbWVsb2cudXNlci5pZCxcbiAgICAgICAgICAgIHVzZXJOYW1lOiB0aW1lbG9nLnVzZXIubmFtZSxcbiAgICAgICAgICAgIHVzZXJuYW1lOiB0aW1lbG9nLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICBzZWNvbmRzOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgdXNlclRvdGFscy5zZWNvbmRzICs9IHRpbWVsb2cuc2Vjb25kcztcbiAgICAgICAgYWdncmVnYXRlLnRvdGFscy5zZXQodXNlcktleSwgdXNlclRvdGFscyk7XG4gICAgICAgIGFnZ3JlZ2F0ZS50b3RhbFNlY29uZHMgKz0gdGltZWxvZy5zZWNvbmRzO1xuICAgICAgICB3ZWVrbHlCdWNrZXRzLnNldCh3ZWVrQnVja2V0LmtleSwgYWdncmVnYXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpc3N1ZUdyb3VwID0gYnlJc3N1ZS5nZXQoaXNzdWUuaWQpID8/IHtcbiAgICAgIGxhYmVsOiBgIyR7aXNzdWUuaWlkfSAke2lzc3VlLnRpdGxlfWAsXG4gICAgICBzZWNvbmRzOiAwLFxuICAgICAgaGludHM6IHtcbiAgICAgICAgaXNzdWVVcmw6IGlzc3VlLndlYlVybCxcbiAgICAgICAgc3RhdGU6IGlzc3VlLnN0YXRlXG4gICAgICB9XG4gICAgfTtcbiAgICBpc3N1ZUdyb3VwLnNlY29uZHMgKz0gaXNzdWVTZWNvbmRzO1xuICAgIGJ5SXNzdWUuc2V0KGlzc3VlLmlkLCBpc3N1ZUdyb3VwKTtcblxuICAgIGNvbnN0IGVwaWNLZXkgPSBpc3N1ZS5lcGljPy5pZCA/PyBcInVuYXNzaWduZWRcIjtcbiAgICBjb25zdCBlcGljTGFiZWwgPSBpc3N1ZS5lcGljID8gaXNzdWUuZXBpYy50aXRsZSA6IFwiTm8gZXBpY1wiO1xuICAgIGNvbnN0IGVwaWNHcm91cCA9IGJ5RXBpYy5nZXQoZXBpY0tleSkgPz8ge1xuICAgICAgbGFiZWw6IGVwaWNMYWJlbCxcbiAgICAgIHNlY29uZHM6IDAsXG4gICAgICBoaW50czoge1xuICAgICAgICBlcGljVXJsOiBpc3N1ZS5lcGljPy53ZWJVcmwgPz8gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfTtcbiAgICBlcGljR3JvdXAuc2Vjb25kcyArPSBpc3N1ZVNlY29uZHM7XG4gICAgYnlFcGljLnNldChlcGljS2V5LCBlcGljR3JvdXApO1xuXG4gICAgY29uc3Qgc3RhdGVLZXkgPSBpc3N1ZS5zdGF0ZSB8fCBcInVua25vd25cIjtcbiAgICBjb25zdCBzdGF0ZUdyb3VwID0gYnlTdGF0ZS5nZXQoc3RhdGVLZXkpID8/IHtcbiAgICAgIGxhYmVsOiBzdGF0ZUtleSxcbiAgICAgIHNlY29uZHM6IDBcbiAgICB9O1xuICAgIHN0YXRlR3JvdXAuc2Vjb25kcyArPSBpc3N1ZVNlY29uZHM7XG4gICAgYnlTdGF0ZS5zZXQoc3RhdGVLZXksIHN0YXRlR3JvdXApO1xuXG4gICAgZm9yIChjb25zdCBsYWJlbCBvZiBpc3N1ZS5sYWJlbHMpIHtcbiAgICAgIGNvbnN0IGxhYmVsR3JvdXAgPSBieUxhYmVsLmdldChsYWJlbCkgPz8ge1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgc2Vjb25kczogMFxuICAgICAgfTtcbiAgICAgIGxhYmVsR3JvdXAuc2Vjb25kcyArPSBpc3N1ZVNlY29uZHM7XG4gICAgICBieUxhYmVsLnNldChsYWJlbCwgbGFiZWxHcm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3RhbFNlY29uZHMsXG4gICAgYnlVc2VyOiBBcnJheS5mcm9tKGJ5VXNlci52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4gYi5zZWNvbmRzIC0gYS5zZWNvbmRzKSxcbiAgICBieUlzc3VlOiBBcnJheS5mcm9tKGJ5SXNzdWUudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGIuc2Vjb25kcyAtIGEuc2Vjb25kcyksXG4gICAgYnlFcGljOiBBcnJheS5mcm9tKGJ5RXBpYy52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4gYi5zZWNvbmRzIC0gYS5zZWNvbmRzKSxcbiAgICBieUxhYmVsOiBBcnJheS5mcm9tKGJ5TGFiZWwudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGIuc2Vjb25kcyAtIGEuc2Vjb25kcyksXG4gICAgYnlTdGF0ZTogQXJyYXkuZnJvbShieVN0YXRlLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiBiLnNlY29uZHMgLSBhLnNlY29uZHMpLFxuICAgIGJ5RGF0ZTogQXJyYXkuZnJvbShieURhdGUuZW50cmllcygpKVxuICAgICAgLm1hcCgoW2RhdGUsIHNlY29uZHNdKSA9PiAoeyBkYXRlLCBzZWNvbmRzIH0pKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZGF0ZS5sb2NhbGVDb21wYXJlKGIuZGF0ZSkpLFxuICAgIHdlZWtseUJ5VXNlcjogQXJyYXkuZnJvbSh3ZWVrbHlCdWNrZXRzLnZhbHVlcygpKVxuICAgICAgLm1hcCgoYnVja2V0KSA9PiAoe1xuICAgICAgICB3ZWVrU3RhcnQ6IGJ1Y2tldC53ZWVrU3RhcnQsXG4gICAgICAgIGxhYmVsOiBidWNrZXQubGFiZWwsXG4gICAgICAgIHRvdGFsczogQXJyYXkuZnJvbShidWNrZXQudG90YWxzLnZhbHVlcygpKS5zb3J0KFxuICAgICAgICAgIChhLCBiKSA9PiBiLnNlY29uZHMgLSBhLnNlY29uZHNcbiAgICAgICAgKSxcbiAgICAgICAgdG90YWxTZWNvbmRzOiBidWNrZXQudG90YWxTZWNvbmRzXG4gICAgICB9KSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLndlZWtTdGFydC5sb2NhbGVDb21wYXJlKGIud2Vla1N0YXJ0KSlcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlY29uZHNUb0hvdXJzKHNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLnJvdW5kKChzZWNvbmRzIC8gMzYwMCkgKiAxMDApIC8gMTAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RHVyYXRpb24oc2Vjb25kczogbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKHNlY29uZHMgLyAzNjAwKTtcbiAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IoKHNlY29uZHMgJSAzNjAwKSAvIDYwKTtcbiAgaWYgKGhvdXJzID09PSAwICYmIG1pbnV0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gXCI8MW1cIjtcbiAgfVxuICBpZiAoaG91cnMgPT09IDApIHtcbiAgICByZXR1cm4gYCR7bWludXRlc31tYDtcbiAgfVxuICBpZiAobWludXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBgJHtob3Vyc31oYDtcbiAgfVxuICByZXR1cm4gYCR7aG91cnN9aCAke21pbnV0ZXN9bWA7XG59XG5cbmZ1bmN0aW9uIGdldFdlZWtCdWNrZXQoc3BlbnRBdDogc3RyaW5nKTogeyBrZXk6IHN0cmluZzsgc3RhcnQ6IHN0cmluZzsgbGFiZWw6IHN0cmluZyB9IHwgbnVsbCB7XG4gIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUucGFyc2Uoc3BlbnRBdCk7XG4gIGlmIChOdW1iZXIuaXNOYU4odGltZXN0YW1wKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHdlZWtTdGFydERhdGUgPSBzdGFydE9mV2VlayhuZXcgRGF0ZSh0aW1lc3RhbXApKTtcbiAgY29uc3Qgc3RhcnQgPSBpc29EYXRlT25seSh3ZWVrU3RhcnREYXRlKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IHN0YXJ0LFxuICAgIHN0YXJ0LFxuICAgIGxhYmVsOiBmb3JtYXRXZWVrTGFiZWwod2Vla1N0YXJ0RGF0ZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RhcnRPZldlZWsoZGF0ZTogRGF0ZSk6IERhdGUge1xuICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKERhdGUuVVRDKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgZGF0ZS5nZXRVVENNb250aCgpLCBkYXRlLmdldFVUQ0RhdGUoKSkpO1xuICBjb25zdCBkYXkgPSBzdGFydC5nZXRVVENEYXkoKTtcbiAgY29uc3QgZGlmZiA9IGRheSA9PT0gMCA/IC02IDogMSAtIGRheTtcbiAgc3RhcnQuc2V0VVRDRGF0ZShzdGFydC5nZXRVVENEYXRlKCkgKyBkaWZmKTtcbiAgcmV0dXJuIHN0YXJ0O1xufVxuXG5mdW5jdGlvbiBpc29EYXRlT25seShkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtMYWJlbChkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodW5kZWZpbmVkLCB7XG4gICAgbW9udGg6IFwic2hvcnRcIixcbiAgICBkYXk6IFwibnVtZXJpY1wiXG4gIH0pO1xuICByZXR1cm4gYFdlZWsgb2YgJHtmb3JtYXR0ZXIuZm9ybWF0KGRhdGUpfWA7XG59XG5cbmludGVyZmFjZSBSZXN0Q29tbWl0IHtcbiAgY29tbWl0dGVkX2RhdGU6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlc3RFbmRwb2ludChncmFwaHFsVXJsPzogc3RyaW5nKSB7XG4gIGlmICghZ3JhcGhxbFVybCkge1xuICAgIHJldHVybiBERUZBVUxUX1JFU1RfRU5EUE9JTlQ7XG4gIH1cbiAgaWYgKGdyYXBocWxVcmwuZW5kc1dpdGgoXCIvYXBpL2dyYXBocWxcIikpIHtcbiAgICByZXR1cm4gZ3JhcGhxbFVybC5yZXBsYWNlKFwiL2FwaS9ncmFwaHFsXCIsIFwiL2FwaS92NFwiKTtcbiAgfVxuICByZXR1cm4gREVGQVVMVF9SRVNUX0VORFBPSU5UO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb21taXRBY3Rpdml0eUJ5RGF5KFxuICBwcm9qZWN0RnVsbFBhdGg6IHN0cmluZyxcbiAgY3JlZGVudGlhbHM6IEdpdExhYkNyZWRlbnRpYWxzLFxuICBtb250aDogc3RyaW5nXG4pOiBQcm9taXNlPHsgZGF5czogQ29tbWl0QWN0aXZpdHlEYXlbXTsgcmFuZ2U6IENvbW1pdFJhbmdlIH0+IHtcbiAgaWYgKCFwcm9qZWN0RnVsbFBhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIEdpdExhYiBwcm9qZWN0IGZ1bGwgcGF0aC5cIik7XG4gIH1cbiAgaWYgKCFjcmVkZW50aWFscy50b2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgR2l0TGFiIGFjY2VzcyB0b2tlbi5cIik7XG4gIH1cbiAgaWYgKCFtb250aCB8fCAhL15cXGR7NH0tXFxkezJ9JC8udGVzdChtb250aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCAnY29tbWl0TW9udGgnIG11c3QgdXNlIFlZWVktTU0gZm9ybWF0LlwiKTtcbiAgfVxuXG4gIGNvbnN0IFt5ZWFyU3RyLCBtb250aFN0cl0gPSBtb250aC5zcGxpdChcIi1cIik7XG4gIGNvbnN0IHllYXIgPSBOdW1iZXIoeWVhclN0cik7XG4gIGNvbnN0IG1vbnRoSW5kZXggPSBOdW1iZXIobW9udGhTdHIpIC0gMTtcbiAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGhJbmRleCwgMSkpO1xuICBjb25zdCBlbmREYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGhJbmRleCArIDEsIDEpKTtcblxuICBjb25zdCBzaW5jZSA9IHN0YXJ0RGF0ZS50b0lTT1N0cmluZygpO1xuICBjb25zdCB1bnRpbCA9IGVuZERhdGUudG9JU09TdHJpbmcoKTtcblxuICBjb25zdCByZXN0QmFzZSA9IHJlc29sdmVSZXN0RW5kcG9pbnQoY3JlZGVudGlhbHMuYXBpVXJsKTtcbiAgY29uc3QgZW5jb2RlZFByb2plY3QgPSBlbmNvZGVVUklDb21wb25lbnQocHJvamVjdEZ1bGxQYXRoKTtcbiAgY29uc3QgcGVyUGFnZSA9IDEwMDtcbiAgbGV0IHBhZ2UgPSAxO1xuICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjcmVkZW50aWFscy50b2tlbn1gXG4gIH07XG5cbiAgY29uc3QgY291bnRzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHVybCA9IGAke3Jlc3RCYXNlfS9wcm9qZWN0cy8ke2VuY29kZWRQcm9qZWN0fS9yZXBvc2l0b3J5L2NvbW1pdHM/c2luY2U9JHtlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICBzaW5jZVxuICAgICl9JnVudGlsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHVudGlsKX0mcGVyX3BhZ2U9JHtwZXJQYWdlfSZwYWdlPSR7cGFnZX0md2l0aF9zdGF0cz1mYWxzZWA7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIGhlYWRlcnNcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBmZXRjaCBjb21taXQgYWN0aXZpdHkgKCR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9KS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHBheWxvYWQgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKSBhcyBSZXN0Q29tbWl0W107XG4gICAgZm9yIChjb25zdCBjb21taXQgb2YgcGF5bG9hZCkge1xuICAgICAgaWYgKCFjb21taXQ/LmNvbW1pdHRlZF9kYXRlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF5S2V5ID0gY29tbWl0LmNvbW1pdHRlZF9kYXRlLnNsaWNlKDAsIDEwKTtcbiAgICAgIGNvdW50cy5zZXQoZGF5S2V5LCAoY291bnRzLmdldChkYXlLZXkpID8/IDApICsgMSk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dFBhZ2UgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dC1wYWdlXCIpO1xuICAgIGlmICghbmV4dFBhZ2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSBOdW1iZXIobmV4dFBhZ2UpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHBhcnNlZCkgfHwgcGFyc2VkIDw9IHBhZ2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYWdlID0gcGFyc2VkO1xuICB9XG5cbiAgY29uc3QgZGF5czogQ29tbWl0QWN0aXZpdHlEYXlbXSA9IFtdO1xuICBmb3IgKFxuICAgIGxldCBjdXJzb3IgPSBuZXcgRGF0ZShzdGFydERhdGUpO1xuICAgIGN1cnNvciA8IGVuZERhdGU7XG4gICAgY3Vyc29yLnNldFVUQ0RhdGUoY3Vyc29yLmdldFVUQ0RhdGUoKSArIDEpXG4gICkge1xuICAgIGNvbnN0IGtleSA9IGlzb0RhdGVPbmx5KGN1cnNvcik7XG4gICAgZGF5cy5wdXNoKHtcbiAgICAgIGRhdGU6IGtleSxcbiAgICAgIGNvdW50OiBjb3VudHMuZ2V0KGtleSkgPz8gMFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkYXlzLFxuICAgIHJhbmdlOiB7XG4gICAgICBtb250aCxcbiAgICAgIGZyb206IHNpbmNlLFxuICAgICAgdG86IHVudGlsXG4gICAgfVxuICB9O1xufVxuIl0sIm5hbWVzIjpbIkRFRkFVTFRfR1JBUEhRTF9FTkRQT0lOVCIsIkRFRkFVTFRfSVNTVUVfUEFHRV9TSVpFIiwiREVGQVVMVF9USU1FTE9HX1BBR0VfU0laRSIsIkRFRkFVTFRfUkVTVF9FTkRQT0lOVCIsIklTU1VFX1RJTUVMT0dTX1FVRVJZIiwiZmV0Y2hQcm9qZWN0VGltZVJlcG9ydCIsInByb2plY3RGdWxsUGF0aCIsImNyZWRlbnRpYWxzIiwicmFuZ2UiLCJpc3N1ZVBhZ2VTaXplIiwidGltZWxvZ1BhZ2VTaXplIiwiYXBpVXJsIiwidHJpbSIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwidG9rZW4iLCJFcnJvciIsImlzc3VlcyIsInBhZ2VJbmZvIiwicHJvamVjdE1ldGEiLCJwYXlsb2FkIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicXVlcnkiLCJ2YXJpYWJsZXMiLCJmdWxsUGF0aCIsImlzc3Vlc0ZpcnN0IiwiaXNzdWVzQWZ0ZXIiLCJlbmRDdXJzb3IiLCJ0aW1lbG9nRmlyc3QiLCJvayIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwianNvbiIsImVycm9ycyIsImxlbmd0aCIsIm1hcCIsImVyciIsImpvaW4iLCJkYXRhIiwicHJvamVjdCIsImlkIiwibmFtZSIsIndlYlVybCIsImN1cnJlbnRJc3N1ZXMiLCJub2RlcyIsIm5vZGUiLCJ0cmFuc2Zvcm1Jc3N1ZU5vZGUiLCJwdXNoIiwiaGFzTmV4dFBhZ2UiLCJzdW1tYXJ5IiwiYnVpbGRUaW1lU3VtbWFyeSIsImdlbmVyYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY29tbWl0QWN0aXZpdHkiLCJjb21taXRSYW5nZSIsInRpbWVsb2dzIiwiZmlsdGVyIiwibG9nIiwidGltZVNwZW50IiwiaXNXaXRoaW5SYW5nZSIsInNwZW50QXQiLCJzZWNvbmRzIiwidXNlciIsInVzZXJuYW1lIiwiaWlkIiwidGl0bGUiLCJzdGF0ZSIsImxhYmVscyIsImxhYmVsIiwiZXBpYyIsImZyb20iLCJ0byIsInRpbWVzdGFtcCIsInBhcnNlIiwiTnVtYmVyIiwiaXNOYU4iLCJmcm9tVHMiLCJ0b1RzIiwidG90YWxTZWNvbmRzIiwiYnlVc2VyIiwiTWFwIiwiYnlJc3N1ZSIsImJ5RXBpYyIsImJ5RGF0ZSIsImJ5TGFiZWwiLCJieVN0YXRlIiwid2Vla2x5QnVja2V0cyIsImlzc3VlIiwiaXNzdWVTZWNvbmRzIiwidGltZWxvZyIsImRhdGVLZXkiLCJzbGljZSIsInNldCIsImdldCIsInVzZXJLZXkiLCJ1c2VyR3JvdXAiLCJoaW50cyIsIndlZWtCdWNrZXQiLCJnZXRXZWVrQnVja2V0IiwiYWdncmVnYXRlIiwia2V5Iiwid2Vla1N0YXJ0Iiwic3RhcnQiLCJ0b3RhbHMiLCJ1c2VyVG90YWxzIiwidXNlcklkIiwidXNlck5hbWUiLCJpc3N1ZUdyb3VwIiwiaXNzdWVVcmwiLCJlcGljS2V5IiwiZXBpY0xhYmVsIiwiZXBpY0dyb3VwIiwiZXBpY1VybCIsInVuZGVmaW5lZCIsInN0YXRlS2V5Iiwic3RhdGVHcm91cCIsImxhYmVsR3JvdXAiLCJBcnJheSIsInZhbHVlcyIsInNvcnQiLCJhIiwiYiIsImVudHJpZXMiLCJkYXRlIiwibG9jYWxlQ29tcGFyZSIsIndlZWtseUJ5VXNlciIsImJ1Y2tldCIsInNlY29uZHNUb0hvdXJzIiwiTWF0aCIsInJvdW5kIiwiZm9ybWF0RHVyYXRpb24iLCJob3VycyIsImZsb29yIiwibWludXRlcyIsIndlZWtTdGFydERhdGUiLCJzdGFydE9mV2VlayIsImlzb0RhdGVPbmx5IiwiZm9ybWF0V2Vla0xhYmVsIiwiVVRDIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJkYXkiLCJnZXRVVENEYXkiLCJkaWZmIiwic2V0VVRDRGF0ZSIsImZvcm1hdHRlciIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsIm1vbnRoIiwiZm9ybWF0IiwicmVzb2x2ZVJlc3RFbmRwb2ludCIsImdyYXBocWxVcmwiLCJlbmRzV2l0aCIsInJlcGxhY2UiLCJmZXRjaENvbW1pdEFjdGl2aXR5QnlEYXkiLCJ0ZXN0IiwieWVhclN0ciIsIm1vbnRoU3RyIiwic3BsaXQiLCJ5ZWFyIiwibW9udGhJbmRleCIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJzaW5jZSIsInVudGlsIiwicmVzdEJhc2UiLCJlbmNvZGVkUHJvamVjdCIsImVuY29kZVVSSUNvbXBvbmVudCIsInBlclBhZ2UiLCJwYWdlIiwiY291bnRzIiwidXJsIiwiY29tbWl0IiwiY29tbWl0dGVkX2RhdGUiLCJkYXlLZXkiLCJuZXh0UGFnZSIsInBhcnNlZCIsImlzRmluaXRlIiwiZGF5cyIsImN1cnNvciIsImNvdW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/gitlab.ts\n"));

/***/ })

});