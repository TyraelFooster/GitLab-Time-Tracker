"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/gitlab.ts":
/*!***************************!*\
  !*** ./app/lib/gitlab.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchProjectTimeReport: function() { return /* binding */ fetchProjectTimeReport; },\n/* harmony export */   formatDuration: function() { return /* binding */ formatDuration; },\n/* harmony export */   secondsToHours: function() { return /* binding */ secondsToHours; }\n/* harmony export */ });\nconst DEFAULT_GRAPHQL_ENDPOINT = \"https://gitlab.com/api/graphql\";\nconst DEFAULT_ISSUE_PAGE_SIZE = 20;\nconst DEFAULT_TIMELOG_PAGE_SIZE = 100;\nconst DEFAULT_REST_ENDPOINT = \"https://gitlab.com/api/v4\";\nconst ISSUE_TIMELOGS_QUERY = \"\\n  query ProjectIssueTimelogs(\\n    $fullPath: ID!,\\n    $issuesFirst: Int!,\\n    $issuesAfter: String,\\n    $timelogFirst: Int!\\n  ) {\\n    project(fullPath: $fullPath) {\\n      id\\n      name\\n      webUrl\\n      issues(first: $issuesFirst, after: $issuesAfter, sort: UPDATED_DESC) {\\n        nodes {\\n          id\\n          iid\\n          title\\n          webUrl\\n          state\\n          labels(first: 10) {\\n            nodes {\\n              title\\n            }\\n          }\\n          epic {\\n            id\\n            iid\\n            title\\n            webUrl\\n          }\\n          timelogs(first: $timelogFirst) {\\n            nodes {\\n              id\\n              spentAt\\n              timeSpent\\n              summary\\n              user {\\n                id\\n                name\\n                username\\n              }\\n            }\\n          }\\n        }\\n        pageInfo {\\n          hasNextPage\\n          endCursor\\n        }\\n      }\\n    }\\n  }\\n\";\nasync function fetchProjectTimeReport(projectFullPath, credentials, range) {\n    let issuePageSize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : DEFAULT_ISSUE_PAGE_SIZE, timelogPageSize = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : DEFAULT_TIMELOG_PAGE_SIZE;\n    var _credentials_apiUrl;\n    const apiUrl = ((_credentials_apiUrl = credentials.apiUrl) === null || _credentials_apiUrl === void 0 ? void 0 : _credentials_apiUrl.trim()) || DEFAULT_GRAPHQL_ENDPOINT;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(credentials.token)\n    };\n    if (!projectFullPath) {\n        throw new Error(\"Missing GitLab project full path.\");\n    }\n    if (!credentials.token) {\n        throw new Error(\"Missing GitLab access token.\");\n    }\n    const issues = [];\n    let pageInfo = null;\n    let projectMeta = null;\n    do {\n        var _payload_errors, _payload_data;\n        var _pageInfo_endCursor;\n        const response = await fetch(apiUrl, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({\n                query: ISSUE_TIMELOGS_QUERY,\n                variables: {\n                    fullPath: projectFullPath,\n                    issuesFirst: issuePageSize,\n                    issuesAfter: (_pageInfo_endCursor = pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.endCursor) !== null && _pageInfo_endCursor !== void 0 ? _pageInfo_endCursor : null,\n                    timelogFirst: timelogPageSize\n                }\n            })\n        });\n        if (!response.ok) {\n            const message = \"GitLab GraphQL responded with \".concat(response.status, \" \").concat(response.statusText);\n            throw new Error(message);\n        }\n        const payload = await response.json();\n        if ((_payload_errors = payload.errors) === null || _payload_errors === void 0 ? void 0 : _payload_errors.length) {\n            throw new Error(payload.errors.map((err)=>err.message).join(\"; \"));\n        }\n        if (!((_payload_data = payload.data) === null || _payload_data === void 0 ? void 0 : _payload_data.project)) {\n            throw new Error(\"Project not found or access denied.\");\n        }\n        projectMeta = {\n            id: payload.data.project.id,\n            name: payload.data.project.name,\n            webUrl: payload.data.project.webUrl\n        };\n        const currentIssues = payload.data.project.issues.nodes.map((node)=>transformIssueNode(node, range));\n        issues.push(...currentIssues);\n        pageInfo = payload.data.project.issues.pageInfo;\n    }while (pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.hasNextPage);\n    const summary = buildTimeSummary(issues);\n    return {\n        project: projectMeta !== null && projectMeta !== void 0 ? projectMeta : {\n            id: \"unknown\",\n            name: projectFullPath,\n            webUrl: \"\"\n        },\n        issues,\n        summary,\n        range,\n        generatedAt: new Date().toISOString(),\n        commitActivity: [],\n        commitRange: null\n    };\n}\nfunction transformIssueNode(node, range) {\n    var _node_timelogs, _node_labels_nodes, _node_labels;\n    var _node_timelogs_nodes;\n    const timelogs = ((_node_timelogs_nodes = (_node_timelogs = node.timelogs) === null || _node_timelogs === void 0 ? void 0 : _node_timelogs.nodes) !== null && _node_timelogs_nodes !== void 0 ? _node_timelogs_nodes : []).filter((log)=>{\n        if (!log || log.timeSpent <= 0) {\n            return false;\n        }\n        return isWithinRange(log.spentAt, range);\n    }).map((log)=>{\n        var _log_user, _log_user1, _log_user2;\n        var _log_user_id, _log_user_name, _log_user_username;\n        return {\n            id: log.id,\n            spentAt: log.spentAt,\n            seconds: log.timeSpent,\n            summary: log.summary,\n            user: {\n                id: (_log_user_id = (_log_user = log.user) === null || _log_user === void 0 ? void 0 : _log_user.id) !== null && _log_user_id !== void 0 ? _log_user_id : \"unknown\",\n                name: (_log_user_name = (_log_user1 = log.user) === null || _log_user1 === void 0 ? void 0 : _log_user1.name) !== null && _log_user_name !== void 0 ? _log_user_name : \"Unknown\",\n                username: (_log_user_username = (_log_user2 = log.user) === null || _log_user2 === void 0 ? void 0 : _log_user2.username) !== null && _log_user_username !== void 0 ? _log_user_username : \"unknown\"\n            }\n        };\n    });\n    var _node_labels_nodes_map;\n    return {\n        id: node.id,\n        iid: node.iid,\n        title: node.title,\n        webUrl: node.webUrl,\n        state: node.state,\n        labels: (_node_labels_nodes_map = (_node_labels = node.labels) === null || _node_labels === void 0 ? void 0 : (_node_labels_nodes = _node_labels.nodes) === null || _node_labels_nodes === void 0 ? void 0 : _node_labels_nodes.map((label)=>label.title)) !== null && _node_labels_nodes_map !== void 0 ? _node_labels_nodes_map : [],\n        epic: node.epic ? {\n            id: node.epic.id,\n            iid: node.epic.iid,\n            title: node.epic.title,\n            webUrl: node.epic.webUrl\n        } : null,\n        timelogs\n    };\n}\nfunction isWithinRange(spentAt, range) {\n    if (!range.from && !range.to) {\n        return true;\n    }\n    const timestamp = Date.parse(spentAt);\n    if (Number.isNaN(timestamp)) {\n        return true;\n    }\n    if (range.from) {\n        const fromTs = Date.parse(range.from);\n        if (!Number.isNaN(fromTs) && timestamp < fromTs) {\n            return false;\n        }\n    }\n    if (range.to) {\n        const toTs = Date.parse(range.to);\n        if (!Number.isNaN(toTs) && timestamp >= toTs) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction buildTimeSummary(issues) {\n    let totalSeconds = 0;\n    const byUser = new Map();\n    const byIssue = new Map();\n    const byEpic = new Map();\n    const byDate = new Map();\n    const byLabel = new Map();\n    const byState = new Map();\n    const weeklyBuckets = new Map();\n    for (const issue of issues){\n        var _issue_epic, _issue_epic1;\n        let issueSeconds = 0;\n        for (const timelog of issue.timelogs){\n            totalSeconds += timelog.seconds;\n            issueSeconds += timelog.seconds;\n            const dateKey = timelog.spentAt ? timelog.spentAt.slice(0, 10) : \"unknown\";\n            var _byDate_get;\n            byDate.set(dateKey, ((_byDate_get = byDate.get(dateKey)) !== null && _byDate_get !== void 0 ? _byDate_get : 0) + timelog.seconds);\n            const userKey = timelog.user.username || timelog.user.id;\n            var _byUser_get;\n            const userGroup = (_byUser_get = byUser.get(userKey)) !== null && _byUser_get !== void 0 ? _byUser_get : {\n                label: timelog.user.name,\n                seconds: 0,\n                hints: {\n                    username: timelog.user.username\n                }\n            };\n            userGroup.seconds += timelog.seconds;\n            byUser.set(userKey, userGroup);\n            const weekBucket = getWeekBucket(timelog.spentAt);\n            if (weekBucket) {\n                var _weeklyBuckets_get;\n                const aggregate = (_weeklyBuckets_get = weeklyBuckets.get(weekBucket.key)) !== null && _weeklyBuckets_get !== void 0 ? _weeklyBuckets_get : {\n                    weekStart: weekBucket.start,\n                    label: weekBucket.label,\n                    totals: new Map(),\n                    totalSeconds: 0\n                };\n                var _aggregate_totals_get;\n                const userTotals = (_aggregate_totals_get = aggregate.totals.get(userKey)) !== null && _aggregate_totals_get !== void 0 ? _aggregate_totals_get : {\n                    userId: timelog.user.id,\n                    userName: timelog.user.name,\n                    username: timelog.user.username,\n                    seconds: 0\n                };\n                userTotals.seconds += timelog.seconds;\n                aggregate.totals.set(userKey, userTotals);\n                aggregate.totalSeconds += timelog.seconds;\n                weeklyBuckets.set(weekBucket.key, aggregate);\n            }\n        }\n        var _byIssue_get;\n        const issueGroup = (_byIssue_get = byIssue.get(issue.id)) !== null && _byIssue_get !== void 0 ? _byIssue_get : {\n            label: \"#\".concat(issue.iid, \" \").concat(issue.title),\n            seconds: 0,\n            hints: {\n                issueUrl: issue.webUrl,\n                state: issue.state\n            }\n        };\n        issueGroup.seconds += issueSeconds;\n        byIssue.set(issue.id, issueGroup);\n        var _issue_epic_id;\n        const epicKey = (_issue_epic_id = (_issue_epic = issue.epic) === null || _issue_epic === void 0 ? void 0 : _issue_epic.id) !== null && _issue_epic_id !== void 0 ? _issue_epic_id : \"unassigned\";\n        const epicLabel = issue.epic ? issue.epic.title : \"No epic\";\n        var _issue_epic_webUrl, _byEpic_get;\n        const epicGroup = (_byEpic_get = byEpic.get(epicKey)) !== null && _byEpic_get !== void 0 ? _byEpic_get : {\n            label: epicLabel,\n            seconds: 0,\n            hints: {\n                epicUrl: (_issue_epic_webUrl = (_issue_epic1 = issue.epic) === null || _issue_epic1 === void 0 ? void 0 : _issue_epic1.webUrl) !== null && _issue_epic_webUrl !== void 0 ? _issue_epic_webUrl : undefined\n            }\n        };\n        epicGroup.seconds += issueSeconds;\n        byEpic.set(epicKey, epicGroup);\n        const stateKey = issue.state || \"unknown\";\n        var _byState_get;\n        const stateGroup = (_byState_get = byState.get(stateKey)) !== null && _byState_get !== void 0 ? _byState_get : {\n            label: stateKey,\n            seconds: 0\n        };\n        stateGroup.seconds += issueSeconds;\n        byState.set(stateKey, stateGroup);\n        for (const label of issue.labels){\n            var _byLabel_get;\n            const labelGroup = (_byLabel_get = byLabel.get(label)) !== null && _byLabel_get !== void 0 ? _byLabel_get : {\n                label,\n                seconds: 0\n            };\n            labelGroup.seconds += issueSeconds;\n            byLabel.set(label, labelGroup);\n        }\n    }\n    return {\n        totalSeconds,\n        byUser: Array.from(byUser.values()).sort((a, b)=>b.seconds - a.seconds),\n        byIssue: Array.from(byIssue.values()).sort((a, b)=>b.seconds - a.seconds),\n        byEpic: Array.from(byEpic.values()).sort((a, b)=>b.seconds - a.seconds),\n        byLabel: Array.from(byLabel.values()).sort((a, b)=>b.seconds - a.seconds),\n        byState: Array.from(byState.values()).sort((a, b)=>b.seconds - a.seconds),\n        byDate: Array.from(byDate.entries()).map((param)=>{\n            let [date, seconds] = param;\n            return {\n                date,\n                seconds\n            };\n        }).sort((a, b)=>a.date.localeCompare(b.date)),\n        weeklyByUser: Array.from(weeklyBuckets.values()).map((bucket)=>({\n                weekStart: bucket.weekStart,\n                label: bucket.label,\n                totals: Array.from(bucket.totals.values()).sort((a, b)=>b.seconds - a.seconds),\n                totalSeconds: bucket.totalSeconds\n            })).sort((a, b)=>a.weekStart.localeCompare(b.weekStart))\n    };\n}\nfunction secondsToHours(seconds) {\n    return Math.round(seconds / 3600 * 100) / 100;\n}\nfunction formatDuration(seconds) {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor(seconds % 3600 / 60);\n    if (hours === 0 && minutes === 0) {\n        return \"<1m\";\n    }\n    if (hours === 0) {\n        return \"\".concat(minutes, \"m\");\n    }\n    if (minutes === 0) {\n        return \"\".concat(hours, \"h\");\n    }\n    return \"\".concat(hours, \"h \").concat(minutes, \"m\");\n}\nfunction getWeekBucket(spentAt) {\n    const timestamp = Date.parse(spentAt);\n    if (Number.isNaN(timestamp)) {\n        return null;\n    }\n    const weekStartDate = startOfWeek(new Date(timestamp));\n    const start = isoDateOnly(weekStartDate);\n    return {\n        key: start,\n        start,\n        label: formatWeekLabel(weekStartDate)\n    };\n}\nfunction startOfWeek(date) {\n    const start = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));\n    const day = start.getUTCDay();\n    const diff = day === 0 ? -6 : 1 - day;\n    start.setUTCDate(start.getUTCDate() + diff);\n    return start;\n}\nfunction isoDateOnly(date) {\n    return date.toISOString().slice(0, 10);\n}\nfunction formatWeekLabel(date) {\n    const formatter = new Intl.DateTimeFormat(undefined, {\n        month: \"short\",\n        day: \"numeric\"\n    });\n    return \"Week of \".concat(formatter.format(date));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxLQUFLRTtRQUNMQTtRQUNBbEMsT0FBT3FFLGdCQUFnQkg7SUFDekI7QUFDRjtBQUVBLFNBQVNDLFlBQVlaLElBQVU7SUFDN0IsTUFBTXJCLFFBQVEsSUFBSW5ELEtBQUtBLEtBQUt1RixHQUFHLENBQUNmLEtBQUtnQixjQUFjLElBQUloQixLQUFLaUIsV0FBVyxJQUFJakIsS0FBS2tCLFVBQVU7SUFDMUYsTUFBTUMsTUFBTXhDLE1BQU15QyxTQUFTO0lBQzNCLE1BQU1DLE9BQU9GLFFBQVEsSUFBSSxDQUFDLElBQUksSUFBSUE7SUFDbEN4QyxNQUFNMkMsVUFBVSxDQUFDM0MsTUFBTXVDLFVBQVUsS0FBS0c7SUFDdEMsT0FBTzFDO0FBQ1Q7QUFFQSxTQUFTa0MsWUFBWWIsSUFBVTtJQUM3QixPQUFPQSxLQUFLdkUsV0FBVyxHQUFHdUMsS0FBSyxDQUFDLEdBQUc7QUFDckM7QUFFQSxTQUFTOEMsZ0JBQWdCZCxJQUFVO0lBQ2pDLE1BQU11QixZQUFZLElBQUlDLEtBQUtDLGNBQWMsQ0FBQ25DLFdBQVc7UUFDbkRvQyxPQUFPO1FBQ1BQLEtBQUs7SUFDUDtJQUNBLE9BQU8sV0FBa0MsT0FBdkJJLFVBQVVJLE1BQU0sQ0FBQzNCO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvZ2l0bGFiLnRzPzk5ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgREVGQVVMVF9HUkFQSFFMX0VORFBPSU5UID0gXCJodHRwczovL2dpdGxhYi5jb20vYXBpL2dyYXBocWxcIjtcbmNvbnN0IERFRkFVTFRfSVNTVUVfUEFHRV9TSVpFID0gMjA7XG5jb25zdCBERUZBVUxUX1RJTUVMT0dfUEFHRV9TSVpFID0gMTAwO1xuY29uc3QgREVGQVVMVF9SRVNUX0VORFBPSU5UID0gXCJodHRwczovL2dpdGxhYi5jb20vYXBpL3Y0XCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2l0TGFiQ3JlZGVudGlhbHMge1xuICBhcGlVcmw/OiBzdHJpbmc7XG4gIHRva2VuOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGltZVJhbmdlRmlsdGVyIHtcbiAgZnJvbT86IHN0cmluZztcbiAgdG8/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2Vla2x5VXNlclRvdGFsIHtcbiAgdXNlcklkOiBzdHJpbmc7XG4gIHVzZXJOYW1lOiBzdHJpbmc7XG4gIHVzZXJuYW1lOiBzdHJpbmc7XG4gIHNlY29uZHM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXZWVrbHlVc2VyU3VtbWFyeSB7XG4gIHdlZWtTdGFydDogc3RyaW5nO1xuICBsYWJlbDogc3RyaW5nO1xuICB0b3RhbHM6IFdlZWtseVVzZXJUb3RhbFtdO1xuICB0b3RhbFNlY29uZHM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21taXRBY3Rpdml0eURheSB7XG4gIGRhdGU6IHN0cmluZztcbiAgY291bnQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21taXRSYW5nZSB7XG4gIG1vbnRoOiBzdHJpbmc7XG4gIGZyb206IHN0cmluZztcbiAgdG86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHaXRMYWJJc3N1ZVRpbWVsb2cge1xuICBpZDogc3RyaW5nO1xuICBzcGVudEF0OiBzdHJpbmc7XG4gIHNlY29uZHM6IG51bWJlcjtcbiAgdXNlcjoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gIH07XG4gIHN1bW1hcnk/OiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdpdExhYklzc3VlVGltZSB7XG4gIGlkOiBzdHJpbmc7XG4gIGlpZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICB3ZWJVcmw6IHN0cmluZztcbiAgc3RhdGU6IHN0cmluZztcbiAgbGFiZWxzOiBzdHJpbmdbXTtcbiAgZXBpYz86IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGlpZD86IHN0cmluZyB8IG51bGw7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICB3ZWJVcmw/OiBzdHJpbmcgfCBudWxsO1xuICB9IHwgbnVsbDtcbiAgdGltZWxvZ3M6IEdpdExhYklzc3VlVGltZWxvZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2plY3RUaW1lUmVwb3J0IHtcbiAgcHJvamVjdDoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHdlYlVybDogc3RyaW5nO1xuICB9O1xuICBpc3N1ZXM6IEdpdExhYklzc3VlVGltZVtdO1xuICBzdW1tYXJ5OiBUaW1lU3VtbWFyeTtcbiAgcmFuZ2U6IFRpbWVSYW5nZUZpbHRlcjtcbiAgZ2VuZXJhdGVkQXQ6IHN0cmluZztcbiAgY29tbWl0QWN0aXZpdHk/OiBDb21taXRBY3Rpdml0eURheVtdO1xuICBjb21taXRSYW5nZT86IENvbW1pdFJhbmdlIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaW1lU3VtbWFyeUdyb3VwIHtcbiAgbGFiZWw6IHN0cmluZztcbiAgc2Vjb25kczogbnVtYmVyO1xuICBoaW50cz86IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGltZVN1bW1hcnkge1xuICB0b3RhbFNlY29uZHM6IG51bWJlcjtcbiAgYnlVc2VyOiBUaW1lU3VtbWFyeUdyb3VwW107XG4gIGJ5SXNzdWU6IFRpbWVTdW1tYXJ5R3JvdXBbXTtcbiAgYnlFcGljOiBUaW1lU3VtbWFyeUdyb3VwW107XG4gIGJ5TGFiZWw6IFRpbWVTdW1tYXJ5R3JvdXBbXTtcbiAgYnlTdGF0ZTogVGltZVN1bW1hcnlHcm91cFtdO1xuICBieURhdGU6IHsgZGF0ZTogc3RyaW5nOyBzZWNvbmRzOiBudW1iZXIgfVtdO1xuICB3ZWVrbHlCeVVzZXI6IFdlZWtseVVzZXJTdW1tYXJ5W107XG59XG5cbmludGVyZmFjZSBHcmFwaFFMSXNzdWVOb2RlIHtcbiAgaWQ6IHN0cmluZztcbiAgaWlkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHdlYlVybDogc3RyaW5nO1xuICBzdGF0ZTogc3RyaW5nO1xuICBsYWJlbHM6IHsgbm9kZXM6IEFycmF5PHsgdGl0bGU6IHN0cmluZyB9PiB9O1xuICBlcGljPzoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgaWlkOiBzdHJpbmcgfCBudWxsO1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgd2ViVXJsOiBzdHJpbmcgfCBudWxsO1xuICB9IHwgbnVsbDtcbiAgdGltZWxvZ3M6IHtcbiAgICBub2RlczogQXJyYXk8e1xuICAgICAgaWQ6IHN0cmluZztcbiAgICAgIHNwZW50QXQ6IHN0cmluZztcbiAgICAgIHRpbWVTcGVudDogbnVtYmVyO1xuICAgICAgc3VtbWFyeTogc3RyaW5nIHwgbnVsbDtcbiAgICAgIHVzZXI/OiB7XG4gICAgICAgIGlkOiBzdHJpbmc7XG4gICAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgICAgdXNlcm5hbWU6IHN0cmluZztcbiAgICAgIH0gfCBudWxsO1xuICAgIH0+O1xuICB9O1xufVxuXG5pbnRlcmZhY2UgR3JhcGhRTFJlc3BvbnNlPFQ+IHtcbiAgZGF0YT86IFQ7XG4gIGVycm9ycz86IEFycmF5PHsgbWVzc2FnZTogc3RyaW5nIH0+O1xufVxuXG5pbnRlcmZhY2UgSXNzdWVQYWdlUGF5bG9hZCB7XG4gIHByb2plY3Q6IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB3ZWJVcmw6IHN0cmluZztcbiAgICBpc3N1ZXM6IHtcbiAgICAgIG5vZGVzOiBHcmFwaFFMSXNzdWVOb2RlW107XG4gICAgICBwYWdlSW5mbzoge1xuICAgICAgICBoYXNOZXh0UGFnZTogYm9vbGVhbjtcbiAgICAgICAgZW5kQ3Vyc29yOiBzdHJpbmcgfCBudWxsO1xuICAgICAgfTtcbiAgICB9O1xuICB9IHwgbnVsbDtcbn1cblxuY29uc3QgSVNTVUVfVElNRUxPR1NfUVVFUlkgPSBgXG4gIHF1ZXJ5IFByb2plY3RJc3N1ZVRpbWVsb2dzKFxuICAgICRmdWxsUGF0aDogSUQhLFxuICAgICRpc3N1ZXNGaXJzdDogSW50ISxcbiAgICAkaXNzdWVzQWZ0ZXI6IFN0cmluZyxcbiAgICAkdGltZWxvZ0ZpcnN0OiBJbnQhXG4gICkge1xuICAgIHByb2plY3QoZnVsbFBhdGg6ICRmdWxsUGF0aCkge1xuICAgICAgaWRcbiAgICAgIG5hbWVcbiAgICAgIHdlYlVybFxuICAgICAgaXNzdWVzKGZpcnN0OiAkaXNzdWVzRmlyc3QsIGFmdGVyOiAkaXNzdWVzQWZ0ZXIsIHNvcnQ6IFVQREFURURfREVTQykge1xuICAgICAgICBub2RlcyB7XG4gICAgICAgICAgaWRcbiAgICAgICAgICBpaWRcbiAgICAgICAgICB0aXRsZVxuICAgICAgICAgIHdlYlVybFxuICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgbGFiZWxzKGZpcnN0OiAxMCkge1xuICAgICAgICAgICAgbm9kZXMge1xuICAgICAgICAgICAgICB0aXRsZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlcGljIHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgICBpaWRcbiAgICAgICAgICAgIHRpdGxlXG4gICAgICAgICAgICB3ZWJVcmxcbiAgICAgICAgICB9XG4gICAgICAgICAgdGltZWxvZ3MoZmlyc3Q6ICR0aW1lbG9nRmlyc3QpIHtcbiAgICAgICAgICAgIG5vZGVzIHtcbiAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgc3BlbnRBdFxuICAgICAgICAgICAgICB0aW1lU3BlbnRcbiAgICAgICAgICAgICAgc3VtbWFyeVxuICAgICAgICAgICAgICB1c2VyIHtcbiAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICB1c2VybmFtZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhZ2VJbmZvIHtcbiAgICAgICAgICBoYXNOZXh0UGFnZVxuICAgICAgICAgIGVuZEN1cnNvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5gO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQcm9qZWN0VGltZVJlcG9ydChcbiAgcHJvamVjdEZ1bGxQYXRoOiBzdHJpbmcsXG4gIGNyZWRlbnRpYWxzOiBHaXRMYWJDcmVkZW50aWFscyxcbiAgcmFuZ2U6IFRpbWVSYW5nZUZpbHRlcixcbiAgaXNzdWVQYWdlU2l6ZTogbnVtYmVyID0gREVGQVVMVF9JU1NVRV9QQUdFX1NJWkUsXG4gIHRpbWVsb2dQYWdlU2l6ZTogbnVtYmVyID0gREVGQVVMVF9USU1FTE9HX1BBR0VfU0laRVxuKTogUHJvbWlzZTxQcm9qZWN0VGltZVJlcG9ydD4ge1xuICBjb25zdCBhcGlVcmwgPSBjcmVkZW50aWFscy5hcGlVcmw/LnRyaW0oKSB8fCBERUZBVUxUX0dSQVBIUUxfRU5EUE9JTlQ7XG4gIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NyZWRlbnRpYWxzLnRva2VufWBcbiAgfTtcblxuICBpZiAoIXByb2plY3RGdWxsUGF0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgR2l0TGFiIHByb2plY3QgZnVsbCBwYXRoLlwiKTtcbiAgfVxuXG4gIGlmICghY3JlZGVudGlhbHMudG9rZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIEdpdExhYiBhY2Nlc3MgdG9rZW4uXCIpO1xuICB9XG5cbiAgY29uc3QgaXNzdWVzOiBHaXRMYWJJc3N1ZVRpbWVbXSA9IFtdO1xuICBsZXQgcGFnZUluZm86IHsgaGFzTmV4dFBhZ2U6IGJvb2xlYW47IGVuZEN1cnNvcjogc3RyaW5nIHwgbnVsbCB9IHwgbnVsbCA9IG51bGw7XG4gIGxldCBwcm9qZWN0TWV0YTogeyBpZDogc3RyaW5nOyBuYW1lOiBzdHJpbmc7IHdlYlVybDogc3RyaW5nIH0gfCBudWxsID0gbnVsbDtcblxuICBkbyB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGlVcmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBxdWVyeTogSVNTVUVfVElNRUxPR1NfUVVFUlksXG4gICAgICAgIHZhcmlhYmxlczoge1xuICAgICAgICAgIGZ1bGxQYXRoOiBwcm9qZWN0RnVsbFBhdGgsXG4gICAgICAgICAgaXNzdWVzRmlyc3Q6IGlzc3VlUGFnZVNpemUsXG4gICAgICAgICAgaXNzdWVzQWZ0ZXI6IHBhZ2VJbmZvPy5lbmRDdXJzb3IgPz8gbnVsbCxcbiAgICAgICAgICB0aW1lbG9nRmlyc3Q6IHRpbWVsb2dQYWdlU2l6ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBHaXRMYWIgR3JhcGhRTCByZXNwb25kZWQgd2l0aCAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWA7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpIGFzIEdyYXBoUUxSZXNwb25zZTxJc3N1ZVBhZ2VQYXlsb2FkPjtcblxuICAgIGlmIChwYXlsb2FkLmVycm9ycz8ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocGF5bG9hZC5lcnJvcnMubWFwKChlcnIpID0+IGVyci5tZXNzYWdlKS5qb2luKFwiOyBcIikpO1xuICAgIH1cblxuICAgIGlmICghcGF5bG9hZC5kYXRhPy5wcm9qZWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9qZWN0IG5vdCBmb3VuZCBvciBhY2Nlc3MgZGVuaWVkLlwiKTtcbiAgICB9XG5cbiAgICBwcm9qZWN0TWV0YSA9IHtcbiAgICAgIGlkOiBwYXlsb2FkLmRhdGEucHJvamVjdC5pZCxcbiAgICAgIG5hbWU6IHBheWxvYWQuZGF0YS5wcm9qZWN0Lm5hbWUsXG4gICAgICB3ZWJVcmw6IHBheWxvYWQuZGF0YS5wcm9qZWN0LndlYlVybFxuICAgIH07XG5cbiAgICBjb25zdCBjdXJyZW50SXNzdWVzID0gcGF5bG9hZC5kYXRhLnByb2plY3QuaXNzdWVzLm5vZGVzLm1hcCgobm9kZSkgPT5cbiAgICAgIHRyYW5zZm9ybUlzc3VlTm9kZShub2RlLCByYW5nZSlcbiAgICApO1xuICAgIGlzc3Vlcy5wdXNoKC4uLmN1cnJlbnRJc3N1ZXMpO1xuXG4gICAgcGFnZUluZm8gPSBwYXlsb2FkLmRhdGEucHJvamVjdC5pc3N1ZXMucGFnZUluZm87XG4gIH0gd2hpbGUgKHBhZ2VJbmZvPy5oYXNOZXh0UGFnZSk7XG5cbiAgY29uc3Qgc3VtbWFyeSA9IGJ1aWxkVGltZVN1bW1hcnkoaXNzdWVzKTtcblxuICByZXR1cm4ge1xuICAgIHByb2plY3Q6IHByb2plY3RNZXRhID8/IHtcbiAgICAgIGlkOiBcInVua25vd25cIixcbiAgICAgIG5hbWU6IHByb2plY3RGdWxsUGF0aCxcbiAgICAgIHdlYlVybDogXCJcIlxuICAgIH0sXG4gICAgaXNzdWVzLFxuICAgIHN1bW1hcnksXG4gICAgcmFuZ2UsXG4gICAgZ2VuZXJhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBjb21taXRBY3Rpdml0eTogW10sXG4gICAgY29tbWl0UmFuZ2U6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtSXNzdWVOb2RlKFxuICBub2RlOiBHcmFwaFFMSXNzdWVOb2RlLFxuICByYW5nZTogVGltZVJhbmdlRmlsdGVyXG4pOiBHaXRMYWJJc3N1ZVRpbWUge1xuICBjb25zdCB0aW1lbG9ncyA9IChub2RlLnRpbWVsb2dzPy5ub2RlcyA/PyBbXSlcbiAgICAuZmlsdGVyKChsb2cpOiBsb2cgaXMgTm9uTnVsbGFibGU8dHlwZW9mIGxvZz4gPT4ge1xuICAgICAgaWYgKCFsb2cgfHwgbG9nLnRpbWVTcGVudCA8PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1dpdGhpblJhbmdlKGxvZy5zcGVudEF0LCByYW5nZSk7XG4gICAgfSlcbiAgICAubWFwKChsb2cpID0+ICh7XG4gICAgICBpZDogbG9nLmlkLFxuICAgICAgc3BlbnRBdDogbG9nLnNwZW50QXQsXG4gICAgICBzZWNvbmRzOiBsb2cudGltZVNwZW50LFxuICAgICAgc3VtbWFyeTogbG9nLnN1bW1hcnksXG4gICAgICB1c2VyOiB7XG4gICAgICAgIGlkOiBsb2cudXNlcj8uaWQgPz8gXCJ1bmtub3duXCIsXG4gICAgICAgIG5hbWU6IGxvZy51c2VyPy5uYW1lID8/IFwiVW5rbm93blwiLFxuICAgICAgICB1c2VybmFtZTogbG9nLnVzZXI/LnVzZXJuYW1lID8/IFwidW5rbm93blwiXG4gICAgICB9XG4gICAgfSkpO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6IG5vZGUuaWQsXG4gICAgaWlkOiBub2RlLmlpZCxcbiAgICB0aXRsZTogbm9kZS50aXRsZSxcbiAgICB3ZWJVcmw6IG5vZGUud2ViVXJsLFxuICAgIHN0YXRlOiBub2RlLnN0YXRlLFxuICAgIGxhYmVsczogbm9kZS5sYWJlbHM/Lm5vZGVzPy5tYXAoKGxhYmVsKSA9PiBsYWJlbC50aXRsZSkgPz8gW10sXG4gICAgZXBpYzogbm9kZS5lcGljXG4gICAgICA/IHtcbiAgICAgICAgICBpZDogbm9kZS5lcGljLmlkLFxuICAgICAgICAgIGlpZDogbm9kZS5lcGljLmlpZCxcbiAgICAgICAgICB0aXRsZTogbm9kZS5lcGljLnRpdGxlLFxuICAgICAgICAgIHdlYlVybDogbm9kZS5lcGljLndlYlVybFxuICAgICAgICB9XG4gICAgICA6IG51bGwsXG4gICAgdGltZWxvZ3NcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNXaXRoaW5SYW5nZShzcGVudEF0OiBzdHJpbmcsIHJhbmdlOiBUaW1lUmFuZ2VGaWx0ZXIpOiBib29sZWFuIHtcbiAgaWYgKCFyYW5nZS5mcm9tICYmICFyYW5nZS50bykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5wYXJzZShzcGVudEF0KTtcbiAgaWYgKE51bWJlci5pc05hTih0aW1lc3RhbXApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAocmFuZ2UuZnJvbSkge1xuICAgIGNvbnN0IGZyb21UcyA9IERhdGUucGFyc2UocmFuZ2UuZnJvbSk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4oZnJvbVRzKSAmJiB0aW1lc3RhbXAgPCBmcm9tVHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAocmFuZ2UudG8pIHtcbiAgICBjb25zdCB0b1RzID0gRGF0ZS5wYXJzZShyYW5nZS50byk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4odG9UcykgJiYgdGltZXN0YW1wID49IHRvVHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYnVpbGRUaW1lU3VtbWFyeShpc3N1ZXM6IEdpdExhYklzc3VlVGltZVtdKTogVGltZVN1bW1hcnkge1xuICBsZXQgdG90YWxTZWNvbmRzID0gMDtcbiAgY29uc3QgYnlVc2VyID0gbmV3IE1hcDxzdHJpbmcsIFRpbWVTdW1tYXJ5R3JvdXA+KCk7XG4gIGNvbnN0IGJ5SXNzdWUgPSBuZXcgTWFwPHN0cmluZywgVGltZVN1bW1hcnlHcm91cD4oKTtcbiAgY29uc3QgYnlFcGljID0gbmV3IE1hcDxzdHJpbmcsIFRpbWVTdW1tYXJ5R3JvdXA+KCk7XG4gIGNvbnN0IGJ5RGF0ZSA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gIGNvbnN0IGJ5TGFiZWwgPSBuZXcgTWFwPHN0cmluZywgVGltZVN1bW1hcnlHcm91cD4oKTtcbiAgY29uc3QgYnlTdGF0ZSA9IG5ldyBNYXA8c3RyaW5nLCBUaW1lU3VtbWFyeUdyb3VwPigpO1xuICBjb25zdCB3ZWVrbHlCdWNrZXRzID0gbmV3IE1hcDxcbiAgICBzdHJpbmcsXG4gICAge1xuICAgICAgd2Vla1N0YXJ0OiBzdHJpbmc7XG4gICAgICBsYWJlbDogc3RyaW5nO1xuICAgICAgdG90YWxzOiBNYXA8c3RyaW5nLCBXZWVrbHlVc2VyVG90YWw+O1xuICAgICAgdG90YWxTZWNvbmRzOiBudW1iZXI7XG4gICAgfVxuICA+KCk7XG5cbiAgZm9yIChjb25zdCBpc3N1ZSBvZiBpc3N1ZXMpIHtcbiAgICBsZXQgaXNzdWVTZWNvbmRzID0gMDtcbiAgICBmb3IgKGNvbnN0IHRpbWVsb2cgb2YgaXNzdWUudGltZWxvZ3MpIHtcbiAgICAgIHRvdGFsU2Vjb25kcyArPSB0aW1lbG9nLnNlY29uZHM7XG4gICAgICBpc3N1ZVNlY29uZHMgKz0gdGltZWxvZy5zZWNvbmRzO1xuXG4gICAgICBjb25zdCBkYXRlS2V5ID0gdGltZWxvZy5zcGVudEF0ID8gdGltZWxvZy5zcGVudEF0LnNsaWNlKDAsIDEwKSA6IFwidW5rbm93blwiO1xuICAgICAgYnlEYXRlLnNldChkYXRlS2V5LCAoYnlEYXRlLmdldChkYXRlS2V5KSA/PyAwKSArIHRpbWVsb2cuc2Vjb25kcyk7XG5cbiAgICAgIGNvbnN0IHVzZXJLZXkgPSB0aW1lbG9nLnVzZXIudXNlcm5hbWUgfHwgdGltZWxvZy51c2VyLmlkO1xuICAgICAgY29uc3QgdXNlckdyb3VwID0gYnlVc2VyLmdldCh1c2VyS2V5KSA/PyB7XG4gICAgICAgIGxhYmVsOiB0aW1lbG9nLnVzZXIubmFtZSxcbiAgICAgICAgc2Vjb25kczogMCxcbiAgICAgICAgaGludHM6IHtcbiAgICAgICAgICB1c2VybmFtZTogdGltZWxvZy51c2VyLnVzZXJuYW1lXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1c2VyR3JvdXAuc2Vjb25kcyArPSB0aW1lbG9nLnNlY29uZHM7XG4gICAgICBieVVzZXIuc2V0KHVzZXJLZXksIHVzZXJHcm91cCk7XG5cbiAgICAgIGNvbnN0IHdlZWtCdWNrZXQgPSBnZXRXZWVrQnVja2V0KHRpbWVsb2cuc3BlbnRBdCk7XG4gICAgICBpZiAod2Vla0J1Y2tldCkge1xuICAgICAgICBjb25zdCBhZ2dyZWdhdGUgPVxuICAgICAgICAgIHdlZWtseUJ1Y2tldHMuZ2V0KHdlZWtCdWNrZXQua2V5KSA/P1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdlZWtTdGFydDogd2Vla0J1Y2tldC5zdGFydCxcbiAgICAgICAgICAgIGxhYmVsOiB3ZWVrQnVja2V0LmxhYmVsLFxuICAgICAgICAgICAgdG90YWxzOiBuZXcgTWFwPHN0cmluZywgV2Vla2x5VXNlclRvdGFsPigpLFxuICAgICAgICAgICAgdG90YWxTZWNvbmRzOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXNlclRvdGFscyA9XG4gICAgICAgICAgYWdncmVnYXRlLnRvdGFscy5nZXQodXNlcktleSkgPz9cbiAgICAgICAgICB7XG4gICAgICAgICAgICB1c2VySWQ6IHRpbWVsb2cudXNlci5pZCxcbiAgICAgICAgICAgIHVzZXJOYW1lOiB0aW1lbG9nLnVzZXIubmFtZSxcbiAgICAgICAgICAgIHVzZXJuYW1lOiB0aW1lbG9nLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICBzZWNvbmRzOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgdXNlclRvdGFscy5zZWNvbmRzICs9IHRpbWVsb2cuc2Vjb25kcztcbiAgICAgICAgYWdncmVnYXRlLnRvdGFscy5zZXQodXNlcktleSwgdXNlclRvdGFscyk7XG4gICAgICAgIGFnZ3JlZ2F0ZS50b3RhbFNlY29uZHMgKz0gdGltZWxvZy5zZWNvbmRzO1xuICAgICAgICB3ZWVrbHlCdWNrZXRzLnNldCh3ZWVrQnVja2V0LmtleSwgYWdncmVnYXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpc3N1ZUdyb3VwID0gYnlJc3N1ZS5nZXQoaXNzdWUuaWQpID8/IHtcbiAgICAgIGxhYmVsOiBgIyR7aXNzdWUuaWlkfSAke2lzc3VlLnRpdGxlfWAsXG4gICAgICBzZWNvbmRzOiAwLFxuICAgICAgaGludHM6IHtcbiAgICAgICAgaXNzdWVVcmw6IGlzc3VlLndlYlVybCxcbiAgICAgICAgc3RhdGU6IGlzc3VlLnN0YXRlXG4gICAgICB9XG4gICAgfTtcbiAgICBpc3N1ZUdyb3VwLnNlY29uZHMgKz0gaXNzdWVTZWNvbmRzO1xuICAgIGJ5SXNzdWUuc2V0KGlzc3VlLmlkLCBpc3N1ZUdyb3VwKTtcblxuICAgIGNvbnN0IGVwaWNLZXkgPSBpc3N1ZS5lcGljPy5pZCA/PyBcInVuYXNzaWduZWRcIjtcbiAgICBjb25zdCBlcGljTGFiZWwgPSBpc3N1ZS5lcGljID8gaXNzdWUuZXBpYy50aXRsZSA6IFwiTm8gZXBpY1wiO1xuICAgIGNvbnN0IGVwaWNHcm91cCA9IGJ5RXBpYy5nZXQoZXBpY0tleSkgPz8ge1xuICAgICAgbGFiZWw6IGVwaWNMYWJlbCxcbiAgICAgIHNlY29uZHM6IDAsXG4gICAgICBoaW50czoge1xuICAgICAgICBlcGljVXJsOiBpc3N1ZS5lcGljPy53ZWJVcmwgPz8gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfTtcbiAgICBlcGljR3JvdXAuc2Vjb25kcyArPSBpc3N1ZVNlY29uZHM7XG4gICAgYnlFcGljLnNldChlcGljS2V5LCBlcGljR3JvdXApO1xuXG4gICAgY29uc3Qgc3RhdGVLZXkgPSBpc3N1ZS5zdGF0ZSB8fCBcInVua25vd25cIjtcbiAgICBjb25zdCBzdGF0ZUdyb3VwID0gYnlTdGF0ZS5nZXQoc3RhdGVLZXkpID8/IHtcbiAgICAgIGxhYmVsOiBzdGF0ZUtleSxcbiAgICAgIHNlY29uZHM6IDBcbiAgICB9O1xuICAgIHN0YXRlR3JvdXAuc2Vjb25kcyArPSBpc3N1ZVNlY29uZHM7XG4gICAgYnlTdGF0ZS5zZXQoc3RhdGVLZXksIHN0YXRlR3JvdXApO1xuXG4gICAgZm9yIChjb25zdCBsYWJlbCBvZiBpc3N1ZS5sYWJlbHMpIHtcbiAgICAgIGNvbnN0IGxhYmVsR3JvdXAgPSBieUxhYmVsLmdldChsYWJlbCkgPz8ge1xuICAgICAgICBsYWJlbCxcbiAgICAgICAgc2Vjb25kczogMFxuICAgICAgfTtcbiAgICAgIGxhYmVsR3JvdXAuc2Vjb25kcyArPSBpc3N1ZVNlY29uZHM7XG4gICAgICBieUxhYmVsLnNldChsYWJlbCwgbGFiZWxHcm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3RhbFNlY29uZHMsXG4gICAgYnlVc2VyOiBBcnJheS5mcm9tKGJ5VXNlci52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4gYi5zZWNvbmRzIC0gYS5zZWNvbmRzKSxcbiAgICBieUlzc3VlOiBBcnJheS5mcm9tKGJ5SXNzdWUudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGIuc2Vjb25kcyAtIGEuc2Vjb25kcyksXG4gICAgYnlFcGljOiBBcnJheS5mcm9tKGJ5RXBpYy52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4gYi5zZWNvbmRzIC0gYS5zZWNvbmRzKSxcbiAgICBieUxhYmVsOiBBcnJheS5mcm9tKGJ5TGFiZWwudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGIuc2Vjb25kcyAtIGEuc2Vjb25kcyksXG4gICAgYnlTdGF0ZTogQXJyYXkuZnJvbShieVN0YXRlLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiBiLnNlY29uZHMgLSBhLnNlY29uZHMpLFxuICAgIGJ5RGF0ZTogQXJyYXkuZnJvbShieURhdGUuZW50cmllcygpKVxuICAgICAgLm1hcCgoW2RhdGUsIHNlY29uZHNdKSA9PiAoeyBkYXRlLCBzZWNvbmRzIH0pKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZGF0ZS5sb2NhbGVDb21wYXJlKGIuZGF0ZSkpLFxuICAgIHdlZWtseUJ5VXNlcjogQXJyYXkuZnJvbSh3ZWVrbHlCdWNrZXRzLnZhbHVlcygpKVxuICAgICAgLm1hcCgoYnVja2V0KSA9PiAoe1xuICAgICAgICB3ZWVrU3RhcnQ6IGJ1Y2tldC53ZWVrU3RhcnQsXG4gICAgICAgIGxhYmVsOiBidWNrZXQubGFiZWwsXG4gICAgICAgIHRvdGFsczogQXJyYXkuZnJvbShidWNrZXQudG90YWxzLnZhbHVlcygpKS5zb3J0KFxuICAgICAgICAgIChhLCBiKSA9PiBiLnNlY29uZHMgLSBhLnNlY29uZHNcbiAgICAgICAgKSxcbiAgICAgICAgdG90YWxTZWNvbmRzOiBidWNrZXQudG90YWxTZWNvbmRzXG4gICAgICB9KSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLndlZWtTdGFydC5sb2NhbGVDb21wYXJlKGIud2Vla1N0YXJ0KSlcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlY29uZHNUb0hvdXJzKHNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLnJvdW5kKChzZWNvbmRzIC8gMzYwMCkgKiAxMDApIC8gMTAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RHVyYXRpb24oc2Vjb25kczogbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKHNlY29uZHMgLyAzNjAwKTtcbiAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IoKHNlY29uZHMgJSAzNjAwKSAvIDYwKTtcbiAgaWYgKGhvdXJzID09PSAwICYmIG1pbnV0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gXCI8MW1cIjtcbiAgfVxuICBpZiAoaG91cnMgPT09IDApIHtcbiAgICByZXR1cm4gYCR7bWludXRlc31tYDtcbiAgfVxuICBpZiAobWludXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBgJHtob3Vyc31oYDtcbiAgfVxuICByZXR1cm4gYCR7aG91cnN9aCAke21pbnV0ZXN9bWA7XG59XG5cbmZ1bmN0aW9uIGdldFdlZWtCdWNrZXQoc3BlbnRBdDogc3RyaW5nKTogeyBrZXk6IHN0cmluZzsgc3RhcnQ6IHN0cmluZzsgbGFiZWw6IHN0cmluZyB9IHwgbnVsbCB7XG4gIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUucGFyc2Uoc3BlbnRBdCk7XG4gIGlmIChOdW1iZXIuaXNOYU4odGltZXN0YW1wKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHdlZWtTdGFydERhdGUgPSBzdGFydE9mV2VlayhuZXcgRGF0ZSh0aW1lc3RhbXApKTtcbiAgY29uc3Qgc3RhcnQgPSBpc29EYXRlT25seSh3ZWVrU3RhcnREYXRlKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IHN0YXJ0LFxuICAgIHN0YXJ0LFxuICAgIGxhYmVsOiBmb3JtYXRXZWVrTGFiZWwod2Vla1N0YXJ0RGF0ZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RhcnRPZldlZWsoZGF0ZTogRGF0ZSk6IERhdGUge1xuICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKERhdGUuVVRDKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgZGF0ZS5nZXRVVENNb250aCgpLCBkYXRlLmdldFVUQ0RhdGUoKSkpO1xuICBjb25zdCBkYXkgPSBzdGFydC5nZXRVVENEYXkoKTtcbiAgY29uc3QgZGlmZiA9IGRheSA9PT0gMCA/IC02IDogMSAtIGRheTtcbiAgc3RhcnQuc2V0VVRDRGF0ZShzdGFydC5nZXRVVENEYXRlKCkgKyBkaWZmKTtcbiAgcmV0dXJuIHN0YXJ0O1xufVxuXG5mdW5jdGlvbiBpc29EYXRlT25seShkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtMYWJlbChkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodW5kZWZpbmVkLCB7XG4gICAgbW9udGg6IFwic2hvcnRcIixcbiAgICBkYXk6IFwibnVtZXJpY1wiXG4gIH0pO1xuICByZXR1cm4gYFdlZWsgb2YgJHtmb3JtYXR0ZXIuZm9ybWF0KGRhdGUpfWA7XG59XG4iXSwibmFtZXMiOlsiREVGQVVMVF9HUkFQSFFMX0VORFBPSU5UIiwiREVGQVVMVF9JU1NVRV9QQUdFX1NJWkUiLCJERUZBVUxUX1RJTUVMT0dfUEFHRV9TSVpFIiwiREVGQVVMVF9SRVNUX0VORFBPSU5UIiwiSVNTVUVfVElNRUxPR1NfUVVFUlkiLCJmZXRjaFByb2plY3RUaW1lUmVwb3J0IiwicHJvamVjdEZ1bGxQYXRoIiwiY3JlZGVudGlhbHMiLCJyYW5nZSIsImlzc3VlUGFnZVNpemUiLCJ0aW1lbG9nUGFnZVNpemUiLCJhcGlVcmwiLCJ0cmltIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJ0b2tlbiIsIkVycm9yIiwiaXNzdWVzIiwicGFnZUluZm8iLCJwcm9qZWN0TWV0YSIsInBheWxvYWQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJxdWVyeSIsInZhcmlhYmxlcyIsImZ1bGxQYXRoIiwiaXNzdWVzRmlyc3QiLCJpc3N1ZXNBZnRlciIsImVuZEN1cnNvciIsInRpbWVsb2dGaXJzdCIsIm9rIiwibWVzc2FnZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJqc29uIiwiZXJyb3JzIiwibGVuZ3RoIiwibWFwIiwiZXJyIiwiam9pbiIsImRhdGEiLCJwcm9qZWN0IiwiaWQiLCJuYW1lIiwid2ViVXJsIiwiY3VycmVudElzc3VlcyIsIm5vZGVzIiwibm9kZSIsInRyYW5zZm9ybUlzc3VlTm9kZSIsInB1c2giLCJoYXNOZXh0UGFnZSIsInN1bW1hcnkiLCJidWlsZFRpbWVTdW1tYXJ5IiwiZ2VuZXJhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjb21taXRBY3Rpdml0eSIsImNvbW1pdFJhbmdlIiwidGltZWxvZ3MiLCJmaWx0ZXIiLCJsb2ciLCJ0aW1lU3BlbnQiLCJpc1dpdGhpblJhbmdlIiwic3BlbnRBdCIsInNlY29uZHMiLCJ1c2VyIiwidXNlcm5hbWUiLCJpaWQiLCJ0aXRsZSIsInN0YXRlIiwibGFiZWxzIiwibGFiZWwiLCJlcGljIiwiZnJvbSIsInRvIiwidGltZXN0YW1wIiwicGFyc2UiLCJOdW1iZXIiLCJpc05hTiIsImZyb21UcyIsInRvVHMiLCJ0b3RhbFNlY29uZHMiLCJieVVzZXIiLCJNYXAiLCJieUlzc3VlIiwiYnlFcGljIiwiYnlEYXRlIiwiYnlMYWJlbCIsImJ5U3RhdGUiLCJ3ZWVrbHlCdWNrZXRzIiwiaXNzdWUiLCJpc3N1ZVNlY29uZHMiLCJ0aW1lbG9nIiwiZGF0ZUtleSIsInNsaWNlIiwic2V0IiwiZ2V0IiwidXNlcktleSIsInVzZXJHcm91cCIsImhpbnRzIiwid2Vla0J1Y2tldCIsImdldFdlZWtCdWNrZXQiLCJhZ2dyZWdhdGUiLCJrZXkiLCJ3ZWVrU3RhcnQiLCJzdGFydCIsInRvdGFscyIsInVzZXJUb3RhbHMiLCJ1c2VySWQiLCJ1c2VyTmFtZSIsImlzc3VlR3JvdXAiLCJpc3N1ZVVybCIsImVwaWNLZXkiLCJlcGljTGFiZWwiLCJlcGljR3JvdXAiLCJlcGljVXJsIiwidW5kZWZpbmVkIiwic3RhdGVLZXkiLCJzdGF0ZUdyb3VwIiwibGFiZWxHcm91cCIsIkFycmF5IiwidmFsdWVzIiwic29ydCIsImEiLCJiIiwiZW50cmllcyIsImRhdGUiLCJsb2NhbGVDb21wYXJlIiwid2Vla2x5QnlVc2VyIiwiYnVja2V0Iiwic2Vjb25kc1RvSG91cnMiLCJNYXRoIiwicm91bmQiLCJmb3JtYXREdXJhdGlvbiIsImhvdXJzIiwiZmxvb3IiLCJtaW51dGVzIiwid2Vla1N0YXJ0RGF0ZSIsInN0YXJ0T2ZXZWVrIiwiaXNvRGF0ZU9ubHkiLCJmb3JtYXRXZWVrTGFiZWwiLCJVVEMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImRheSIsImdldFVUQ0RheSIsImRpZmYiLCJzZXRVVENEYXRlIiwiZm9ybWF0dGVyIiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwibW9udGgiLCJmb3JtYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/gitlab.ts\n"));

/***/ })

});