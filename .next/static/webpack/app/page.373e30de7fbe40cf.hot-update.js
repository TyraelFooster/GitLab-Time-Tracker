"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/lib/gitlab.ts":
/*!***************************!*\
  !*** ./app/lib/gitlab.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchProjectTimeReport: function() { return /* binding */ fetchProjectTimeReport; },\n/* harmony export */   formatDuration: function() { return /* binding */ formatDuration; },\n/* harmony export */   secondsToHours: function() { return /* binding */ secondsToHours; }\n/* harmony export */ });\nconst DEFAULT_GRAPHQL_ENDPOINT = \"https://gitlab.com/api/graphql\";\nconst DEFAULT_ISSUE_PAGE_SIZE = 20;\nconst DEFAULT_TIMELOG_PAGE_SIZE = 100;\nconst ISSUE_TIMELOGS_QUERY = \"\\n  query ProjectIssueTimelogs(\\n    $fullPath: ID!,\\n    $issuesFirst: Int!,\\n    $issuesAfter: String,\\n    $timelogFirst: Int!\\n  ) {\\n    project(fullPath: $fullPath) {\\n      id\\n      name\\n      webUrl\\n      issues(first: $issuesFirst, after: $issuesAfter, sort: UPDATED_DESC) {\\n        nodes {\\n          id\\n          iid\\n          title\\n          webUrl\\n          state\\n          labels(first: 10) {\\n            nodes {\\n              title\\n            }\\n          }\\n          epic {\\n            id\\n            iid\\n            title\\n            webUrl\\n          }\\n          timelogs(first: $timelogFirst) {\\n            nodes {\\n              id\\n              spentAt\\n              timeSpent\\n              summary\\n              user {\\n                id\\n                name\\n                username\\n              }\\n            }\\n          }\\n        }\\n        pageInfo {\\n          hasNextPage\\n          endCursor\\n        }\\n      }\\n    }\\n  }\\n\";\nasync function fetchProjectTimeReport(projectFullPath, credentials, range) {\n    let issuePageSize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : DEFAULT_ISSUE_PAGE_SIZE, timelogPageSize = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : DEFAULT_TIMELOG_PAGE_SIZE;\n    var _credentials_apiUrl;\n    const apiUrl = ((_credentials_apiUrl = credentials.apiUrl) === null || _credentials_apiUrl === void 0 ? void 0 : _credentials_apiUrl.trim()) || DEFAULT_GRAPHQL_ENDPOINT;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(credentials.token)\n    };\n    if (!projectFullPath) {\n        throw new Error(\"Missing GitLab project full path.\");\n    }\n    if (!credentials.token) {\n        throw new Error(\"Missing GitLab access token.\");\n    }\n    const issues = [];\n    let pageInfo = null;\n    let projectMeta = null;\n    do {\n        var _payload_errors, _payload_data;\n        var _pageInfo_endCursor;\n        const response = await fetch(apiUrl, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({\n                query: ISSUE_TIMELOGS_QUERY,\n                variables: {\n                    fullPath: projectFullPath,\n                    issuesFirst: issuePageSize,\n                    issuesAfter: (_pageInfo_endCursor = pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.endCursor) !== null && _pageInfo_endCursor !== void 0 ? _pageInfo_endCursor : null,\n                    timelogFirst: timelogPageSize\n                }\n            })\n        });\n        if (!response.ok) {\n            const message = \"GitLab GraphQL responded with \".concat(response.status, \" \").concat(response.statusText);\n            throw new Error(message);\n        }\n        const payload = await response.json();\n        if ((_payload_errors = payload.errors) === null || _payload_errors === void 0 ? void 0 : _payload_errors.length) {\n            throw new Error(payload.errors.map((err)=>err.message).join(\"; \"));\n        }\n        if (!((_payload_data = payload.data) === null || _payload_data === void 0 ? void 0 : _payload_data.project)) {\n            throw new Error(\"Project not found or access denied.\");\n        }\n        projectMeta = {\n            id: payload.data.project.id,\n            name: payload.data.project.name,\n            webUrl: payload.data.project.webUrl\n        };\n        const currentIssues = payload.data.project.issues.nodes.map((node)=>transformIssueNode(node, range));\n        issues.push(...currentIssues);\n        pageInfo = payload.data.project.issues.pageInfo;\n    }while (pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo.hasNextPage);\n    const summary = buildTimeSummary(issues);\n    return {\n        project: projectMeta !== null && projectMeta !== void 0 ? projectMeta : {\n            id: \"unknown\",\n            name: projectFullPath,\n            webUrl: \"\"\n        },\n        issues,\n        summary,\n        range,\n        generatedAt: new Date().toISOString()\n    };\n}\nfunction transformIssueNode(node, range) {\n    var _node_timelogs, _node_labels_nodes, _node_labels;\n    var _node_timelogs_nodes;\n    const timelogs = ((_node_timelogs_nodes = (_node_timelogs = node.timelogs) === null || _node_timelogs === void 0 ? void 0 : _node_timelogs.nodes) !== null && _node_timelogs_nodes !== void 0 ? _node_timelogs_nodes : []).filter((log)=>{\n        if (!log || log.timeSpent <= 0) {\n            return false;\n        }\n        return isWithinRange(log.spentAt, range);\n    }).map((log)=>{\n        var _log_user, _log_user1, _log_user2;\n        var _log_user_id, _log_user_name, _log_user_username;\n        return {\n            id: log.id,\n            spentAt: log.spentAt,\n            seconds: log.timeSpent,\n            summary: log.summary,\n            user: {\n                id: (_log_user_id = (_log_user = log.user) === null || _log_user === void 0 ? void 0 : _log_user.id) !== null && _log_user_id !== void 0 ? _log_user_id : \"unknown\",\n                name: (_log_user_name = (_log_user1 = log.user) === null || _log_user1 === void 0 ? void 0 : _log_user1.name) !== null && _log_user_name !== void 0 ? _log_user_name : \"Unknown\",\n                username: (_log_user_username = (_log_user2 = log.user) === null || _log_user2 === void 0 ? void 0 : _log_user2.username) !== null && _log_user_username !== void 0 ? _log_user_username : \"unknown\"\n            }\n        };\n    });\n    var _node_labels_nodes_map;\n    return {\n        id: node.id,\n        iid: node.iid,\n        title: node.title,\n        webUrl: node.webUrl,\n        state: node.state,\n        labels: (_node_labels_nodes_map = (_node_labels = node.labels) === null || _node_labels === void 0 ? void 0 : (_node_labels_nodes = _node_labels.nodes) === null || _node_labels_nodes === void 0 ? void 0 : _node_labels_nodes.map((label)=>label.title)) !== null && _node_labels_nodes_map !== void 0 ? _node_labels_nodes_map : [],\n        epic: node.epic ? {\n            id: node.epic.id,\n            iid: node.epic.iid,\n            title: node.epic.title,\n            webUrl: node.epic.webUrl\n        } : null,\n        timelogs\n    };\n}\nfunction isWithinRange(spentAt, range) {\n    if (!range.from && !range.to) {\n        return true;\n    }\n    const timestamp = Date.parse(spentAt);\n    if (Number.isNaN(timestamp)) {\n        return true;\n    }\n    if (range.from) {\n        const fromTs = Date.parse(range.from);\n        if (!Number.isNaN(fromTs) && timestamp < fromTs) {\n            return false;\n        }\n    }\n    if (range.to) {\n        const toTs = Date.parse(range.to);\n        if (!Number.isNaN(toTs) && timestamp >= toTs) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction buildTimeSummary(issues) {\n    let totalSeconds = 0;\n    const byUser = new Map();\n    const byIssue = new Map();\n    const byEpic = new Map();\n    const byDate = new Map();\n    for (const issue of issues){\n        var _issue_epic, _issue_epic1;\n        let issueSeconds = 0;\n        for (const timelog of issue.timelogs){\n            totalSeconds += timelog.seconds;\n            issueSeconds += timelog.seconds;\n            const dateKey = timelog.spentAt ? timelog.spentAt.slice(0, 10) : \"unknown\";\n            var _byDate_get;\n            byDate.set(dateKey, ((_byDate_get = byDate.get(dateKey)) !== null && _byDate_get !== void 0 ? _byDate_get : 0) + timelog.seconds);\n            const userKey = timelog.user.username || timelog.user.id;\n            var _byUser_get;\n            const userGroup = (_byUser_get = byUser.get(userKey)) !== null && _byUser_get !== void 0 ? _byUser_get : {\n                label: timelog.user.name,\n                seconds: 0,\n                hints: {\n                    username: timelog.user.username\n                }\n            };\n            userGroup.seconds += timelog.seconds;\n            byUser.set(userKey, userGroup);\n        }\n        var _byIssue_get;\n        const issueGroup = (_byIssue_get = byIssue.get(issue.id)) !== null && _byIssue_get !== void 0 ? _byIssue_get : {\n            label: \"#\".concat(issue.iid, \" \").concat(issue.title),\n            seconds: 0,\n            hints: {\n                issueUrl: issue.webUrl,\n                state: issue.state\n            }\n        };\n        issueGroup.seconds += issueSeconds;\n        byIssue.set(issue.id, issueGroup);\n        var _issue_epic_id;\n        const epicKey = (_issue_epic_id = (_issue_epic = issue.epic) === null || _issue_epic === void 0 ? void 0 : _issue_epic.id) !== null && _issue_epic_id !== void 0 ? _issue_epic_id : \"unassigned\";\n        const epicLabel = issue.epic ? issue.epic.title : \"No epic\";\n        var _issue_epic_webUrl, _byEpic_get;\n        const epicGroup = (_byEpic_get = byEpic.get(epicKey)) !== null && _byEpic_get !== void 0 ? _byEpic_get : {\n            label: epicLabel,\n            seconds: 0,\n            hints: {\n                epicUrl: (_issue_epic_webUrl = (_issue_epic1 = issue.epic) === null || _issue_epic1 === void 0 ? void 0 : _issue_epic1.webUrl) !== null && _issue_epic_webUrl !== void 0 ? _issue_epic_webUrl : undefined\n            }\n        };\n        epicGroup.seconds += issueSeconds;\n        byEpic.set(epicKey, epicGroup);\n    }\n    return {\n        totalSeconds,\n        byUser: Array.from(byUser.values()).sort((a, b)=>b.seconds - a.seconds),\n        byIssue: Array.from(byIssue.values()).sort((a, b)=>b.seconds - a.seconds),\n        byEpic: Array.from(byEpic.values()).sort((a, b)=>b.seconds - a.seconds),\n        byDate: Array.from(byDate.entries()).map((param)=>{\n            let [date, seconds] = param;\n            return {\n                date,\n                seconds\n            };\n        }).sort((a, b)=>a.date.localeCompare(b.date))\n    };\n}\nfunction secondsToHours(seconds) {\n    return Math.round(seconds / 3600 * 100) / 100;\n}\nfunction formatDuration(seconds) {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor(seconds % 3600 / 60);\n    if (hours === 0 && minutes === 0) {\n        return \"<1m\";\n    }\n    if (hours === 0) {\n        return \"\".concat(minutes, \"m\");\n    }\n    if (minutes === 0) {\n        return \"\".concat(hours, \"h\");\n    }\n    return \"\".concat(hours, \"h \").concat(minutes, \"m\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0MsSUFBTUEsRUFBRTVDLE9BQU8sR0FBRzJDLEVBQUUzQyxPQUFPO1FBQzFFcUIsUUFBUW1CLE1BQU0vQixJQUFJLENBQUNZLE9BQU9vQixNQUFNLElBQUlDLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNQSxFQUFFNUMsT0FBTyxHQUFHMkMsRUFBRTNDLE9BQU87UUFDeEVzQixRQUFRa0IsTUFBTS9CLElBQUksQ0FBQ2EsT0FBT3VCLE9BQU8sSUFDOUJ0RSxHQUFHLENBQUM7Z0JBQUMsQ0FBQ3VFLE1BQU05QyxRQUFRO21CQUFNO2dCQUFFOEM7Z0JBQU05QztZQUFRO1dBQzFDMEMsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVHLElBQUksQ0FBQ0MsYUFBYSxDQUFDSCxFQUFFRSxJQUFJO0lBQy9DO0FBQ0Y7QUFFTyxTQUFTRSxlQUFlaEQsT0FBZTtJQUM1QyxPQUFPaUQsS0FBS0MsS0FBSyxDQUFDLFVBQVcsT0FBUSxPQUFPO0FBQzlDO0FBRU8sU0FBU0MsZUFBZW5ELE9BQWU7SUFDNUMsTUFBTW9ELFFBQVFILEtBQUtJLEtBQUssQ0FBQ3JELFVBQVU7SUFDbkMsTUFBTXNELFVBQVVMLEtBQUtJLEtBQUssQ0FBQyxVQUFXLE9BQVE7SUFDOUMsSUFBSUQsVUFBVSxLQUFLRSxZQUFZLEdBQUc7UUFDaEMsT0FBTztJQUNUO0lBQ0EsSUFBSUYsVUFBVSxHQUFHO1FBQ2YsT0FBTyxHQUFXLE9BQVJFLFNBQVE7SUFDcEI7SUFDQSxJQUFJQSxZQUFZLEdBQUc7UUFDakIsT0FBTyxHQUFTLE9BQU5GLE9BQU07SUFDbEI7SUFDQSxPQUFPLEdBQWFFLE9BQVZGLE9BQU0sTUFBWSxPQUFSRSxTQUFRO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9saWIvZ2l0bGFiLnRzPzk5ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgREVGQVVMVF9HUkFQSFFMX0VORFBPSU5UID0gXCJodHRwczovL2dpdGxhYi5jb20vYXBpL2dyYXBocWxcIjtcbmNvbnN0IERFRkFVTFRfSVNTVUVfUEFHRV9TSVpFID0gMjA7XG5jb25zdCBERUZBVUxUX1RJTUVMT0dfUEFHRV9TSVpFID0gMTAwO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdpdExhYkNyZWRlbnRpYWxzIHtcbiAgYXBpVXJsPzogc3RyaW5nO1xuICB0b2tlbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVSYW5nZUZpbHRlciB7XG4gIGZyb20/OiBzdHJpbmc7XG4gIHRvPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdlZWtseVVzZXJUb3RhbCB7XG4gIHVzZXJJZDogc3RyaW5nO1xuICB1c2VyTmFtZTogc3RyaW5nO1xuICB1c2VybmFtZTogc3RyaW5nO1xuICBzZWNvbmRzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2Vla2x5VXNlclN1bW1hcnkge1xuICB3ZWVrU3RhcnQ6IHN0cmluZztcbiAgbGFiZWw6IHN0cmluZztcbiAgdG90YWxzOiBXZWVrbHlVc2VyVG90YWxbXTtcbiAgdG90YWxTZWNvbmRzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tbWl0QWN0aXZpdHlEYXkge1xuICBkYXRlOiBzdHJpbmc7XG4gIGNvdW50OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tbWl0UmFuZ2Uge1xuICBtb250aDogc3RyaW5nO1xuICBmcm9tOiBzdHJpbmc7XG4gIHRvOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2l0TGFiSXNzdWVUaW1lbG9nIHtcbiAgaWQ6IHN0cmluZztcbiAgc3BlbnRBdDogc3RyaW5nO1xuICBzZWNvbmRzOiBudW1iZXI7XG4gIHVzZXI6IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB1c2VybmFtZTogc3RyaW5nO1xuICB9O1xuICBzdW1tYXJ5Pzogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHaXRMYWJJc3N1ZVRpbWUge1xuICBpZDogc3RyaW5nO1xuICBpaWQ6IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgd2ViVXJsOiBzdHJpbmc7XG4gIHN0YXRlOiBzdHJpbmc7XG4gIGxhYmVsczogc3RyaW5nW107XG4gIGVwaWM/OiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBpaWQ/OiBzdHJpbmcgfCBudWxsO1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgd2ViVXJsPzogc3RyaW5nIHwgbnVsbDtcbiAgfSB8IG51bGw7XG4gIHRpbWVsb2dzOiBHaXRMYWJJc3N1ZVRpbWVsb2dbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9qZWN0VGltZVJlcG9ydCB7XG4gIHByb2plY3Q6IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB3ZWJVcmw6IHN0cmluZztcbiAgfTtcbiAgaXNzdWVzOiBHaXRMYWJJc3N1ZVRpbWVbXTtcbiAgc3VtbWFyeTogVGltZVN1bW1hcnk7XG4gIHJhbmdlOiBUaW1lUmFuZ2VGaWx0ZXI7XG4gIGdlbmVyYXRlZEF0OiBzdHJpbmc7XG4gIGNvbW1pdEFjdGl2aXR5PzogQ29tbWl0QWN0aXZpdHlEYXlbXTtcbiAgY29tbWl0UmFuZ2U/OiBDb21taXRSYW5nZSB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGltZVN1bW1hcnlHcm91cCB7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIHNlY29uZHM6IG51bWJlcjtcbiAgaGludHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVTdW1tYXJ5IHtcbiAgdG90YWxTZWNvbmRzOiBudW1iZXI7XG4gIGJ5VXNlcjogVGltZVN1bW1hcnlHcm91cFtdO1xuICBieUlzc3VlOiBUaW1lU3VtbWFyeUdyb3VwW107XG4gIGJ5RXBpYzogVGltZVN1bW1hcnlHcm91cFtdO1xuICBieUxhYmVsOiBUaW1lU3VtbWFyeUdyb3VwW107XG4gIGJ5U3RhdGU6IFRpbWVTdW1tYXJ5R3JvdXBbXTtcbiAgYnlEYXRlOiB7IGRhdGU6IHN0cmluZzsgc2Vjb25kczogbnVtYmVyIH1bXTtcbiAgd2Vla2x5QnlVc2VyOiBXZWVrbHlVc2VyU3VtbWFyeVtdO1xufVxuXG5pbnRlcmZhY2UgR3JhcGhRTElzc3VlTm9kZSB7XG4gIGlkOiBzdHJpbmc7XG4gIGlpZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICB3ZWJVcmw6IHN0cmluZztcbiAgc3RhdGU6IHN0cmluZztcbiAgbGFiZWxzOiB7IG5vZGVzOiBBcnJheTx7IHRpdGxlOiBzdHJpbmcgfT4gfTtcbiAgZXBpYz86IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGlpZDogc3RyaW5nIHwgbnVsbDtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHdlYlVybDogc3RyaW5nIHwgbnVsbDtcbiAgfSB8IG51bGw7XG4gIHRpbWVsb2dzOiB7XG4gICAgbm9kZXM6IEFycmF5PHtcbiAgICAgIGlkOiBzdHJpbmc7XG4gICAgICBzcGVudEF0OiBzdHJpbmc7XG4gICAgICB0aW1lU3BlbnQ6IG51bWJlcjtcbiAgICAgIHN1bW1hcnk6IHN0cmluZyB8IG51bGw7XG4gICAgICB1c2VyPzoge1xuICAgICAgICBpZDogc3RyaW5nO1xuICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgICB9IHwgbnVsbDtcbiAgICB9PjtcbiAgfTtcbn1cblxuaW50ZXJmYWNlIEdyYXBoUUxSZXNwb25zZTxUPiB7XG4gIGRhdGE/OiBUO1xuICBlcnJvcnM/OiBBcnJheTx7IG1lc3NhZ2U6IHN0cmluZyB9Pjtcbn1cblxuaW50ZXJmYWNlIElzc3VlUGFnZVBheWxvYWQge1xuICBwcm9qZWN0OiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgd2ViVXJsOiBzdHJpbmc7XG4gICAgaXNzdWVzOiB7XG4gICAgICBub2RlczogR3JhcGhRTElzc3VlTm9kZVtdO1xuICAgICAgcGFnZUluZm86IHtcbiAgICAgICAgaGFzTmV4dFBhZ2U6IGJvb2xlYW47XG4gICAgICAgIGVuZEN1cnNvcjogc3RyaW5nIHwgbnVsbDtcbiAgICAgIH07XG4gICAgfTtcbiAgfSB8IG51bGw7XG59XG5cbmNvbnN0IElTU1VFX1RJTUVMT0dTX1FVRVJZID0gYFxuICBxdWVyeSBQcm9qZWN0SXNzdWVUaW1lbG9ncyhcbiAgICAkZnVsbFBhdGg6IElEISxcbiAgICAkaXNzdWVzRmlyc3Q6IEludCEsXG4gICAgJGlzc3Vlc0FmdGVyOiBTdHJpbmcsXG4gICAgJHRpbWVsb2dGaXJzdDogSW50IVxuICApIHtcbiAgICBwcm9qZWN0KGZ1bGxQYXRoOiAkZnVsbFBhdGgpIHtcbiAgICAgIGlkXG4gICAgICBuYW1lXG4gICAgICB3ZWJVcmxcbiAgICAgIGlzc3VlcyhmaXJzdDogJGlzc3Vlc0ZpcnN0LCBhZnRlcjogJGlzc3Vlc0FmdGVyLCBzb3J0OiBVUERBVEVEX0RFU0MpIHtcbiAgICAgICAgbm9kZXMge1xuICAgICAgICAgIGlkXG4gICAgICAgICAgaWlkXG4gICAgICAgICAgdGl0bGVcbiAgICAgICAgICB3ZWJVcmxcbiAgICAgICAgICBzdGF0ZVxuICAgICAgICAgIGxhYmVscyhmaXJzdDogMTApIHtcbiAgICAgICAgICAgIG5vZGVzIHtcbiAgICAgICAgICAgICAgdGl0bGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXBpYyB7XG4gICAgICAgICAgICBpZFxuICAgICAgICAgICAgaWlkXG4gICAgICAgICAgICB0aXRsZVxuICAgICAgICAgICAgd2ViVXJsXG4gICAgICAgICAgfVxuICAgICAgICAgIHRpbWVsb2dzKGZpcnN0OiAkdGltZWxvZ0ZpcnN0KSB7XG4gICAgICAgICAgICBub2RlcyB7XG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgIHNwZW50QXRcbiAgICAgICAgICAgICAgdGltZVNwZW50XG4gICAgICAgICAgICAgIHN1bW1hcnlcbiAgICAgICAgICAgICAgdXNlciB7XG4gICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgdXNlcm5hbWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYWdlSW5mbyB7XG4gICAgICAgICAgaGFzTmV4dFBhZ2VcbiAgICAgICAgICBlbmRDdXJzb3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuYDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoUHJvamVjdFRpbWVSZXBvcnQoXG4gIHByb2plY3RGdWxsUGF0aDogc3RyaW5nLFxuICBjcmVkZW50aWFsczogR2l0TGFiQ3JlZGVudGlhbHMsXG4gIHJhbmdlOiBUaW1lUmFuZ2VGaWx0ZXIsXG4gIGlzc3VlUGFnZVNpemU6IG51bWJlciA9IERFRkFVTFRfSVNTVUVfUEFHRV9TSVpFLFxuICB0aW1lbG9nUGFnZVNpemU6IG51bWJlciA9IERFRkFVTFRfVElNRUxPR19QQUdFX1NJWkVcbik6IFByb21pc2U8UHJvamVjdFRpbWVSZXBvcnQ+IHtcbiAgY29uc3QgYXBpVXJsID0gY3JlZGVudGlhbHMuYXBpVXJsPy50cmltKCkgfHwgREVGQVVMVF9HUkFQSFFMX0VORFBPSU5UO1xuICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtjcmVkZW50aWFscy50b2tlbn1gXG4gIH07XG5cbiAgaWYgKCFwcm9qZWN0RnVsbFBhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIEdpdExhYiBwcm9qZWN0IGZ1bGwgcGF0aC5cIik7XG4gIH1cblxuICBpZiAoIWNyZWRlbnRpYWxzLnRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBHaXRMYWIgYWNjZXNzIHRva2VuLlwiKTtcbiAgfVxuXG4gIGNvbnN0IGlzc3VlczogR2l0TGFiSXNzdWVUaW1lW10gPSBbXTtcbiAgbGV0IHBhZ2VJbmZvOiB7IGhhc05leHRQYWdlOiBib29sZWFuOyBlbmRDdXJzb3I6IHN0cmluZyB8IG51bGwgfSB8IG51bGwgPSBudWxsO1xuICBsZXQgcHJvamVjdE1ldGE6IHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nOyB3ZWJVcmw6IHN0cmluZyB9IHwgbnVsbCA9IG51bGw7XG5cbiAgZG8ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXBpVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcXVlcnk6IElTU1VFX1RJTUVMT0dTX1FVRVJZLFxuICAgICAgICB2YXJpYWJsZXM6IHtcbiAgICAgICAgICBmdWxsUGF0aDogcHJvamVjdEZ1bGxQYXRoLFxuICAgICAgICAgIGlzc3Vlc0ZpcnN0OiBpc3N1ZVBhZ2VTaXplLFxuICAgICAgICAgIGlzc3Vlc0FmdGVyOiBwYWdlSW5mbz8uZW5kQ3Vyc29yID8/IG51bGwsXG4gICAgICAgICAgdGltZWxvZ0ZpcnN0OiB0aW1lbG9nUGFnZVNpemVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgR2l0TGFiIEdyYXBoUUwgcmVzcG9uZGVkIHdpdGggJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHBheWxvYWQgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKSBhcyBHcmFwaFFMUmVzcG9uc2U8SXNzdWVQYWdlUGF5bG9hZD47XG5cbiAgICBpZiAocGF5bG9hZC5lcnJvcnM/Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHBheWxvYWQuZXJyb3JzLm1hcCgoZXJyKSA9PiBlcnIubWVzc2FnZSkuam9pbihcIjsgXCIpKTtcbiAgICB9XG5cbiAgICBpZiAoIXBheWxvYWQuZGF0YT8ucHJvamVjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvamVjdCBub3QgZm91bmQgb3IgYWNjZXNzIGRlbmllZC5cIik7XG4gICAgfVxuXG4gICAgcHJvamVjdE1ldGEgPSB7XG4gICAgICBpZDogcGF5bG9hZC5kYXRhLnByb2plY3QuaWQsXG4gICAgICBuYW1lOiBwYXlsb2FkLmRhdGEucHJvamVjdC5uYW1lLFxuICAgICAgd2ViVXJsOiBwYXlsb2FkLmRhdGEucHJvamVjdC53ZWJVcmxcbiAgICB9O1xuXG4gICAgY29uc3QgY3VycmVudElzc3VlcyA9IHBheWxvYWQuZGF0YS5wcm9qZWN0Lmlzc3Vlcy5ub2Rlcy5tYXAoKG5vZGUpID0+XG4gICAgICB0cmFuc2Zvcm1Jc3N1ZU5vZGUobm9kZSwgcmFuZ2UpXG4gICAgKTtcbiAgICBpc3N1ZXMucHVzaCguLi5jdXJyZW50SXNzdWVzKTtcblxuICAgIHBhZ2VJbmZvID0gcGF5bG9hZC5kYXRhLnByb2plY3QuaXNzdWVzLnBhZ2VJbmZvO1xuICB9IHdoaWxlIChwYWdlSW5mbz8uaGFzTmV4dFBhZ2UpO1xuXG4gIGNvbnN0IHN1bW1hcnkgPSBidWlsZFRpbWVTdW1tYXJ5KGlzc3Vlcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm9qZWN0OiBwcm9qZWN0TWV0YSA/PyB7XG4gICAgICBpZDogXCJ1bmtub3duXCIsXG4gICAgICBuYW1lOiBwcm9qZWN0RnVsbFBhdGgsXG4gICAgICB3ZWJVcmw6IFwiXCJcbiAgICB9LFxuICAgIGlzc3VlcyxcbiAgICBzdW1tYXJ5LFxuICAgIHJhbmdlLFxuICAgIGdlbmVyYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtSXNzdWVOb2RlKFxuICBub2RlOiBHcmFwaFFMSXNzdWVOb2RlLFxuICByYW5nZTogVGltZVJhbmdlRmlsdGVyXG4pOiBHaXRMYWJJc3N1ZVRpbWUge1xuICBjb25zdCB0aW1lbG9ncyA9IChub2RlLnRpbWVsb2dzPy5ub2RlcyA/PyBbXSlcbiAgICAuZmlsdGVyKChsb2cpOiBsb2cgaXMgTm9uTnVsbGFibGU8dHlwZW9mIGxvZz4gPT4ge1xuICAgICAgaWYgKCFsb2cgfHwgbG9nLnRpbWVTcGVudCA8PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1dpdGhpblJhbmdlKGxvZy5zcGVudEF0LCByYW5nZSk7XG4gICAgfSlcbiAgICAubWFwKChsb2cpID0+ICh7XG4gICAgICBpZDogbG9nLmlkLFxuICAgICAgc3BlbnRBdDogbG9nLnNwZW50QXQsXG4gICAgICBzZWNvbmRzOiBsb2cudGltZVNwZW50LFxuICAgICAgc3VtbWFyeTogbG9nLnN1bW1hcnksXG4gICAgICB1c2VyOiB7XG4gICAgICAgIGlkOiBsb2cudXNlcj8uaWQgPz8gXCJ1bmtub3duXCIsXG4gICAgICAgIG5hbWU6IGxvZy51c2VyPy5uYW1lID8/IFwiVW5rbm93blwiLFxuICAgICAgICB1c2VybmFtZTogbG9nLnVzZXI/LnVzZXJuYW1lID8/IFwidW5rbm93blwiXG4gICAgICB9XG4gICAgfSkpO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6IG5vZGUuaWQsXG4gICAgaWlkOiBub2RlLmlpZCxcbiAgICB0aXRsZTogbm9kZS50aXRsZSxcbiAgICB3ZWJVcmw6IG5vZGUud2ViVXJsLFxuICAgIHN0YXRlOiBub2RlLnN0YXRlLFxuICAgIGxhYmVsczogbm9kZS5sYWJlbHM/Lm5vZGVzPy5tYXAoKGxhYmVsKSA9PiBsYWJlbC50aXRsZSkgPz8gW10sXG4gICAgZXBpYzogbm9kZS5lcGljXG4gICAgICA/IHtcbiAgICAgICAgICBpZDogbm9kZS5lcGljLmlkLFxuICAgICAgICAgIGlpZDogbm9kZS5lcGljLmlpZCxcbiAgICAgICAgICB0aXRsZTogbm9kZS5lcGljLnRpdGxlLFxuICAgICAgICAgIHdlYlVybDogbm9kZS5lcGljLndlYlVybFxuICAgICAgICB9XG4gICAgICA6IG51bGwsXG4gICAgdGltZWxvZ3NcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNXaXRoaW5SYW5nZShzcGVudEF0OiBzdHJpbmcsIHJhbmdlOiBUaW1lUmFuZ2VGaWx0ZXIpOiBib29sZWFuIHtcbiAgaWYgKCFyYW5nZS5mcm9tICYmICFyYW5nZS50bykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5wYXJzZShzcGVudEF0KTtcbiAgaWYgKE51bWJlci5pc05hTih0aW1lc3RhbXApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAocmFuZ2UuZnJvbSkge1xuICAgIGNvbnN0IGZyb21UcyA9IERhdGUucGFyc2UocmFuZ2UuZnJvbSk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4oZnJvbVRzKSAmJiB0aW1lc3RhbXAgPCBmcm9tVHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAocmFuZ2UudG8pIHtcbiAgICBjb25zdCB0b1RzID0gRGF0ZS5wYXJzZShyYW5nZS50byk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4odG9UcykgJiYgdGltZXN0YW1wID49IHRvVHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYnVpbGRUaW1lU3VtbWFyeShpc3N1ZXM6IEdpdExhYklzc3VlVGltZVtdKTogVGltZVN1bW1hcnkge1xuICBsZXQgdG90YWxTZWNvbmRzID0gMDtcbiAgY29uc3QgYnlVc2VyID0gbmV3IE1hcDxzdHJpbmcsIFRpbWVTdW1tYXJ5R3JvdXA+KCk7XG4gIGNvbnN0IGJ5SXNzdWUgPSBuZXcgTWFwPHN0cmluZywgVGltZVN1bW1hcnlHcm91cD4oKTtcbiAgY29uc3QgYnlFcGljID0gbmV3IE1hcDxzdHJpbmcsIFRpbWVTdW1tYXJ5R3JvdXA+KCk7XG4gIGNvbnN0IGJ5RGF0ZSA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cbiAgZm9yIChjb25zdCBpc3N1ZSBvZiBpc3N1ZXMpIHtcbiAgICBsZXQgaXNzdWVTZWNvbmRzID0gMDtcbiAgICBmb3IgKGNvbnN0IHRpbWVsb2cgb2YgaXNzdWUudGltZWxvZ3MpIHtcbiAgICAgIHRvdGFsU2Vjb25kcyArPSB0aW1lbG9nLnNlY29uZHM7XG4gICAgICBpc3N1ZVNlY29uZHMgKz0gdGltZWxvZy5zZWNvbmRzO1xuXG4gICAgICBjb25zdCBkYXRlS2V5ID0gdGltZWxvZy5zcGVudEF0ID8gdGltZWxvZy5zcGVudEF0LnNsaWNlKDAsIDEwKSA6IFwidW5rbm93blwiO1xuICAgICAgYnlEYXRlLnNldChkYXRlS2V5LCAoYnlEYXRlLmdldChkYXRlS2V5KSA/PyAwKSArIHRpbWVsb2cuc2Vjb25kcyk7XG5cbiAgICAgIGNvbnN0IHVzZXJLZXkgPSB0aW1lbG9nLnVzZXIudXNlcm5hbWUgfHwgdGltZWxvZy51c2VyLmlkO1xuICAgICAgY29uc3QgdXNlckdyb3VwID0gYnlVc2VyLmdldCh1c2VyS2V5KSA/PyB7XG4gICAgICAgIGxhYmVsOiB0aW1lbG9nLnVzZXIubmFtZSxcbiAgICAgICAgc2Vjb25kczogMCxcbiAgICAgICAgaGludHM6IHtcbiAgICAgICAgICB1c2VybmFtZTogdGltZWxvZy51c2VyLnVzZXJuYW1lXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1c2VyR3JvdXAuc2Vjb25kcyArPSB0aW1lbG9nLnNlY29uZHM7XG4gICAgICBieVVzZXIuc2V0KHVzZXJLZXksIHVzZXJHcm91cCk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNzdWVHcm91cCA9IGJ5SXNzdWUuZ2V0KGlzc3VlLmlkKSA/PyB7XG4gICAgICBsYWJlbDogYCMke2lzc3VlLmlpZH0gJHtpc3N1ZS50aXRsZX1gLFxuICAgICAgc2Vjb25kczogMCxcbiAgICAgIGhpbnRzOiB7XG4gICAgICAgIGlzc3VlVXJsOiBpc3N1ZS53ZWJVcmwsXG4gICAgICAgIHN0YXRlOiBpc3N1ZS5zdGF0ZVxuICAgICAgfVxuICAgIH07XG4gICAgaXNzdWVHcm91cC5zZWNvbmRzICs9IGlzc3VlU2Vjb25kcztcbiAgICBieUlzc3VlLnNldChpc3N1ZS5pZCwgaXNzdWVHcm91cCk7XG5cbiAgICBjb25zdCBlcGljS2V5ID0gaXNzdWUuZXBpYz8uaWQgPz8gXCJ1bmFzc2lnbmVkXCI7XG4gICAgY29uc3QgZXBpY0xhYmVsID0gaXNzdWUuZXBpYyA/IGlzc3VlLmVwaWMudGl0bGUgOiBcIk5vIGVwaWNcIjtcbiAgICBjb25zdCBlcGljR3JvdXAgPSBieUVwaWMuZ2V0KGVwaWNLZXkpID8/IHtcbiAgICAgIGxhYmVsOiBlcGljTGFiZWwsXG4gICAgICBzZWNvbmRzOiAwLFxuICAgICAgaGludHM6IHtcbiAgICAgICAgZXBpY1VybDogaXNzdWUuZXBpYz8ud2ViVXJsID8/IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH07XG4gICAgZXBpY0dyb3VwLnNlY29uZHMgKz0gaXNzdWVTZWNvbmRzO1xuICAgIGJ5RXBpYy5zZXQoZXBpY0tleSwgZXBpY0dyb3VwKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG90YWxTZWNvbmRzLFxuICAgIGJ5VXNlcjogQXJyYXkuZnJvbShieVVzZXIudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGIuc2Vjb25kcyAtIGEuc2Vjb25kcyksXG4gICAgYnlJc3N1ZTogQXJyYXkuZnJvbShieUlzc3VlLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiBiLnNlY29uZHMgLSBhLnNlY29uZHMpLFxuICAgIGJ5RXBpYzogQXJyYXkuZnJvbShieUVwaWMudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGIuc2Vjb25kcyAtIGEuc2Vjb25kcyksXG4gICAgYnlEYXRlOiBBcnJheS5mcm9tKGJ5RGF0ZS5lbnRyaWVzKCkpXG4gICAgICAubWFwKChbZGF0ZSwgc2Vjb25kc10pID0+ICh7IGRhdGUsIHNlY29uZHMgfSkpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5kYXRlLmxvY2FsZUNvbXBhcmUoYi5kYXRlKSlcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlY29uZHNUb0hvdXJzKHNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLnJvdW5kKChzZWNvbmRzIC8gMzYwMCkgKiAxMDApIC8gMTAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RHVyYXRpb24oc2Vjb25kczogbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKHNlY29uZHMgLyAzNjAwKTtcbiAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IoKHNlY29uZHMgJSAzNjAwKSAvIDYwKTtcbiAgaWYgKGhvdXJzID09PSAwICYmIG1pbnV0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gXCI8MW1cIjtcbiAgfVxuICBpZiAoaG91cnMgPT09IDApIHtcbiAgICByZXR1cm4gYCR7bWludXRlc31tYDtcbiAgfVxuICBpZiAobWludXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBgJHtob3Vyc31oYDtcbiAgfVxuICByZXR1cm4gYCR7aG91cnN9aCAke21pbnV0ZXN9bWA7XG59XG4iXSwibmFtZXMiOlsiREVGQVVMVF9HUkFQSFFMX0VORFBPSU5UIiwiREVGQVVMVF9JU1NVRV9QQUdFX1NJWkUiLCJERUZBVUxUX1RJTUVMT0dfUEFHRV9TSVpFIiwiSVNTVUVfVElNRUxPR1NfUVVFUlkiLCJmZXRjaFByb2plY3RUaW1lUmVwb3J0IiwicHJvamVjdEZ1bGxQYXRoIiwiY3JlZGVudGlhbHMiLCJyYW5nZSIsImlzc3VlUGFnZVNpemUiLCJ0aW1lbG9nUGFnZVNpemUiLCJhcGlVcmwiLCJ0cmltIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJ0b2tlbiIsIkVycm9yIiwiaXNzdWVzIiwicGFnZUluZm8iLCJwcm9qZWN0TWV0YSIsInBheWxvYWQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJxdWVyeSIsInZhcmlhYmxlcyIsImZ1bGxQYXRoIiwiaXNzdWVzRmlyc3QiLCJpc3N1ZXNBZnRlciIsImVuZEN1cnNvciIsInRpbWVsb2dGaXJzdCIsIm9rIiwibWVzc2FnZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJqc29uIiwiZXJyb3JzIiwibGVuZ3RoIiwibWFwIiwiZXJyIiwiam9pbiIsImRhdGEiLCJwcm9qZWN0IiwiaWQiLCJuYW1lIiwid2ViVXJsIiwiY3VycmVudElzc3VlcyIsIm5vZGVzIiwibm9kZSIsInRyYW5zZm9ybUlzc3VlTm9kZSIsInB1c2giLCJoYXNOZXh0UGFnZSIsInN1bW1hcnkiLCJidWlsZFRpbWVTdW1tYXJ5IiwiZ2VuZXJhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ0aW1lbG9ncyIsImZpbHRlciIsImxvZyIsInRpbWVTcGVudCIsImlzV2l0aGluUmFuZ2UiLCJzcGVudEF0Iiwic2Vjb25kcyIsInVzZXIiLCJ1c2VybmFtZSIsImlpZCIsInRpdGxlIiwic3RhdGUiLCJsYWJlbHMiLCJsYWJlbCIsImVwaWMiLCJmcm9tIiwidG8iLCJ0aW1lc3RhbXAiLCJwYXJzZSIsIk51bWJlciIsImlzTmFOIiwiZnJvbVRzIiwidG9UcyIsInRvdGFsU2Vjb25kcyIsImJ5VXNlciIsIk1hcCIsImJ5SXNzdWUiLCJieUVwaWMiLCJieURhdGUiLCJpc3N1ZSIsImlzc3VlU2Vjb25kcyIsInRpbWVsb2ciLCJkYXRlS2V5Iiwic2xpY2UiLCJzZXQiLCJnZXQiLCJ1c2VyS2V5IiwidXNlckdyb3VwIiwiaGludHMiLCJpc3N1ZUdyb3VwIiwiaXNzdWVVcmwiLCJlcGljS2V5IiwiZXBpY0xhYmVsIiwiZXBpY0dyb3VwIiwiZXBpY1VybCIsInVuZGVmaW5lZCIsIkFycmF5IiwidmFsdWVzIiwic29ydCIsImEiLCJiIiwiZW50cmllcyIsImRhdGUiLCJsb2NhbGVDb21wYXJlIiwic2Vjb25kc1RvSG91cnMiLCJNYXRoIiwicm91bmQiLCJmb3JtYXREdXJhdGlvbiIsImhvdXJzIiwiZmxvb3IiLCJtaW51dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/lib/gitlab.ts\n"));

/***/ })

});